{
  "name": "gitlab-decision-notify",
  "nodes": [
    {
      "parameters": {
        "path": "gitlab/decision/notify",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "1",
      "name": "Webhook (GitLab)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        200,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const headers = ($json && $json.headers) ? $json.headers : {};\nconst body = ($json && $json.body) ? $json.body : ($json ?? {});\nconst env = $env || {};\n\nfunction getHeader(name) {\n  const lower = String(name || '').toLowerCase();\n  if (headers[lower] !== undefined) return headers[lower];\n  if (headers[name] !== undefined) return headers[name];\n  const key = Object.keys(headers).find((k) => k.toLowerCase() === lower);\n  return key ? headers[key] : undefined;\n}\n\nfunction isTruthy(value) {\n  if (value === undefined || value === null) return false;\n  const v = String(value).toLowerCase();\n  return ['1', 'true', 'yes', 'y', 'on'].includes(v);\n}\n\nfunction error(status, message, extra = {}) {\n  return [{\n    json: {\n      ok: false,\n      status_code: status,\n      error: message,\n      ...extra,\n    }\n  }];\n}\n\nfunction pickFirst(paths, fallback = null) {\n  for (const path of paths) {\n    const parts = String(path).split('.').filter(Boolean);\n    let cur = body;\n    for (const part of parts) {\n      if (cur === null || cur === undefined) {\n        cur = undefined;\n        break;\n      }\n      cur = cur?.[part];\n    }\n    if (cur !== undefined && cur !== null && String(cur).trim() !== '') return cur;\n  }\n  return fallback;\n}\n\nfunction parseList(value) {\n  if (!value) return [];\n  if (Array.isArray(value)) return value.filter(Boolean);\n  return String(value)\n    .split(',')\n    .map((v) => v.trim())\n    .filter(Boolean);\n}\n\nfunction firstNonEmptyLine(text) {\n  const lines = String(text || '').split(/\\r?\\n/);\n  for (const line of lines) {\n    const t = String(line || '').trim();\n    if (t) return t;\n  }\n  return '';\n}\n\nfunction matchPrefix(line, prefixes) {\n  const raw = String(line || '').trim();\n  if (!raw) return '';\n  const lower = raw.toLowerCase();\n  for (const prefix of prefixes || []) {\n    const p = String(prefix || '').trim();\n    if (!p) continue;\n    const pl = p.toLowerCase();\n    if (lower.startsWith(pl)) return p;\n  }\n  return '';\n}\n\nfunction stripAnyPrefix(text, prefix) {\n  const trimmed = String(text || '').trim();\n  if (!prefix) return trimmed;\n  let rest = trimmed.slice(String(prefix).trim().length);\n  rest = rest.replace(/^\\s*[:：]\\s*/, '');\n  return rest.trim();\n}\n\nfunction isZulipEvidenceText(text) {\n  const t = String(text || '');\n  // Avoid loop: skip comments created by Zulip->GitLab sync.\n  if (t.includes('### 決定（Zulip）')) return true;\n  if (t.includes('### Zulip更新')) return true;\n  if (t.includes('### Zulipクローズ')) return true;\n  if (t.includes('### Zulip再オープン')) return true;\n  return false;\n}\n\nfunction findZulipNarrowUrl(text) {\n  const t = String(text || '');\n  const m = t.match(/https?:\\/\\/[^\\s]+#narrow\\/stream\\/(\\d+)\\/topic\\/([^\\s/]+)(?:\\/near\\/(\\d+))?/);\n  if (!m) return null;\n  const streamId = m[1];\n  const topicEncoded = m[2];\n  const msgId = m[3] || '';\n  let topic = topicEncoded;\n  try {\n    topic = decodeURIComponent(topicEncoded);\n  } catch (err) {}\n  return {\n    url: m[0],\n    stream_id: streamId,\n    topic,\n    near: msgId,\n  };\n}\n\nfunction trimSlash(value) {\n  return String(value || '').trim().replace(/\\/+$/, '');\n}\n\nfunction buildZulipApiBase(baseOverride) {\n  const baseRaw = trimSlash(\n    baseOverride\n      || env.N8N_ZULIP_API_BASE_URL\n      || env.ZULIP_API_MESS_BASE_URL\n      || env.ZULIP_API_BASE_URL\n      || env.N8N_ZULIP_BASE_URL\n      || env.ZULIP_BASE_URL\n      || env.SERVICE_URL_ZULIP\n      || env.ZULIP_URL\n      || ''\n  );\n  if (!baseRaw) return '';\n  if (baseRaw.endsWith('/api/v1')) return baseRaw;\n  return `${baseRaw}/api/v1`;\n}\n\nfunction parseJsonMap(text) {\n  if (!text) return {};\n  try {\n    const obj = JSON.parse(String(text));\n    if (obj && typeof obj === 'object' && !Array.isArray(obj)) return obj;\n  } catch (err) {}\n  return {};\n}\n\nfunction parseYamlMap(text) {\n  const map = {};\n  if (!text) return map;\n  const newlineRe = new RegExp('(?:\\r?\\n|\\\\n)');\n  const lines = String(text || '').split(newlineRe);\n  for (const line of lines) {\n    const trimmed = String(line || '').trim();\n    if (!trimmed || trimmed.startsWith('#')) continue;\n    const idx = trimmed.indexOf(':');\n    if (idx <= 0) continue;\n    const key = trimmed.slice(0, idx).trim();\n    let value = trimmed.slice(idx + 1).trim();\n    if (!key) continue;\n    if ((value.startsWith('\"') && value.endsWith('\"')) || (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\n      value = value.slice(1, -1);\n    }\n    map[key] = value;\n  }\n  return map;\n}\n\nfunction loadRealmMap(jsonText, yamlText) {\n  const jsonMap = parseJsonMap(jsonText);\n  if (jsonMap && Object.keys(jsonMap).length) return jsonMap;\n  return parseYamlMap(yamlText);\n}\n\nfunction pickRealmValue(map, realmKey) {\n  if (!map || typeof map !== 'object') return '';\n  const realmStr = String(realmKey || '').trim();\n  const candidates = [realmStr, realmStr.toLowerCase(), 'default', '*'];\n  for (const key of candidates) {\n    if (!key) continue;\n    const value = map[key];\n    if (value === undefined || value === null) continue;\n    const trimmed = String(value).trim();\n    if (trimmed) return trimmed;\n  }\n  return '';\n}\n\nfunction deriveRealmFromProjectPath(path) {\n  const p = String(path || '').trim();\n  if (!p) return '';\n  const first = p.split('/')[0] || '';\n  return first.trim();\n}\n\nfunction looksLikeYamlMap(text) {\n  const t = String(text || '').trim();\n  if (!t) return false;\n  if (/^https?:\\/\\//i.test(t)) return false;\n  if (t.includes(String.fromCharCode(10)) || t.includes(String.fromCharCode(13)) || t.includes('\\\\n')) return true;\n  if (/^\\s*(default|\\*)\\s*:\\s*\\S+/i.test(t)) return true;\n  return false;\n}\n\nfunction resolveGitlabWebhookSecretsMap() {\n  const json = String(env.GITLAB_WEBHOOK_SECRETS_JSON || '').trim();\n  const yaml = String(env.GITLAB_WEBHOOK_SECRETS_YAML || '').trim();\n  if (json || yaml) return loadRealmMap(json, yaml);\n  const raw = String(env.GITLAB_WEBHOOK_SECRET || '').trim();\n  if (looksLikeYamlMap(raw)) return loadRealmMap('', raw);\n  return {};\n}\n\nconst token = String(getHeader('x-gitlab-token') || '').trim();\nconst scalarSecret = String(env.GITLAB_WEBHOOK_SECRET || '').trim();\nconst secretMap = resolveGitlabWebhookSecretsMap();\n\nconst hasAnySecret = Boolean(scalarSecret) || (secretMap && Object.keys(secretMap).length);\nif (!hasAnySecret) {\n  return error(424, 'missing webhook secret', { missing: ['GITLAB_WEBHOOK_SECRET (or GITLAB_WEBHOOK_SECRETS_YAML/JSON)'] });\n}\n\nlet secretOk = false;\nlet matchedSecretKey = '';\nif (scalarSecret && token && token === scalarSecret) {\n  secretOk = true;\n}\nif (!secretOk && token) {\n  for (const [k, v] of Object.entries(secretMap || {})) {\n    const vv = String(v || '').trim();\n    if (!vv) continue;\n    if (token === vv) {\n      secretOk = true;\n      matchedSecretKey = k;\n      break;\n    }\n  }\n}\n\nif (!secretOk) {\n  return error(401, 'invalid token');\n}\n\nconst eventHeader = (getHeader('x-gitlab-event') || body.event_type || body.object_kind || '').toString();\nconst event = eventHeader.toLowerCase();\n\n// GitLab payload fields vary by event.\nconst objectKind = String(body.object_kind || '').toLowerCase();\n\nconst actor = pickFirst([\n  'user.username',\n  'user.name',\n  'user_username',\n  'user_name',\n  'user.email',\n  'user_email'\n], 'unknown');\n\nconst projectPath = pickFirst([\n  'project.path_with_namespace',\n  'project.path',\n  'project.path_with_namespace',\n], null);\n\nconst issueTitle = pickFirst([\n  'issue.title',\n  'object_attributes.title',\n], '');\n\nconst issueUrl = pickFirst([\n  'issue.url',\n  'object_attributes.url',\n  'object_attributes.noteable_url',\n], '');\n\nconst issueDescription = pickFirst([\n  'issue.description',\n  'object_attributes.description',\n], '');\n\nconst noteText = pickFirst([\n  'object_attributes.note',\n], '');\n\nconst noteUrl = pickFirst([\n  'object_attributes.url',\n], '');\n\nconst realmFromProject = deriveRealmFromProjectPath(projectPath);\nconst realm = realmFromProject\n  || (matchedSecretKey && matchedSecretKey !== 'default' ? String(matchedSecretKey).trim() : '')\n  || String(env.N8N_REALM || env.N8N_OBSERVER_REALM || env.ZULIP_REALM || 'default').trim()\n  || 'default';\n\nfunction resolveZulipCredentials(realmKey) {\n  const rk = String(realmKey || '').trim() || 'default';\n\n  const baseFromMap = pickRealmValue(\n    loadRealmMap(env.N8N_ZULIP_API_BASE_URL || env.ZULIP_API_MESS_BASE_URL || '', env.N8N_ZULIP_API_BASE_URL || env.ZULIP_API_MESS_BASE_URL || ''),\n    rk\n  );\n\n  let uiBaseOverride = trimSlash(baseFromMap);\n  if (uiBaseOverride.endsWith('/api/v1')) uiBaseOverride = uiBaseOverride.slice(0, -'/api/v1'.length);\n\n  if (!uiBaseOverride && env.ZULIP_REALM_URL_TEMPLATE) {\n    uiBaseOverride = String(env.ZULIP_REALM_URL_TEMPLATE).replace(/\\{realm\\}/g, rk);\n  }\n  if (!uiBaseOverride && env.HOSTED_ZONE_NAME) {\n    const hz = String(env.HOSTED_ZONE_NAME).replace(/^\\.+|\\.+$/g, '');\n    uiBaseOverride = `https://${rk}.zulip.${hz}`;\n  }\n\n  const apiBase = buildZulipApiBase(uiBaseOverride);\n\n  const emailFromMap = pickRealmValue(\n    loadRealmMap(env.N8N_ZULIP_BOT_EMAIL || env.ZULIP_MESS_BOT_EMAIL || '', env.N8N_ZULIP_BOT_EMAIL || env.ZULIP_MESS_BOT_EMAIL || ''),\n    rk\n  );\n  const tokenFromMap = pickRealmValue(\n    loadRealmMap(env.N8N_ZULIP_BOT_TOKEN || env.ZULIP_MESS_BOT_TOKEN || '', env.N8N_ZULIP_BOT_TOKEN || env.ZULIP_MESS_BOT_TOKEN || ''),\n    rk\n  );\n\n  const email = String(\n    emailFromMap\n      || env.ZULIP_MESS_BOT_EMAIL\n      || env.ZULIP_BOT_EMAIL\n      || env.N8N_ZULIP_BOT_EMAIL\n      || ''\n  ).trim();\n\n  const apiKey = String(\n    tokenFromMap\n      || env.ZULIP_MESS_BOT_TOKEN\n      || env.ZULIP_BOT_API_KEY\n      || env.ZULIP_API_KEY\n      || env.ZULIP_BOT_TOKEN\n      || env.N8N_ZULIP_BOT_TOKEN\n      || ''\n  ).trim();\n\n  return { api_base: apiBase, email, api_key: apiKey };\n}\n\nconst zulip = resolveZulipCredentials(realm);\nif (!zulip.api_base || !zulip.email || !zulip.api_key) {\n  return error(500, 'Zulip credentials are missing', {\n    missing: [\n      !zulip.api_base ? 'N8N_ZULIP_API_BASE_URL/YAML or ZULIP_REALM_URL_TEMPLATE or HOSTED_ZONE_NAME (or ZULIP_BASE_URL)' : null,\n      !zulip.email ? 'N8N_ZULIP_BOT_EMAIL/YAML (or ZULIP_BOT_EMAIL)' : null,\n      !zulip.api_key ? 'N8N_ZULIP_BOT_TOKEN/YAML (or ZULIP_API_KEY/ZULIP_BOT_API_KEY)' : null,\n    ].filter(Boolean),\n    realm,\n    project_path: projectPath,\n  });\n}\n\nconst decisionPrefixes = parseList(env.GITLAB_DECISION_PREFIXES || '[DECISION],決定:,DECISION:');\nconst dryRun = isTruthy(env.GITLAB_DECISION_NOTIFY_DRY_RUN);\n\n// Decide which text to inspect for decision.\nconst candidateTexts = [];\nif (objectKind === 'note' || event.includes('note')) {\n  if (noteText) candidateTexts.push(noteText);\n} else if (objectKind === 'issue' || event.includes('issue')) {\n  if (issueDescription) candidateTexts.push(issueDescription);\n}\n\n// Always allow explicit decision in the webhook payload even if event type differs.\nif (noteText && !candidateTexts.includes(noteText)) candidateTexts.push(noteText);\n\nconst inspected = candidateTexts.find((t) => String(t || '').trim() !== '') || '';\nif (!inspected) {\n  return [{ json: { ok: true, status_code: 200, skipped: true, reason: 'no_text', event: eventHeader } }];\n}\n\nif (isZulipEvidenceText(inspected)) {\n  return [{ json: { ok: true, status_code: 200, skipped: true, reason: 'zulip_evidence', event: eventHeader } }];\n}\n\nconst firstLine = firstNonEmptyLine(inspected);\nconst marker = matchPrefix(firstLine, decisionPrefixes);\nif (!marker) {\n  return [{ json: { ok: true, status_code: 200, skipped: true, reason: 'no_decision_marker', event: eventHeader } }];\n}\n\nconst decisionBody = stripAnyPrefix(inspected, marker).slice(0, 1000);\n\n// Resolve Zulip stream/topic from the issue description (preferred) || note text.\nconst narrow = findZulipNarrowUrl(issueDescription) || findZulipNarrowUrl(noteText) || findZulipNarrowUrl(inspected);\n\nconst fallbackStream = String(env.GITLAB_DECISION_FALLBACK_STREAM || '').trim();\nconst fallbackTopic = String(env.GITLAB_DECISION_FALLBACK_TOPIC || 'decisions').trim();\n\nlet stream = '';\nlet topic = '';\nif (narrow) {\n  stream = String(narrow.stream_id);\n  topic = String(narrow.topic);\n} else if (fallbackStream) {\n  stream = fallbackStream;\n  topic = fallbackTopic;\n}\n\nif (!stream || !topic) {\n  return [{\n    json: {\n      ok: true,\n      status_code: 200,\n      skipped: true,\n      reason: 'missing_zulip_destination',\n      event: eventHeader,\n      issue_url: issueUrl,\n      project_path: projectPath,\n      realm,\n    }\n  }];\n}\n\n// Idempotency: avoid duplicate notifications for the same note/issue update.\nconst state = (typeof this.getWorkflowStaticData === 'function')\n  ? this.getWorkflowStaticData('global')\n  : (typeof $getWorkflowStaticData === 'function' ? $getWorkflowStaticData('global') : {});\nstate.seen = state.seen || {};\n\nconst noteId = pickFirst(['object_attributes.id', 'object_attributes.note_id'], '');\nconst issueId = pickFirst(['issue.id', 'object_attributes.iid', 'object_attributes.id'], '');\nconst key = `${eventHeader}:${projectPath || ''}:${issueId}:${noteId}:${marker}:${stream}:${topic}`;\nif (state.seen[key]) {\n  return [{ json: { ok: true, status_code: 200, skipped: true, reason: 'duplicate', key } }];\n}\nstate.seen[key] = new Date().toISOString();\n\n// Prune state\nconst keys = Object.keys(state.seen);\nif (keys.length > 500) {\n  for (const k of keys.slice(0, keys.length - 500)) {\n    delete state.seen[k];\n  }\n}\n\nconst lines = [\n  'GitLab で決定が記載されました',\n  `Realm: ${realm}`,\n  `Actor: ${actor}`,\n  issueTitle ? `Issue: ${issueTitle}` : null,\n  (noteUrl || issueUrl) ? `URL: ${noteUrl || issueUrl}` : null,\n  `Marker: ${marker}`,\n  '',\n  decisionBody ? decisionBody : '(本文なし)',\n].filter((v) => v !== null);\n\nconst content = lines.join('\\n');\n\nif (dryRun) {\n  return [{\n    json: {\n      ok: true,\n      status_code: 200,\n      dry_run: true,\n      realm,\n      stream,\n      topic,\n      marker,\n      issue_url: issueUrl,\n      note_url: noteUrl,\n    }\n  }];\n}\n\nconst auth = Buffer.from(`${zulip.email}:${zulip.api_key}`).toString('base64');\nconst formBody = Object.entries({\n  type: 'stream',\n  to: String(stream),\n  topic: String(topic),\n  content,\n})\n  .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(String(v))}`)\n  .join('&');\n\ntry {\n  await this.helpers.httpRequest({\n    method: 'POST',\n    url: `${zulip.api_base}/messages`,\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      Authorization: `Basic ${auth}`,\n    },\n    body: formBody,\n  });\n  return [{ json: { ok: true, status_code: 200, realm, stream, topic, marker } }];\n} catch (err) {\n  const status = err?.response?.statusCode || err?.statusCode || err?.httpCode || null;\n  const responseBody = err?.response?.body || err?.response?.data || null;\n  return [{\n    json: {\n      ok: false,\n      status_code: status || 500,\n      error: String(err?.message || err),\n      response_body: responseBody,\n      realm,\n      stream,\n      topic,\n      marker,\n    }\n  }];\n}\n"
      },
      "id": "2",
      "name": "Process + Notify",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        200
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": "={{ $json.status_code || 200 }}"
        }
      },
      "id": "3",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        700,
        200
      ]
    }
  ],
  "connections": {
    "Webhook (GitLab)": {
      "main": [
        [
          {
            "node": "Process + Notify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process + Notify": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}
