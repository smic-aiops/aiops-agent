{
  "name": "gitlab-decision-notify",
  "nodes": [
    {
      "parameters": {
        "path": "gitlab/decision/notify",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "1",
      "name": "Webhook (GitLab)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        200,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const headers = ($json && $json.headers) ? $json.headers : {};\nconst body = ($json && $json.body) ? $json.body : ($json ?? {});\nconst env = $env || {};\n\nfunction getHeader(name) {\n  const lower = String(name || '').toLowerCase();\n  if (headers[lower] !== undefined) return headers[lower];\n  if (headers[name] !== undefined) return headers[name];\n  const key = Object.keys(headers).find((k) => k.toLowerCase() === lower);\n  return key ? headers[key] : undefined;\n}\n\nfunction isTruthy(value) {\n  if (value === undefined || value === null) return false;\n  const v = String(value).toLowerCase();\n  return ['1', 'true', 'yes', 'y', 'on'].includes(v);\n}\n\nfunction error(status, message, extra = {}) {\n  return [{\n    json: {\n      ok: false,\n      status_code: status,\n      error: message,\n      ...extra,\n    }\n  }];\n}\n\nfunction pickFirst(paths, fallback = null) {\n  for (const path of paths) {\n    const parts = String(path).split('.').filter(Boolean);\n    let cur = body;\n    for (const part of parts) {\n      if (cur === null || cur === undefined) {\n        cur = undefined;\n        break;\n      }\n      cur = cur?.[part];\n    }\n    if (cur !== undefined && cur !== null && String(cur).trim() !== '') return cur;\n  }\n  return fallback;\n}\n\nfunction parseList(value) {\n  if (!value) return [];\n  if (Array.isArray(value)) return value.filter(Boolean);\n  return String(value)\n    .split(',')\n    .map((v) => v.trim())\n    .filter(Boolean);\n}\n\nfunction firstNonEmptyLine(text) {\n  const lines = String(text || '').split(/\\r?\\n/);\n  for (const line of lines) {\n    const t = String(line || '').trim();\n    if (t) return t;\n  }\n  return '';\n}\n\nfunction matchPrefix(line, prefixes) {\n  const raw = String(line || '').trim();\n  if (!raw) return '';\n  const lower = raw.toLowerCase();\n  for (const prefix of prefixes || []) {\n    const p = String(prefix || '').trim();\n    if (!p) continue;\n    const pl = p.toLowerCase();\n    if (lower.startsWith(pl)) return p;\n  }\n  return '';\n}\n\nfunction stripAnyPrefix(text, prefix) {\n  const trimmed = String(text || '').trim();\n  if (!prefix) return trimmed;\n  let rest = trimmed.slice(String(prefix).trim().length);\n  rest = rest.replace(/^\\s*[:：]\\s*/, '');\n  return rest.trim();\n}\n\nfunction parseJsonFromText(text) {\n  const raw = String(text || '').trim();\n  if (!raw) return null;\n  const cleaned = raw.replace(/^```(?:json)?\\s*/i, '').replace(/```\\s*$/i, '').trim();\n  try { return JSON.parse(cleaned); } catch (error) {}\n  const start = cleaned.indexOf('{');\n  const end = cleaned.lastIndexOf('}');\n  if (start >= 0 && end > start) {\n    try { return JSON.parse(cleaned.slice(start, end + 1)); } catch (error) {}\n  }\n  return null;\n}\n\nasync function detectDecisionByLlm(text) {\n  if (!decisionLlmEnabled) return null;\n  if (!decisionLlmApiKey || !decisionLlmApiBase || !decisionLlmModel) return null;\n  const t = String(text || '').trim();\n  if (!t) return null;\n  if (decisionLlmCalls >= decisionLlmMaxCalls) return null;\n  decisionLlmCalls += 1;\n  let response;\n  try {\n    response = await this.helpers.httpRequest({\n      method: 'POST',\n      url: `${decisionLlmApiBase}/chat/completions`,\n      json: true,\n      timeout: 8000,\n      headers: { Authorization: `Bearer ${decisionLlmApiKey}` },\n      body: {\n        model: decisionLlmModel,\n        temperature: 0,\n        max_tokens: 200,\n        messages: [\n          { role: 'system', content: 'あなたは短文が「決定/承認（実施・採用・却下・クローズ等の意思決定）」に該当するかを判定する分類器です。出力は必ずJSONのみ。キーは is_decision(boolean), confidence(0-1), category(string), reason(string,短く)。疑わしい場合は is_decision=false。' },\n          { role: 'user', content: JSON.stringify({ text: t.slice(0, decisionLlmMaxTextChars) }) }\n        ]\n      }\n    });\n  } catch (error) {\n    return null;\n  }\n  const content = response?.choices?.[0]?.message?.content ?? '';\n  const parsed = parseJsonFromText(content);\n  const confRaw = Number(parsed?.confidence);\n  const conf = Number.isFinite(confRaw) ? Math.max(0, Math.min(1, confRaw)) : 0;\n  const rawDecision = Boolean(parsed?.is_decision);\n  const isDecision = rawDecision && conf >= decisionLlmMinConfidence;\n  return { is_decision: isDecision, confidence: conf, method: 'llm', category: parsed?.category ?? null, reason: parsed?.reason ?? null };\n}\n\nfunction isZulipEvidenceText(text) {\n  const t = String(text || '');\n  // Avoid loop: skip comments created by Zulip->GitLab sync.\n  if (t.includes('### 決定（Zulip）')) return true;\n  if (t.includes('### Zulip更新')) return true;\n  if (t.includes('### Zulipクローズ')) return true;\n  if (t.includes('### Zulip再オープン')) return true;\n  return false;\n}\n\nfunction findZulipNarrowUrl(text) {\n  const t = String(text || '');\n  const m = t.match(/https?:\\/\\/[^\\s]+#narrow\\/stream\\/(\\d+)\\/topic\\/([^\\s/]+)(?:\\/near\\/(\\d+))?/);\n  if (!m) return null;\n  const streamId = m[1];\n  const topicEncoded = m[2];\n  const msgId = m[3] || '';\n  let topic = topicEncoded;\n  try {\n    topic = decodeURIComponent(topicEncoded);\n  } catch (err) {}\n  return {\n    url: m[0],\n    stream_id: streamId,\n    topic,\n    near: msgId,\n  };\n}\n\nfunction trimSlash(value) {\n  return String(value || '').trim().replace(/\\/+$/, '');\n}\n\nfunction buildZulipApiBase(baseOverride) {\n  const baseRaw = trimSlash(\n    baseOverride\n      || env.N8N_ZULIP_API_BASE_URL\n      || env.ZULIP_API_MESS_BASE_URL\n      || env.ZULIP_API_BASE_URL\n      || env.N8N_ZULIP_BASE_URL\n      || env.ZULIP_BASE_URL\n      || env.SERVICE_URL_ZULIP\n      || env.ZULIP_URL\n      || ''\n  );\n  if (!baseRaw) return '';\n  if (baseRaw.endsWith('/api/v1')) return baseRaw;\n  return `${baseRaw}/api/v1`;\n}\n\nfunction parseJsonMap(text) {\n  if (!text) return {};\n  try {\n    const obj = JSON.parse(String(text));\n    if (obj && typeof obj === 'object' && !Array.isArray(obj)) return obj;\n  } catch (err) {}\n  return {};\n}\n\nfunction parseYamlMap(text) {\n  const map = {};\n  if (!text) return map;\n  const newlineRe = new RegExp('(?:\\r?\\n|\\\\n)');\n  const lines = String(text || '').split(newlineRe);\n  for (const line of lines) {\n    const trimmed = String(line || '').trim();\n    if (!trimmed || trimmed.startsWith('#')) continue;\n    const idx = trimmed.indexOf(':');\n    if (idx <= 0) continue;\n    const key = trimmed.slice(0, idx).trim();\n    let value = trimmed.slice(idx + 1).trim();\n    if (!key) continue;\n    if ((value.startsWith('\"') && value.endsWith('\"')) || (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\n      value = value.slice(1, -1);\n    }\n    map[key] = value;\n  }\n  return map;\n}\n\nfunction loadRealmMap(jsonText, yamlText) {\n  const jsonMap = parseJsonMap(jsonText);\n  if (jsonMap && Object.keys(jsonMap).length) return jsonMap;\n  return parseYamlMap(yamlText);\n}\n\nfunction pickRealmValue(map, realmKey) {\n  if (!map || typeof map !== 'object') return '';\n  const realmStr = String(realmKey || '').trim();\n  const candidates = [realmStr, realmStr.toLowerCase(), 'default', '*'];\n  for (const key of candidates) {\n    if (!key) continue;\n    const value = map[key];\n    if (value === undefined || value === null) continue;\n    const trimmed = String(value).trim();\n    if (trimmed) return trimmed;\n  }\n  return '';\n}\n\nfunction deriveRealmFromProjectPath(path) {\n  const p = String(path || '').trim();\n  if (!p) return '';\n  const first = p.split('/')[0] || '';\n  return first.trim();\n}\n\nfunction looksLikeYamlMap(text) {\n  const t = String(text || '').trim();\n  if (!t) return false;\n  if (/^https?:\\/\\//i.test(t)) return false;\n  if (t.includes(String.fromCharCode(10)) || t.includes(String.fromCharCode(13)) || t.includes('\\\\n')) return true;\n  if (/^\\s*(default|\\*)\\s*:\\s*\\S+/i.test(t)) return true;\n  return false;\n}\n\nfunction resolveGitlabWebhookSecretsMap() {\n  const json = String(env.GITLAB_WEBHOOK_SECRETS_JSON || '').trim();\n  const yaml = String(env.GITLAB_WEBHOOK_SECRETS_YAML || '').trim();\n  if (json || yaml) return loadRealmMap(json, yaml);\n  const raw = String(env.GITLAB_WEBHOOK_SECRET || '').trim();\n  if (looksLikeYamlMap(raw)) return loadRealmMap('', raw);\n  return {};\n}\n\nconst token = String(getHeader('x-gitlab-token') || '').trim();\nconst scalarSecret = String(env.GITLAB_WEBHOOK_SECRET || '').trim();\nconst secretMap = resolveGitlabWebhookSecretsMap();\n\nconst hasAnySecret = Boolean(scalarSecret) || (secretMap && Object.keys(secretMap).length);\nif (!hasAnySecret) {\n  return error(424, 'missing webhook secret', { missing: ['GITLAB_WEBHOOK_SECRET (or GITLAB_WEBHOOK_SECRETS_YAML/JSON)'] });\n}\n\nlet secretOk = false;\nlet matchedSecretKey = '';\nif (scalarSecret && token && token === scalarSecret) {\n  secretOk = true;\n}\nif (!secretOk && token) {\n  for (const [k, v] of Object.entries(secretMap || {})) {\n    const vv = String(v || '').trim();\n    if (!vv) continue;\n    if (token === vv) {\n      secretOk = true;\n      matchedSecretKey = k;\n      break;\n    }\n  }\n}\n\nif (!secretOk) {\n  return error(401, 'invalid token');\n}\n\nconst eventHeader = (getHeader('x-gitlab-event') || body.event_type || body.object_kind || '').toString();\nconst event = eventHeader.toLowerCase();\n\n// GitLab payload fields vary by event.\nconst objectKind = String(body.object_kind || '').toLowerCase();\n\nconst actor = pickFirst([\n  'user.username',\n  'user.name',\n  'user_username',\n  'user_name',\n  'user.email',\n  'user_email'\n], 'unknown');\n\nconst projectPath = pickFirst([\n  'project.path_with_namespace',\n  'project.path',\n  'project.path_with_namespace',\n], null);\n\nconst issueTitle = pickFirst([\n  'issue.title',\n  'object_attributes.title',\n], '');\n\nconst issueUrl = pickFirst([\n  'issue.url',\n  'object_attributes.url',\n  'object_attributes.noteable_url',\n], '');\n\nconst issueDescription = pickFirst([\n  'issue.description',\n  'object_attributes.description',\n], '');\n\nconst noteText = pickFirst([\n  'object_attributes.note',\n], '');\n\nconst noteUrl = pickFirst([\n  'object_attributes.url',\n], '');\n\nconst realmFromProject = deriveRealmFromProjectPath(projectPath);\nconst realm = realmFromProject\n  || (matchedSecretKey && matchedSecretKey !== 'default' ? String(matchedSecretKey).trim() : '')\n  || String(env.N8N_REALM || env.N8N_OBSERVER_REALM || env.ZULIP_REALM || 'default').trim()\n  || 'default';\n\nfunction resolveZulipCredentials(realmKey) {\n  const rk = String(realmKey || '').trim() || 'default';\n\n  const baseFromMap = pickRealmValue(\n    loadRealmMap(env.N8N_ZULIP_API_BASE_URL || env.ZULIP_API_MESS_BASE_URL || '', env.N8N_ZULIP_API_BASE_URL || env.ZULIP_API_MESS_BASE_URL || ''),\n    rk\n  );\n\n  let uiBaseOverride = trimSlash(baseFromMap);\n  if (uiBaseOverride.endsWith('/api/v1')) uiBaseOverride = uiBaseOverride.slice(0, -'/api/v1'.length);\n\n  if (!uiBaseOverride && env.ZULIP_REALM_URL_TEMPLATE) {\n    uiBaseOverride = String(env.ZULIP_REALM_URL_TEMPLATE).replace(/\\{realm\\}/g, rk);\n  }\n  if (!uiBaseOverride && env.HOSTED_ZONE_NAME) {\n    const hz = String(env.HOSTED_ZONE_NAME).replace(/^\\.+|\\.+$/g, '');\n    uiBaseOverride = `https://${rk}.zulip.${hz}`;\n  }\n\n  const apiBase = buildZulipApiBase(uiBaseOverride);\n\n  const emailFromMap = pickRealmValue(\n    loadRealmMap(env.N8N_ZULIP_BOT_EMAIL || env.ZULIP_MESS_BOT_EMAIL || '', env.N8N_ZULIP_BOT_EMAIL || env.ZULIP_MESS_BOT_EMAIL || ''),\n    rk\n  );\n  const tokenFromMap = pickRealmValue(\n    loadRealmMap(env.N8N_ZULIP_BOT_TOKEN || env.ZULIP_MESS_BOT_TOKEN || '', env.N8N_ZULIP_BOT_TOKEN || env.ZULIP_MESS_BOT_TOKEN || ''),\n    rk\n  );\n\n  const email = String(\n    emailFromMap\n      || env.ZULIP_MESS_BOT_EMAIL\n      || env.ZULIP_BOT_EMAIL\n      || env.N8N_ZULIP_BOT_EMAIL\n      || ''\n  ).trim();\n\n  const apiKey = String(\n    tokenFromMap\n      || env.ZULIP_MESS_BOT_TOKEN\n      || env.ZULIP_BOT_API_KEY\n      || env.ZULIP_API_KEY\n      || env.ZULIP_BOT_TOKEN\n      || env.N8N_ZULIP_BOT_TOKEN\n      || ''\n  ).trim();\n\n  return { api_base: apiBase, email, api_key: apiKey };\n}\n\nconst zulip = resolveZulipCredentials(realm);\nif (!zulip.api_base || !zulip.email || !zulip.api_key) {\n  return error(500, 'Zulip credentials are missing', {\n    missing: [\n      !zulip.api_base ? 'N8N_ZULIP_API_BASE_URL/YAML or ZULIP_REALM_URL_TEMPLATE or HOSTED_ZONE_NAME (or ZULIP_BASE_URL)' : null,\n      !zulip.email ? 'N8N_ZULIP_BOT_EMAIL/YAML (or ZULIP_BOT_EMAIL)' : null,\n      !zulip.api_key ? 'N8N_ZULIP_BOT_TOKEN/YAML (or ZULIP_API_KEY/ZULIP_BOT_API_KEY)' : null,\n    ].filter(Boolean),\n    realm,\n    project_path: projectPath,\n  });\n}\n\nconst decisionPrefixes = parseList(env.GITLAB_DECISION_PREFIXES || '[DECISION],決定:,DECISION:');\nconst decisionLlmEnabled = (env.GITLAB_DECISION_LLM_ENABLED === undefined || env.GITLAB_DECISION_LLM_ENABLED === null || String(env.GITLAB_DECISION_LLM_ENABLED).trim() === '')\n  ? true\n  : isTruthy(env.GITLAB_DECISION_LLM_ENABLED);\nconst decisionLlmApiBase = String(env.GITLAB_DECISION_LLM_API_BASE_URL || env.OPENAI_BASE_URL || env.N8N_LLM_API_BASE_URL || 'https://api.openai.com/v1').replace(/\\/+$/, '');\nconst decisionLlmApiKey = String(env.GITLAB_DECISION_LLM_API_KEY || env.OPENAI_MODEL_API_KEY || env.OPENAI_API_KEY || env.N8N_LLM_API_KEY || '').trim();\nconst decisionLlmModel = String(env.GITLAB_DECISION_LLM_MODEL || env.OPENAI_MODEL || env.N8N_LLM_MODEL || 'gpt-4o-mini').trim();\nconst decisionLlmMinConfidence = Math.max(0, Math.min(1, Number(env.GITLAB_DECISION_LLM_MIN_CONFIDENCE || 0.75)));\nconst decisionLlmMaxCalls = Math.max(0, Math.min(50, Number(env.GITLAB_DECISION_LLM_MAX_CALLS_PER_RUN || 10)));\nconst decisionLlmMaxTextChars = Math.max(50, Math.min(2000, Number(env.GITLAB_DECISION_LLM_MAX_TEXT_CHARS || 400)));\nlet decisionLlmCalls = 0;\nconst dryRun = isTruthy(env.GITLAB_DECISION_NOTIFY_DRY_RUN);\n\n// Decide which text to inspect for decision.\nconst candidateTexts = [];\nif (objectKind === 'note' || event.includes('note')) {\n  if (noteText) candidateTexts.push(noteText);\n} else if (objectKind === 'issue' || event.includes('issue')) {\n  if (issueDescription) candidateTexts.push(issueDescription);\n}\n\n// Always allow explicit decision in the webhook payload even if event type differs.\nif (noteText && !candidateTexts.includes(noteText)) candidateTexts.push(noteText);\n\nconst inspected = candidateTexts.find((t) => String(t || '').trim() !== '') || '';\nif (!inspected) {\n  return [{ json: { ok: true, status_code: 200, skipped: true, reason: 'no_text', event: eventHeader } }];\n}\n\nif (isZulipEvidenceText(inspected)) {\n  return [{ json: { ok: true, status_code: 200, skipped: true, reason: 'zulip_evidence', event: eventHeader } }];\n}\n\nconst firstLine = firstNonEmptyLine(inspected);\nconst marker = matchPrefix(firstLine, decisionPrefixes);\n\nlet decisionDetection = null;\nif (marker) {\n  decisionDetection = { is_decision: true, confidence: 1, method: 'prefix' };\n} else {\n  decisionDetection = await detectDecisionByLlm(inspected);\n}\n\nconst isDecision = Boolean(decisionDetection?.is_decision);\nconst decisionMethod = decisionDetection?.method || null;\nconst decisionConfidence = (typeof decisionDetection?.confidence === 'number') ? decisionDetection.confidence : null;\n\nif (!isDecision) {\n  return [{ json: { ok: true, status_code: 200, skipped: true, reason: 'no_decision_marker', event: eventHeader } }];\n}\n\nconst decisionBody = (marker ? stripAnyPrefix(inspected, marker) : inspected).slice(0, 1000);\nconst markerForReport = marker || (decisionMethod === 'llm' ? 'llm' : null);\n\nconst issueIidForSor = pickFirst(['object_attributes.iid', 'issue.iid', 'object_attributes.old_iid'], '');\nconst noteIdForSor = pickFirst(['object_attributes.id', 'object_attributes.note_id'], '');\nconst eventKey = `gitlab:decision:${projectPath || 'unknown'}:${issueIidForSor || 'unknown'}:${noteIdForSor || 'issue'}:${markerForReport || ''}`;\nconst correlationId = `gitlab:${projectPath || 'unknown'}#${issueIidForSor || ''}`;\nconst sorAudit = {\n  record_type: 'sor_audit_event',\n  realm,\n  occurred_at: pickFirst(['object_attributes.created_at', 'object_attributes.updated_at', 'object_attributes.last_edited_at', 'issue.updated_at', 'issue.created_at'], null),\n  action: 'decision.recorded',\n  source: 'gitlab',\n  actor_type: actor ? 'human' : 'unknown',\n  actor: { name: actor || null },\n  resource_type: 'gitlab_issue',\n  correlation_id: correlationId,\n  reply_target: { source: 'gitlab', project_path: projectPath || null, issue_iid: issueIidForSor || null, note_id: noteIdForSor || null, url: noteUrl || issueUrl || null },\n  summary: issueTitle ? `決定（GitLab）: ${issueTitle}` : '決定（GitLab）',\n  message: decisionBody || null,\n  after: { gitlab_project_path: projectPath || null, gitlab_issue_url: issueUrl || null, gitlab_note_url: noteUrl || null, marker: markerForReport || marker || null },\n  integrity: { event_key: eventKey, decision_method: decisionMethod || null, decision_confidence: (typeof decisionConfidence === 'number') ? decisionConfidence : null }\n};\n\n// Resolve Zulip stream/topic from the issue description (preferred) || note text.\nconst narrow = findZulipNarrowUrl(issueDescription) || findZulipNarrowUrl(noteText) || findZulipNarrowUrl(inspected);\n\nconst fallbackStream = String(env.GITLAB_DECISION_FALLBACK_STREAM || '').trim();\nconst fallbackTopic = String(env.GITLAB_DECISION_FALLBACK_TOPIC || 'decisions').trim();\n\nlet stream = '';\nlet topic = '';\nif (narrow) {\n  stream = String(narrow.stream_id);\n  topic = String(narrow.topic);\n} else if (fallbackStream) {\n  stream = fallbackStream;\n  topic = fallbackTopic;\n}\n\nif (!stream || !topic) {\n  return [{\n    json: {\n      ok: true,\n      status_code: 200,\n      skipped: true,\n      reason: 'missing_zulip_destination',\n      event: eventHeader,\n      issue_url: issueUrl,\n      project_path: projectPath,\n      realm,\n      ...sorAudit,\n    }\n  }];\n}\n\n// Idempotency: avoid duplicate notifications for the same note/issue update.\nconst state = (typeof this.getWorkflowStaticData === 'function')\n  ? this.getWorkflowStaticData('global')\n  : (typeof $getWorkflowStaticData === 'function' ? $getWorkflowStaticData('global') : {});\nstate.seen = state.seen || {};\n\nconst noteId = pickFirst(['object_attributes.id', 'object_attributes.note_id'], '');\nconst issueId = pickFirst(['issue.id', 'object_attributes.iid', 'object_attributes.id'], '');\nconst key = `${eventHeader}:${projectPath || ''}:${issueId}:${noteId}:${marker}:${stream}:${topic}`;\nif (state.seen[key]) {\n  return [{ json: { ok: true, status_code: 200, skipped: true, reason: 'duplicate', key } }];\n}\nstate.seen[key] = new Date().toISOString();\n\n// Prune state\nconst keys = Object.keys(state.seen);\nif (keys.length > 500) {\n  for (const k of keys.slice(0, keys.length - 500)) {\n    delete state.seen[k];\n  }\n}\n\nconst lines = [\n  'GitLab で決定が記載されました',\n  `Realm: ${realm}`,\n  `Actor: ${actor}`,\n  issueTitle ? `Issue: ${issueTitle}` : null,\n  (noteUrl || issueUrl) ? `URL: ${noteUrl || issueUrl}` : null,\n  `Marker: ${markerForReport || marker}`,\n  (decisionMethod === 'llm' && typeof decisionConfidence === 'number') ? `DecisionMethod: LLM (conf=${decisionConfidence.toFixed(2)})` : null,\n  '',\n  decisionBody ? decisionBody : '(本文なし)',\n].filter((v) => v !== null);\n\nconst content = lines.join('\\n');\n\nif (dryRun) {\n  return [{\n    json: {\n      ok: true,\n      status_code: 200,\n      dry_run: true,\n      realm,\n      stream,\n      topic,\n      marker: markerForReport || marker,\n      issue_url: issueUrl,\n      note_url: noteUrl,\n      ...sorAudit,\n    }\n  }];\n}\n\nconst auth = Buffer.from(`${zulip.email}:${zulip.api_key}`).toString('base64');\nconst formBody = Object.entries({\n  type: 'stream',\n  to: String(stream),\n  topic: String(topic),\n  content,\n})\n  .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(String(v))}`)\n  .join('&');\n\ntry {\n  await this.helpers.httpRequest({\n    method: 'POST',\n    url: `${zulip.api_base}/messages`,\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      Authorization: `Basic ${auth}`,\n    },\n    body: formBody,\n  });\n  return [{ json: { ok: true, status_code: 200, realm, stream, topic, marker: markerForReport || marker, ...sorAudit } }];\n} catch (err) {\n  const status = err?.response?.statusCode || err?.statusCode || err?.httpCode || null;\n  const responseBody = err?.response?.body || err?.response?.data || null;\n  return [{\n    json: {\n      ok: false,\n      status_code: status || 500,\n      error: String(err?.message || err),\n      response_body: responseBody,\n      realm,\n      stream,\n      topic,\n      marker,\n      ...sorAudit,\n    }\n  }];\n}\n"
      },
      "id": "2",
      "name": "Process + Notify",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        200
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": "={{ $json.status_code || 200 }}"
        }
      },
      "id": "3",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        700,
        200
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.record_type}}",
              "value2": "sor_audit_event"
            }
          ]
        }
      },
      "id": "4",
      "name": "IF SoR Audit Event",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        760,
        60
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH v AS (\n  SELECT\n    itsm.get_realm_id(NULLIF('{{ $json.realm }}','')) AS realm_id,\n    COALESCE(NULLIF(NULLIF('{{ $json.occurred_at }}',''), 'undefined')::timestamptz, NOW()) AS occurred_at,\n    COALESCE(NULLIF('{{ JSON.stringify($json.actor || {}).replace(/'/g, \"''\") }}', 'undefined')::jsonb, '{}'::jsonb) AS actor,\n    COALESCE(NULLIF('{{ String($json.actor_type ?? \"unknown\").replace(/'/g, \"''\") }}', 'undefined'), 'unknown') AS actor_type,\n    '{{ String($json.action || '').replace(/'/g, \"''\") }}' AS action,\n    '{{ String($json.source || '').replace(/'/g, \"''\") }}' AS source,\n    NULLIF('{{ String($json.resource_type || '').replace(/'/g, \"''\") }}','') AS resource_type,\n    NULLIF('{{ String($json.correlation_id || '').replace(/'/g, \"''\") }}','') AS correlation_id,\n    COALESCE(NULLIF('{{ JSON.stringify($json.reply_target || {}).replace(/'/g, \"''\") }}', 'undefined')::jsonb, '{}'::jsonb) AS reply_target,\n    NULLIF('{{ String($json.summary || '').replace(/'/g, \"''\") }}','') AS summary,\n    NULLIF('{{ String($json.message || '').replace(/'/g, \"''\") }}','') AS message,\n    COALESCE(NULLIF('{{ JSON.stringify($json.after || {}).replace(/'/g, \"''\") }}', 'undefined')::jsonb, '{}'::jsonb) AS after,\n    COALESCE(NULLIF('{{ JSON.stringify($json.integrity || {}).replace(/'/g, \"''\") }}', 'undefined')::jsonb, '{}'::jsonb) AS integrity\n)\nINSERT INTO itsm.audit_event (\n  realm_id, occurred_at, actor, actor_type, action, source,\n  resource_type, correlation_id, reply_target, summary, message, after, integrity\n)\nSELECT\n  v.realm_id, v.occurred_at, v.actor, v.actor_type, v.action, v.source,\n  v.resource_type, v.correlation_id, v.reply_target, v.summary, v.message, v.after, v.integrity\nFROM v\nON CONFLICT DO NOTHING\nRETURNING id;"
      },
      "id": "5",
      "name": "Insert SoR Audit Event",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        980,
        60
      ],
      "credentials": {
        "postgres": {
          "name": "RDS Postgres"
        }
      },
      "continueOnFail": true
    }
  ],
  "connections": {
    "Webhook (GitLab)": {
      "main": [
        [
          {
            "node": "Process + Notify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process + Notify": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          },
          {
            "node": "IF SoR Audit Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF SoR Audit Event": {
      "main": [
        [
          {
            "node": "Insert SoR Audit Event",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    }
  }
}