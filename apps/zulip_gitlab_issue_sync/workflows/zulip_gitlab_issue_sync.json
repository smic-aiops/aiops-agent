{
  "name": "Zulip GitLab Issue Sync",
  "nodes": [
    {
      "parameters": {
        "triggerTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        }
      },
      "id": "1",
      "name": "Cron Sync",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [
        200,
        200
      ]
    },
    {
      "parameters": {
        "path": "zulip/gitlab/issue/sync/oq",
        "httpMethod": "POST",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "7",
      "name": "Webhook (OQ)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        200,
        40
      ]
    },
    {
      "parameters": {
        "jsCode": "const workflowContext = this;\nconst env = $env || {};\n\nconst missing = [];\n\nfunction required(value, name) {\n  if (value === undefined || value === null || String(value).trim() === '') {\n    missing.push(name);\n    return '';\n  }\n  return value;\n}\n\nfunction trimSlash(value) {\n  return String(value || '').replace(/\\/+$/, '');\n}\n\nfunction toDateKey(dateObj) {\n  const year = dateObj.getUTCFullYear();\n  const month = String(dateObj.getUTCMonth() + 1).padStart(2, '0');\n  const day = String(dateObj.getUTCDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\nfunction dateKeyFromIso(iso) {\n  if (!iso) return '';\n  const dt = new Date(iso);\n  if (Number.isNaN(dt.getTime())) return '';\n  return toDateKey(dt);\n}\n\nfunction toMinutes(start, end) {\n  if (!start || !end) return null;\n  const diff = (end.getTime() - start.getTime()) / 60000;\n  return Number.isFinite(diff) ? diff : null;\n}\n\nfunction percentile(values, p) {\n  const list = values.filter((v) => Number.isFinite(v)).sort((a, b) => a - b);\n  if (!list.length) return null;\n  const idx = Math.ceil((p / 100) * list.length) - 1;\n  return list[Math.max(0, Math.min(idx, list.length - 1))];\n}\n\nfunction buildZulipApiBase(baseOverride) {\n  const baseRaw = trimSlash(baseOverride || env.N8N_ZULIP_API_BASE_URL || env.ZULIP_API_BASE_URL || env.N8N_ZULIP_BASE_URL || env.ZULIP_BASE_URL || env.SERVICE_URL_ZULIP || env.ZULIP_URL || '');\n  if (!baseRaw) return '';\n  if (baseRaw.endsWith('/api/v1')) return baseRaw;\n  return `${baseRaw}/api/v1`;\n}\n\nfunction buildZulipUiBase(apiBase) {\n  const raw = trimSlash(env.N8N_ZULIP_BASE_URL || env.ZULIP_BASE_URL || env.SERVICE_URL_ZULIP || env.ZULIP_URL || '');\n  if (raw) return raw;\n  return trimSlash(String(apiBase || '').replace(/\\/api\\/v1$/, ''));\n}\n\nfunction buildGitlabApiBase() {\n  const baseRaw = trimSlash(env.GITLAB_API_BASE_URL || env.GITLAB_API_BASE_URL || '');\n  if (baseRaw) return baseRaw;\n  const uiBase = trimSlash(env.N8N_GITLAB_BASE_URL || env.GITLAB_BASE_URL || env.GITLAB_URL || env.SERVICE_URL_GITLAB || '');\n  if (!uiBase) return '';\n  if (uiBase.endsWith('/api/v4')) return uiBase;\n  return `${uiBase}/api/v4`;\n}\n\nfunction parseList(value) {\n  if (!value) return [];\n  if (Array.isArray(value)) return value.filter(Boolean);\n  return String(value)\n    .split(',')\n    .map((v) => v.trim())\n    .filter(Boolean);\n}\n\nfunction toInt(value, fallback) {\n  const parsed = Number.parseInt(String(value), 10);\n  return Number.isFinite(parsed) ? parsed : fallback;\n}\n\nfunction normalizeTopic(topic) {\n  const raw = String(topic || '').trim();\n  if (!raw) return '';\n  return raw.replace(/^\\[ARCHIVED\\]\\s*/i, '').trim();\n}\n\nfunction normalizeStreamName(name) {\n  return String(name || '').trim().replace(/^#/, '');\n}\n\nfunction buildStreamLabel(streamName) {\n  const name = normalizeStreamName(streamName);\n  if (!name) return '';\n  const match = name.match(/^cust-([^\\(]+)\\(([^\\)]+)\\)-/i);\n  if (!match) return '';\n  return `STREAM::${match[1]}(${match[2]}`;\n}\n\nfunction isArchivedTopic(topic) {\n  return /^\\[ARCHIVED\\]/i.test(String(topic || '').trim());\n}\n\nfunction stripHtml(value) {\n  return String(value || '')\n    .replace(/<br\\s*\\/?>/gi, '\\n')\n    .replace(/<\\/p>/gi, '\\n')\n    .replace(/<[^>]+>/g, '')\n    .replace(/\\n{3,}/g, '\\n\\n')\n    .trim();\n}\n\nfunction formatBlockquote(text) {\n  if (!text) return '';\n  return text.split('\\n').map((line) => `> ${line}`).join('\\n');\n}\n\nfunction messageLink(uiBase, streamId, topic, messageId) {\n  if (!uiBase || !streamId || !topic || !messageId) return '';\n  const encodedTopic = encodeURIComponent(topic);\n  return `${uiBase}#narrow/stream/${streamId}/topic/${encodedTopic}/near/${messageId}`;\n}\n\nfunction formatTimestamp(ts) {\n  const num = Number(ts);\n  if (!Number.isFinite(num)) return '';\n  return new Date(num * 1000).toISOString();\n}\n\nfunction buildIssueDescription(params) {\n  const textBlock = params.messageText ? formatBlockquote(params.messageText) : '';\n  return [\n    '## 種別',\n    `種別：${params.defaultType}`,\n    '',\n    '## 依頼者',\n    `- 顧客名：${params.customerName || ''}`,\n    `- 依頼者：${params.senderName || ''}`,\n    `- 連絡先：${params.senderEmail || ''}`,\n    '',\n    '## 受付チャネル',\n    '- 受付チャネル：Zulip',\n    `- トピックURL：${params.topicUrl || ''}`,\n    `- 受付日時：${params.receivedAt || ''}`,\n    '',\n    '## 対象サービス/CI',\n    '- サービス：',\n    '- CI：',\n    '',\n    '## 影響度/緊急度/優先度',\n    '- 影響度：全社 / 部門 / 個人',\n    '- 緊急度：高 / 中 / 低',\n    '- 優先度：P1 / P2 / P3 / P4',\n    '',\n    '## 依頼内容',\n    textBlock || '(本文なし)',\n    '',\n    '## 期待成果 / 受入基準',\n    '（完了と見なす条件）',\n    '',\n    '## 希望期限 / SLA',\n    '- 希望期限：',\n    '- SLA期限：',\n    '',\n    '## 担当部門',\n    '担当：インフラ / アプリ / ネットワーク / サービスデスク',\n    '',\n    '## 関連',\n    `- Zulipリンク：${params.messageUrl || ''}`,\n    `- ストリーム：${params.streamName || ''}`,\n    `- トピック：${params.topic || ''}`,\n  ].join('\\n');\n}\n\nfunction buildComment(params) {\n  const textBlock = params.messageText ? formatBlockquote(params.messageText) : '(本文なし)';\n  return [\n    '### Zulip更新',\n    `- 送信者：${params.senderName || ''} (${params.senderEmail || ''})`,\n    `- 時刻：${params.receivedAt || ''}`,\n    `- トピック：${params.topic || ''}`,\n    '',\n    textBlock,\n    '',\n    `- Zulip：${params.messageUrl || ''}`\n  ].join('\\n');\n}\n\nfunction buildCloseComment(params) {\n  return [\n    '### Zulipクローズ',\n    `- 理由：${params.reason || ''}`,\n    `- 時刻：${params.receivedAt || ''}`,\n    `- トピック：${params.topic || ''}`,\n    `- Zulip：${params.messageUrl || ''}`\n  ].join('\\n');\n}\n\nfunction buildReopenComment(params) {\n  return [\n    '### Zulip再オープン',\n    `- 理由：${params.reason || ''}`,\n    `- 時刻：${params.receivedAt || ''}`,\n    `- トピック：${params.topic || ''}`,\n    `- Zulip：${params.messageUrl || ''}`\n  ].join('\\n');\n}\n\nfunction matchPrefix(normalizedLowerText, prefixes) {\n  if (!normalizedLowerText) return '';\n  for (const prefix of prefixes || []) {\n    const p = String(prefix || '').trim();\n    if (!p) continue;\n    if (normalizedLowerText.startsWith(p.toLowerCase())) return p;\n  }\n  return '';\n}\n\nfunction stripAnyPrefix(text, prefixes) {\n  const trimmed = String(text || '').trim();\n  const normalized = trimmed.toLowerCase();\n  const matched = matchPrefix(normalized, prefixes);\n  if (!matched) return trimmed;\n  let rest = trimmed.slice(matched.length);\n  rest = rest.replace(/^\\s*[:：]\\s*/, '');\n  return rest.trim();\n}\n\nfunction buildDecisionComment(params) {\n  const decisionText = params.decisionText ? String(params.decisionText) : '';\n  const textBlock = decisionText ? formatBlockquote(decisionText) : '(本文なし)';\n  return [\n    '### 決定（Zulip）',\n    `- 決定者：${params.senderName || ''} (${params.senderEmail || ''})`,\n    `- 時刻：${params.receivedAt || ''}`,\n    `- トピック：${params.topic || ''}`,\n    '',\n    textBlock,\n    '',\n    `- Zulip：${params.messageUrl || ''}`\n  ].join('\\n');\n}\n\nfunction ensure(obj, key, fallback) {\n  if (!obj[key]) obj[key] = fallback;\n  return obj[key];\n}\n\nconst realm = String(env.N8N_REALM || env.N8N_OBSERVER_REALM || env.ZULIP_REALM || 'default').trim() || 'default';\n\nfunction parseJsonMap(text) {\n  if (!text) return {};\n  try {\n    const obj = JSON.parse(String(text));\n    if (obj && typeof obj === 'object' && !Array.isArray(obj)) return obj;\n  } catch (error) {\n    // ignore\n  }\n  return {};\n}\n\nfunction parseYamlMap(text) {\n  const map = {};\n  if (!text) return map;\n  const newlineRe = new RegExp('(?:\\r?\\n|\\\\n)');\n  const lines = String(text || '').split(newlineRe);\n  for (const line of lines) {\n    const trimmed = String(line || '').trim();\n    if (!trimmed || trimmed.startsWith('#')) continue;\n    const idx = trimmed.indexOf(':');\n    if (idx <= 0) continue;\n    const key = trimmed.slice(0, idx).trim();\n    let value = trimmed.slice(idx + 1).trim();\n    if (!key) continue;\n    if ((value.startsWith('\"') && value.endsWith('\"')) || (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\n      value = value.slice(1, -1);\n    }\n    map[key] = value;\n  }\n  return map;\n}\n\nfunction loadRealmMap(jsonText, yamlText) {\n  const jsonMap = parseJsonMap(jsonText);\n  if (jsonMap && Object.keys(jsonMap).length) return jsonMap;\n  return parseYamlMap(yamlText);\n}\n\nfunction pickRealmValue(map, realmKey) {\n  if (!map || typeof map !== 'object') return '';\n  const realmStr = String(realmKey || '').trim();\n  const candidates = [realmStr, realmStr.toLowerCase(), 'default', '*'];\n  for (const key of candidates) {\n    if (!key) continue;\n    const value = map[key];\n    if (value === undefined || value === null) continue;\n    const trimmed = String(value).trim();\n    if (trimmed) return trimmed;\n  }\n  return '';\n}\n\nconst zulipApiBaseFromMap = pickRealmValue(loadRealmMap(env.N8N_ZULIP_API_BASE_URL, env.N8N_ZULIP_API_BASE_URL), realm);\n\nlet zulipUiBaseOverride = zulipApiBaseFromMap;\nif (!zulipUiBaseOverride && env.ZULIP_REALM_URL_TEMPLATE) {\n  zulipUiBaseOverride = String(env.ZULIP_REALM_URL_TEMPLATE).replace(/\\{realm\\}/g, realm);\n}\nif (!zulipUiBaseOverride && env.HOSTED_ZONE_NAME) {\n  zulipUiBaseOverride = `https://${realm}.zulip.${String(env.HOSTED_ZONE_NAME).replace(/^\\.+|\\.+$/g, '')}`;\n}\n\nconst zulipApiBase = buildZulipApiBase(zulipUiBaseOverride);\nconst zulipUiBase = buildZulipUiBase(zulipApiBase);\n\n\nconst zulipEmail = pickRealmValue(loadRealmMap(env.N8N_ZULIP_BOT_EMAIL, env.N8N_ZULIP_BOT_EMAIL), realm)\n  || env.ZULIP_BOT_EMAIL || env.N8N_ZULIP_BOT_EMAIL || '';\n\nconst zulipToken = pickRealmValue(loadRealmMap(env.N8N_ZULIP_BOT_TOKEN, env.N8N_ZULIP_BOT_TOKEN), realm)\n  || pickRealmValue(loadRealmMap(env.ZULIP_BOT_TOKEN, env.ZULIP_BOT_TOKEN), realm)\n  || env.ZULIP_API_KEY || env.ZULIP_BOT_API_KEY || env.ZULIP_BOT_TOKEN || env.N8N_ZULIP_BOT_API_KEY || env.N8N_ZULIP_BOT_TOKEN || '';\n\nrequired(zulipApiBase, 'N8N_ZULIP_API_BASE_URL/YAML or ZULIP_REALM_URL_TEMPLATE or HOSTED_ZONE_NAME or N8N_ZULIP_API_BASE_URL or ZULIP_API_BASE_URL or ZULIP_BASE_URL');\nrequired(zulipEmail, 'N8N_ZULIP_BOT_EMAIL/YAML or ZULIP_BOT_EMAIL');\nrequired(zulipToken, 'N8N_ZULIP_BOT_TOKEN/YAML or ZULIP_BOT_TOKEN or ZULIP_API_KEY');\n\nconst gitlabApiBase = buildGitlabApiBase();\nconst gitlabToken = env.N8N_GITLAB_TOKEN || env.GITLAB_TOKEN || env.GITLAB_ADMIN_TOKEN || '';\nconst projectRef = env.N8N_GITLAB_PROJECT_ID || env.GITLAB_PROJECT_ID || env.N8N_GITLAB_PROJECT_PATH || env.GITLAB_PROJECT_PATH || `${realm}/service-management`;\nrequired(gitlabApiBase, 'GITLAB_API_BASE_URL or GITLAB_BASE_URL or GITLAB_URL or SERVICE_URL_GITLAB');\nrequired(gitlabToken, 'GITLAB_TOKEN');\nrequired(projectRef, 'GITLAB_PROJECT_ID or GITLAB_PROJECT_PATH');\n\nif (missing.length) {\n  return [\n    {\n      json: {\n        record_type: 'sync_summary',\n        ok: false,\n        realm,\n        missing,\n        received: 0,\n        created: 0,\n        updated: 0,\n        closed: 0,\n        reopened: 0,\n        skipped: 0,\n        errors: []\n      }\n    }\n  ];\n}\n\nconst defaultType = env.ZULIP_GITLAB_DEFAULT_TYPE || '問い合わせ';\nconst defaultLabels = parseList(env.ZULIP_GITLAB_DEFAULT_LABELS || '種別：問い合わせ,状態：新規,チャネル：Zulip,自動：Zulip同期,自動：自動作成');\nconst closeLabel = env.ZULIP_GITLAB_CLOSE_LABEL || '状態：クローズ';\nconst reopenLabel = env.ZULIP_GITLAB_REOPEN_LABEL || '状態：対応中';\nconst decisionPrefixes = parseList(env.ZULIP_GITLAB_DECISION_PREFIXES || '/decision,[decision],[DECISION],決定:');\nconst decisionLabel = String(env.ZULIP_GITLAB_DECISION_LABEL || '').trim();\nconst escalationLabel = env.N8N_GITLAB_ESCALATION_LABEL || env.GITLAB_ESCALATION_LABEL || '一次対応：エスカレーション';\nconst firstContactDoneLabel = env.N8N_GITLAB_FIRST_CONTACT_DONE_LABEL || env.GITLAB_FIRST_CONTACT_DONE_LABEL || '一次対応：完了';\nconst pollLimit = Math.max(1, Math.min(200, toInt(env.ZULIP_POLL_LIMIT, 50)));\nconst initialAnchor = String(env.ZULIP_INITIAL_ANCHOR || 'newest').trim() || 'newest';\n\nconst streamNamePrefixRaw = String(env.ZULIP_STREAM_NAME_PREFIX ?? 'cust-').trim();\nconst streamNamePrefix = normalizeStreamName(streamNamePrefixRaw).toLowerCase();\nconst enforceStreamNamePrefix = streamNamePrefix.length > 0;\nconst streamIds = parseList(env.ZULIP_STREAM_IDS || env.ZULIP_STREAM_ID || '');\n\nconst s3Bucket = env.N8N_S3_BUCKET || env.S3_BUCKET || '';\nconst s3Prefix = String(env.N8N_S3_PREFIX || 'itsm/customer_request').replace(/\\/+$/, '');\nconst metricsTargetDate = String(env.N8N_METRICS_TARGET_DATE || '').trim();\nconst exportEnabled = Boolean(s3Bucket);\n\nconst state = (() => {\n  if (typeof workflowContext.getWorkflowStaticData === 'function') {\n    return workflowContext.getWorkflowStaticData('global');\n  }\n  if (typeof $getWorkflowStaticData === 'function') {\n    return $getWorkflowStaticData('global');\n  }\n  return {};\n})();\nconst root = ensure(state, 'zulip_gitlab_sync', {});\nconst realmState = ensure(root, realm, { last_message_id: null, topic_map: {} });\nconst topicMap = ensure(realmState, 'topic_map', {});\nconst metricsByDate = ensure(realmState, 'metrics_by_date', {});\nconst lastMessageId = Number.isFinite(Number(realmState.last_message_id)) ? Number(realmState.last_message_id) : null;\n\nfunction ensureMetricsBucket(dt) {\n  if (!dt) return null;\n  if (!metricsByDate[dt]) {\n    metricsByDate[dt] = {\n      request_count: 0,\n      first_response_minutes: [],\n      resolution_minutes: [],\n      closed_count: 0,\n      escalated_count: 0,\n      fcr_count: 0,\n      reopened_count: 0,\n      backlog_count: null,\n      has_data: false\n    };\n  }\n  return metricsByDate[dt];\n}\n\nfunction recordRequest(receivedAt) {\n  const dt = dateKeyFromIso(receivedAt);\n  const bucket = ensureMetricsBucket(dt);\n  if (!bucket) return;\n  bucket.request_count += 1;\n  bucket.has_data = true;\n}\n\nfunction recordFirstResponse(entry, receivedAt) {\n  if (!entry || entry.first_response_at || !entry.created_at || !receivedAt) return;\n  const minutes = toMinutes(new Date(entry.created_at), new Date(receivedAt));\n  const dt = dateKeyFromIso(receivedAt);\n  const bucket = ensureMetricsBucket(dt);\n  if (bucket && minutes !== null) {\n    bucket.first_response_minutes.push(minutes);\n    bucket.has_data = true;\n  }\n  entry.first_response_at = receivedAt;\n}\n\nfunction recordResolution(entry, receivedAt) {\n  if (!entry || !entry.created_at || !receivedAt) return;\n  const minutes = toMinutes(new Date(entry.created_at), new Date(receivedAt));\n  const dt = dateKeyFromIso(receivedAt);\n  const bucket = ensureMetricsBucket(dt);\n  if (!bucket) return;\n  bucket.closed_count += 1;\n  if (entry.escalated) {\n    bucket.escalated_count += 1;\n  }\n  if (entry.first_contact_done && !entry.escalated) {\n    bucket.fcr_count += 1;\n  }\n  if (minutes !== null) {\n    bucket.resolution_minutes.push(minutes);\n  }\n  bucket.has_data = true;\n}\n\nfunction recordReopen(receivedAt) {\n  const dt = dateKeyFromIso(receivedAt);\n  const bucket = ensureMetricsBucket(dt);\n  if (!bucket) return;\n  bucket.reopened_count += 1;\n  bucket.has_data = true;\n}\n\nfunction backlogCountAtDate(dt) {\n  if (!dt) return null;\n  const end = new Date(`${dt}T23:59:59Z`);\n  let count = 0;\n  for (const entry of Object.values(topicMap)) {\n    if (!entry || !entry.created_at) continue;\n    const createdAt = new Date(entry.created_at);\n    if (Number.isNaN(createdAt.getTime()) || createdAt > end) continue;\n    if (entry.closed_at) {\n      const closedAt = new Date(entry.closed_at);\n      const reopenedAt = entry.reopened_at ? new Date(entry.reopened_at) : null;\n      if (!Number.isNaN(closedAt.getTime()) && closedAt <= end) {\n        if (!reopenedAt || Number.isNaN(reopenedAt.getTime()) || reopenedAt > end) {\n          continue;\n        }\n      }\n    }\n    count += 1;\n  }\n  return count;\n}\n\nfunction buildMetrics(bucket) {\n  const firstContactResolutionRate = bucket.closed_count > 0\n    ? bucket.fcr_count / bucket.closed_count\n    : null;\n  const reopenRate = bucket.closed_count > 0\n    ? bucket.reopened_count / bucket.closed_count\n    : null;\n  return {\n    realm,\n    request_count: bucket.request_count,\n    first_response_p50_minutes: percentile(bucket.first_response_minutes, 50),\n    first_response_p95_minutes: percentile(bucket.first_response_minutes, 95),\n    resolution_p50_minutes: percentile(bucket.resolution_minutes, 50),\n    resolution_p95_minutes: percentile(bucket.resolution_minutes, 95),\n    first_contact_resolution_rate: firstContactResolutionRate,\n    reopen_rate: reopenRate,\n    backlog_count: bucket.backlog_count,\n    escalated_count: bucket.escalated_count\n  };\n}\n\nfunction buildAuthHeader() {\n  return 'Basic ' + Buffer.from(`${zulipEmail}:${zulipToken}`).toString('base64');\n}\n\nasync function fetchStreamsByPrefix() {\n  if (!enforceStreamNamePrefix) return [];\n  const response = await workflowContext.helpers.httpRequest({\n    method: 'GET',\n    url: `${zulipApiBase}/streams`,\n    qs: {\n      include_public: 'true',\n      include_subscribed: 'true',\n      include_all_active: 'true'\n    },\n    json: true,\n    headers: { Authorization: buildAuthHeader() }\n  });\n  const streams = Array.isArray(response?.streams) ? response.streams : [];\n  return streams\n    .filter((stream) => {\n      const name = normalizeStreamName(stream?.name || '');\n      return name.toLowerCase().startsWith(streamNamePrefix);\n    })\n    .map((stream) => stream.stream_id)\n    .filter((id) => Number.isFinite(Number(id)) || String(id).trim() !== '');\n}\n\nasync function zulipFetch(anchor, numBefore, numAfter, narrow) {\n  const qs = {\n    anchor,\n    num_before: numBefore,\n    num_after: numAfter,\n    apply_markdown: 'false'\n  };\n  if (narrow) {\n    qs.narrow = JSON.stringify(narrow);\n  }\n  return await workflowContext.helpers.httpRequest({\n    method: 'GET',\n    url: `${zulipApiBase}/messages`,\n    qs,\n    json: true,\n    headers: { Authorization: buildAuthHeader() }\n  });\n}\n\nfunction encodeForm(params) {\n  return Object.entries(params)\n    .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`)\n    .join('&');\n}\n\nasync function zulipSendStreamMessage(stream, topic, content) {\n  if (!stream || !topic || !content) return null;\n  const payload = encodeForm({\n    type: 'stream',\n    to: String(stream),\n    topic: String(topic),\n    content: String(content)\n  });\n\n  return await workflowContext.helpers.httpRequest({\n    method: 'POST',\n    url: `${zulipApiBase}/messages`,\n    body: payload,\n    headers: {\n      Authorization: buildAuthHeader(),\n      'Content-Type': 'application/x-www-form-urlencoded'\n    },\n    json: true\n  });\n}\n\n\nasync function gitlabRequest(method, path, body) {\n  const options = {\n    method,\n    url: `${gitlabApiBase}${path}`,\n    headers: { 'PRIVATE-TOKEN': gitlabToken },\n    json: true\n  };\n  if (body) options.body = body;\n  return await workflowContext.helpers.httpRequest(options);\n}\n\nasync function fetchIssue(issueIid) {\n  return await gitlabRequest('GET', `/projects/${encodeURIComponent(projectRef)}/issues/${issueIid}`);\n}\n\nasync function createIssue(title, description, labels) {\n  const payload = {\n    title,\n    description,\n    labels: labels.join(',')\n  };\n  return await gitlabRequest('POST', `/projects/${encodeURIComponent(projectRef)}/issues`, payload);\n}\n\nasync function addNote(issueIid, body) {\n  return await gitlabRequest('POST', `/projects/${encodeURIComponent(projectRef)}/issues/${issueIid}/notes`, { body });\n}\n\nasync function closeIssue(issueIid) {\n  return await gitlabRequest('PUT', `/projects/${encodeURIComponent(projectRef)}/issues/${issueIid}`, {\n    state_event: 'close',\n    add_labels: closeLabel\n  });\n}\n\nasync function reopenIssue(issueIid) {\n  const payload = { state_event: 'reopen' };\n  if (reopenLabel) payload.add_labels = reopenLabel;\n  if (closeLabel) payload.remove_labels = closeLabel;\n  return await gitlabRequest('PUT', `/projects/${encodeURIComponent(projectRef)}/issues/${issueIid}`, payload);\n}\n\nasync function addIssueLabel(issueIid, label) {\n  if (!label) return null;\n  return await gitlabRequest('PUT', `/projects/${encodeURIComponent(projectRef)}/issues/${issueIid}`, {\n    add_labels: String(label)\n  });\n}\n\nfunction buildEventBase(params) {\n  return {\n    event_at: params.receivedAt || null,\n    realm,\n    stream_id: params.streamId ? String(params.streamId) : null,\n    topic: params.topic || null,\n    zulip_message_id: params.messageId ? String(params.messageId) : null,\n    zulip_sender_email: params.senderEmail || null,\n    zulip_message_url: params.messageUrl || null,\n    gitlab_project_path: String(projectRef)\n  };\n}\n\nasync function processMessages(messages) {\n  const created = [];\n  const updated = [];\n  const closed = [];\n  const reopened = [];\n  const skipped = [];\n  const errors = [];\n  const events = [];\n\n  const sorted = messages.slice().sort((a, b) => (a.id || 0) - (b.id || 0));\n  for (const message of sorted) {\n    const messageId = message.id;\n    if (!messageId) continue;\n\n    if (lastMessageId && messageId <= lastMessageId) continue;\n\n    const streamId = message.stream_id;\n    const topicRaw = message.subject || message.topic || '';\n    const topic = normalizeTopic(topicRaw);\n    if (!streamId || !topic) {\n      skipped.push({ message_id: messageId, reason: 'missing_topic' });\n      continue;\n    }\n\n    const senderEmail = message.sender_email || '';\n\n    const messageText = stripHtml(message.content || message.content_text || message.text || '');\n    const normalizedText = messageText.trim().toLowerCase();\n\n\n    const botOqSeed = normalizedText.startsWith('/oq-seed');\n    const decisionMarker = matchPrefix(normalizedText, decisionPrefixes);\n    const isDecision = Boolean(decisionMarker);\n    const decisionText = isDecision ? stripAnyPrefix(messageText, [decisionMarker]) : '';\n\n    if (senderEmail && zulipEmail && senderEmail === zulipEmail && !(botOqSeed || isDecision)) {\n      skipped.push({ message_id: messageId, reason: 'bot_message' });\n      continue;\n    }\n\n    const streamName = typeof message.display_recipient === 'string' ? message.display_recipient : '';\n    const streamLabel = buildStreamLabel(streamName);\n    const issueLabels = streamLabel ? [...defaultLabels, streamLabel] : defaultLabels;\n    const receivedAt = formatTimestamp(message.timestamp);\n    const topicUrl = messageLink(zulipUiBase, streamId, topicRaw || topic, messageId);\n    const closeRequested = normalizedText.startsWith('/close');\n    const reopenRequested = normalizedText.startsWith('/reopen');\n    const archived = isArchivedTopic(topicRaw);\n\n    const key = `${streamId}:${topic}`;\n    let entry = topicMap[key];\n\n    if (!entry) {\n      try {\n        const description = buildIssueDescription({\n          defaultType,\n          customerName: '',\n          senderName: message.sender_full_name || '',\n          senderEmail,\n          receivedAt,\n          topicUrl,\n          messageUrl: topicUrl,\n          messageText: isDecision ? decisionText : messageText,\n          streamName,\n          topic\n        });\n        const issue = await createIssue(topic, description, issueLabels);\n        entry = {\n          issue_iid: issue.iid,\n          issue_url: issue.web_url || issue.url || null,\n          status: 'open',\n          stream_id: streamId,\n          topic,\n          created_at: receivedAt || null,\n          creator_email: senderEmail || null,\n          first_response_at: null,\n          first_contact_done: null,\n          escalated: null,\n          decision_label_added: false\n        };\n        topicMap[key] = entry;\n\n        if (isDecision) {\n          const decisionComment = buildDecisionComment({\n            senderName: message.sender_full_name || '',\n            senderEmail,\n            receivedAt,\n            topic,\n            messageUrl: topicUrl,\n            decisionText\n          });\n          await addNote(entry.issue_iid, decisionComment);\n\n          if (decisionLabel && !entry.decision_label_added) {\n            try {\n              await addIssueLabel(entry.issue_iid, decisionLabel);\n              entry.decision_label_added = true;\n            } catch (error) {\n              errors.push({ message_id: messageId, error: `gitlab_label_failed: ${String(error?.message || error)}` });\n            }\n          }\n        }\n        created.push({ message_id: messageId, issue_iid: issue.iid, topic });\n        recordRequest(receivedAt);\n\n        const eventBase = buildEventBase({\n          receivedAt,\n          streamId,\n          topic,\n          messageId,\n          senderEmail,\n          messageUrl: topicUrl\n        });\n        events.push({\n          ...eventBase,\n          event_id: `${messageId}-topic`,\n          event_type: 'topic_created',\n          gitlab_issue_iid: issue.iid,\n          gitlab_issue_state: 'opened',\n          gitlab_labels: issueLabels,\n          issue_title: topic,\n          issue_url: entry.issue_url,\n          issue_created_at: entry.created_at,\n          issue_updated_at: receivedAt || null\n        });\n\n        if (isDecision) {\n          events.push({\n            ...eventBase,\n            event_id: `${messageId}-decision`,\n            event_type: 'decision_recorded',\n            decision_marker: decisionMarker || null,\n            gitlab_issue_iid: entry.issue_iid,\n            gitlab_issue_state: 'opened',\n            gitlab_labels: issueLabels,\n            issue_title: topic,\n            issue_url: entry.issue_url,\n            issue_created_at: entry.created_at,\n            issue_updated_at: receivedAt || null\n          });\n        }\n\n        try {\n          await zulipSendStreamMessage(streamName || streamId, topicRaw || topic, isDecision\n            ? `GitLab Issueを作成し、決定を証跡として記録しました: ${entry.issue_url || ''} (#${issue.iid})`\n            : `GitLab Issueを作成しました: ${entry.issue_url || ''} (#${issue.iid})`);\n        } catch (error) {\n          errors.push({ message_id: messageId, error: `zulip_notify_failed: ${String(error?.message || error)}` });\n        }\n      } catch (error) {\n        errors.push({ message_id: messageId, error: String(error?.message || error) });\n        continue;\n      }\n    } else {\n      try {\n        const comment = isDecision\n          ? buildDecisionComment({\n              senderName: message.sender_full_name || '',\n              senderEmail,\n              receivedAt,\n              topic,\n              messageUrl: topicUrl,\n              decisionText\n            })\n          : buildComment({\n              senderName: message.sender_full_name || '',\n              senderEmail,\n              receivedAt,\n              topic,\n              messageUrl: topicUrl,\n              messageText\n            });\n        await addNote(entry.issue_iid, comment);\n\n        if (isDecision && decisionLabel && !entry.decision_label_added) {\n          try {\n            await addIssueLabel(entry.issue_iid, decisionLabel);\n            entry.decision_label_added = true;\n          } catch (error) {\n            errors.push({ message_id: messageId, error: `gitlab_label_failed: ${String(error?.message || error)}` });\n          }\n        }\n        updated.push({ message_id: messageId, issue_iid: entry.issue_iid, topic });\n        entry.updated_at = receivedAt || null;\n        const sameSender = senderEmail && entry.creator_email && senderEmail === entry.creator_email;\n        if (!entry.first_response_at && !sameSender) {\n          recordFirstResponse(entry, receivedAt);\n        }\n\n        const eventBase = buildEventBase({\n          receivedAt,\n          streamId,\n          topic,\n          messageId,\n          senderEmail,\n          messageUrl: topicUrl\n        });\n        events.push({\n          ...eventBase,\n          event_id: `${messageId}-message`,\n          event_type: isDecision ? 'decision_recorded' : 'message_added',\n          decision_marker: decisionMarker || null,\n          gitlab_issue_iid: entry.issue_iid,\n          gitlab_issue_state: entry.status === 'closed' ? 'closed' : 'opened',\n          gitlab_labels: issueLabels,\n          issue_title: entry.topic || topic,\n          issue_url: entry.issue_url,\n          issue_created_at: entry.created_at || null,\n          issue_updated_at: entry.updated_at || null\n        });\n\n        try {\n          await zulipSendStreamMessage(streamName || streamId, topicRaw || topic, isDecision\n            ? `決定をGitLabへ証跡として記録しました: ${entry.issue_url || ''} (#${entry.issue_iid})`\n            : `GitLabへコメントを同期しました: ${entry.issue_url || ''} (#${entry.issue_iid})`);\n        } catch (error) {\n          errors.push({ message_id: messageId, error: `zulip_notify_failed: ${String(error?.message || error)}` });\n        }\n      } catch (error) {\n        errors.push({ message_id: messageId, error: String(error?.message || error) });\n      }\n    }\n\n    if (reopenRequested) {\n      if (entry && entry.status === 'closed') {\n        try {\n          await reopenIssue(entry.issue_iid);\n          const reopenComment = buildReopenComment({\n            reason: '/reopen 指示',\n            receivedAt,\n            topic,\n            messageUrl: topicUrl\n          });\n          await addNote(entry.issue_iid, reopenComment);\n          entry.status = 'open';\n          entry.reopened_at = receivedAt || null;\n          reopened.push({ message_id: messageId, issue_iid: entry.issue_iid, topic });\n          recordReopen(receivedAt);\n\n          const eventBase = buildEventBase({\n            receivedAt,\n            streamId,\n            topic,\n            messageId,\n            senderEmail,\n            messageUrl: topicUrl\n          });\n          events.push({\n            ...eventBase,\n            event_id: `${messageId}-reopen`,\n            event_type: 'issue_reopened',\n            gitlab_issue_iid: entry.issue_iid,\n            gitlab_issue_state: 'opened',\n            gitlab_labels: [...issueLabels, reopenLabel].filter(Boolean),\n            issue_title: entry.topic || topic,\n            issue_url: entry.issue_url,\n            issue_created_at: entry.created_at || null,\n            issue_updated_at: receivedAt || null\n          });\n\n          try {\n            await zulipSendStreamMessage(streamName || streamId, topicRaw || topic, `GitLab Issueを再オープンしました: ${entry.issue_url || ''} (#${entry.issue_iid})`);\n          } catch (error) {\n            errors.push({ message_id: messageId, error: `zulip_notify_failed: ${String(error?.message || error)}` });\n          }\n        } catch (error) {\n          errors.push({ message_id: messageId, error: String(error?.message || error) });\n        }\n      }\n    } else if (closeRequested || archived) {\n      if (entry && entry.status !== 'closed') {\n        try {\n          await closeIssue(entry.issue_iid);\n          const reason = closeRequested ? '/close 指示' : '[ARCHIVED] 付与';\n          const closeComment = buildCloseComment({\n            reason,\n            receivedAt,\n            topic,\n            messageUrl: topicUrl\n          });\n          await addNote(entry.issue_iid, closeComment);\n          entry.status = 'closed';\n          entry.closed_at = receivedAt || null;\n\n          try {\n            const issue = await fetchIssue(entry.issue_iid);\n            const labels = Array.isArray(issue?.labels) ? issue.labels : [];\n            entry.escalated = labels.includes(escalationLabel);\n            entry.first_contact_done = labels.includes(firstContactDoneLabel);\n          } catch (error) {\n            entry.escalated = entry.escalated ?? null;\n            entry.first_contact_done = entry.first_contact_done ?? null;\n          }\n\n          closed.push({ message_id: messageId, issue_iid: entry.issue_iid, topic });\n          recordResolution(entry, receivedAt);\n\n          const eventBase = buildEventBase({\n            receivedAt,\n            streamId,\n            topic,\n            messageId,\n            senderEmail,\n            messageUrl: topicUrl\n          });\n          events.push({\n            ...eventBase,\n            event_id: `${messageId}-close`,\n            event_type: 'issue_closed',\n            gitlab_issue_iid: entry.issue_iid,\n            gitlab_issue_state: 'closed',\n            gitlab_labels: [...issueLabels, closeLabel],\n            issue_title: entry.topic || topic,\n            issue_url: entry.issue_url,\n            issue_created_at: entry.created_at || null,\n            issue_closed_at: entry.closed_at || null,\n            issue_updated_at: entry.closed_at || null\n          });\n\n          try {\n            await zulipSendStreamMessage(streamName || streamId, topicRaw || topic, `GitLab Issueをクローズしました: ${entry.issue_url || ''} (#${entry.issue_iid})`);\n          } catch (error) {\n            errors.push({ message_id: messageId, error: `zulip_notify_failed: ${String(error?.message || error)}` });\n          }\n        } catch (error) {\n          errors.push({ message_id: messageId, error: String(error?.message || error) });\n        }\n      }\n    }\n  }\n\n  return { created, updated, closed, reopened, skipped, errors, events };\n}\n\nasync function fetchAllMessages() {\n  const numBefore = (!lastMessageId && initialAnchor === 'newest') ? pollLimit : 0;\n  const numAfter = (!lastMessageId && initialAnchor === 'newest') ? 0 : pollLimit;\n  const anchor = lastMessageId || initialAnchor;\n\n  if (!streamIds.length && !enforceStreamNamePrefix) {\n    const response = await zulipFetch(anchor, numBefore, numAfter, null);\n    return Array.isArray(response?.messages) ? response.messages : [];\n  }\n\n  const resolvedStreamIds = streamIds.length ? streamIds : await fetchStreamsByPrefix();\n  if (!resolvedStreamIds.length) return [];\n\n  const all = [];\n  for (const streamId of resolvedStreamIds) {\n    const narrow = [{ operator: 'stream', operand: Number.isFinite(Number(streamId)) ? Number(streamId) : streamId }];\n    const response = await zulipFetch(anchor, numBefore, numAfter, narrow);\n    if (Array.isArray(response?.messages)) {\n      all.push(...response.messages);\n    }\n  }\n  return all;\n}\n\nconst messages = await fetchAllMessages();\nconst result = await processMessages(messages);\nconst runId = new Date().toISOString().replace(/[-:.TZ]/g, '');\n\nconst skippedReasons = {};\nfor (const item of result.skipped || []) {\n  const reason = String(item?.reason || 'unknown');\n  skippedReasons[reason] = (skippedReasons[reason] || 0) + 1;\n}\n\nconst outputItems = [\n  {\n    json: {\n      record_type: 'sync_summary',\n      ok: true,\n      realm,\n      received: messages.length,\n      created: result.created.length,\n      updated: result.updated.length,\n      closed: result.closed.length,\n      reopened: result.reopened.length,\n      skipped: result.skipped.length,\n      skipped_reasons: skippedReasons,\n      errors: result.errors\n    }\n  }\n];\n\nif (exportEnabled && result.events.length) {\n  const eventGroups = {};\n  for (const event of result.events) {\n    const dt = dateKeyFromIso(event.event_at);\n    if (!dt) continue;\n    if (!eventGroups[dt]) eventGroups[dt] = [];\n    eventGroups[dt].push(event);\n  }\n\n  for (const [dt, events] of Object.entries(eventGroups)) {\n    const eventsBody = events.map((item) => JSON.stringify(item)).join('\\n') + '\\n';\n    const eventsKey = `${s3Prefix}/events/dt=${dt}/realm=${realm}/zulip_events_${runId}.jsonl`;\n\n    outputItems.push({\n      json: {\n        record_type: 'events',\n        s3_bucket: s3Bucket,\n        s3_key: eventsKey,\n        dt,\n        realm\n      },\n      binary: {\n        data: {\n          data: Buffer.from(eventsBody, 'utf8').toString('base64'),\n          mimeType: 'application/json',\n          fileName: `zulip_events_${runId}.jsonl`\n        }\n      }\n    });\n  }\n}\n\nif (exportEnabled) {\n  const today = toDateKey(new Date());\n  const dates = metricsTargetDate\n    ? [metricsTargetDate]\n    : Object.keys(metricsByDate).filter((dt) => dt < today).sort();\n\n  for (const dt of dates) {\n    const bucket = ensureMetricsBucket(dt);\n    if (!bucket) continue;\n    bucket.backlog_count = backlogCountAtDate(dt);\n\n    const shouldExport = metricsTargetDate\n      ? true\n      : (bucket.has_data || (bucket.backlog_count && bucket.backlog_count > 0));\n    if (!shouldExport) {\n      if (metricsTargetDate) {\n        delete metricsByDate[dt];\n      }\n      continue;\n    }\n\n    const metrics = buildMetrics(bucket);\n    const metricsBody = JSON.stringify(metrics);\n    const metricsKey = `${s3Prefix}/daily_metrics/dt=${dt}/realm=${realm}/zulip_metrics_${runId}.json`;\n\n    outputItems.push({\n      json: {\n        record_type: 'daily_metrics',\n        s3_bucket: s3Bucket,\n        s3_key: metricsKey,\n        dt,\n        realm\n      },\n      binary: {\n        data: {\n          data: Buffer.from(metricsBody, 'utf8').toString('base64'),\n          mimeType: 'application/json',\n          fileName: `zulip_metrics_${dt}_${runId}.json`\n        }\n      }\n    });\n\n    delete metricsByDate[dt];\n  }\n}\n\nreturn outputItems;\n"
      },
      "id": "2",
      "name": "Zulip to GitLab Sync",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        200
      ]
    },
    {
      "parameters": {
        "content": "Env\n- N8N_REALM (or N8N_OBSERVER_REALM)\n- (realm map) N8N_ZULIP_API_BASE_URL/YAML\n- (realm map) N8N_ZULIP_BOT_EMAIL/YAML\n- (realm map) N8N_ZULIP_BOT_TOKEN/YAML\n- (fallback) N8N_ZULIP_API_BASE_URL or ZULIP_API_BASE_URL or ZULIP_BASE_URL\n- (fallback) ZULIP_BOT_EMAIL\n- (fallback) ZULIP_API_KEY or ZULIP_BOT_API_KEY\n- ZULIP_STREAM_NAME_PREFIX (default: cust-)\n- ZULIP_STREAM_IDS (optional)\n- GITLAB_API_BASE_URL or GITLAB_BASE_URL or GITLAB_URL or SERVICE_URL_GITLAB\n- GITLAB_TOKEN or GITLAB_ADMIN_TOKEN\n- GITLAB_PROJECT_ID or GITLAB_PROJECT_PATH\n- ZULIP_GITLAB_DEFAULT_LABELS (optional)\n- ZULIP_GITLAB_CLOSE_LABEL (optional)\n- ZULIP_GITLAB_REOPEN_LABEL (optional)\n- ZULIP_GITLAB_DECISION_PREFIXES (optional)\n- ZULIP_GITLAB_DECISION_LABEL (optional)\n- N8N_GITLAB_ESCALATION_LABEL (optional)\n- N8N_GITLAB_FIRST_CONTACT_DONE_LABEL (optional)\n- ZULIP_INITIAL_ANCHOR (optional)\n- N8N_S3_BUCKET (optional)\n- N8N_S3_PREFIX (optional)\n- N8N_METRICS_TARGET_DATE (optional)\n- (notify) 同期結果は対象 stream/topic へ bot が投稿します（ZULIP_BOT_EMAIL）\n- (fallback) ZULIP_REALM_URL_TEMPLATE or HOSTED_ZONE_NAME",
        "height": 220,
        "width": 420,
        "color": 6
      },
      "id": "100",
      "name": "Sticky Note: env",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        200,
        420
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.record_type}}",
              "value2": "events"
            }
          ]
        }
      },
      "id": "3",
      "name": "IF Events",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        720,
        140
      ]
    },
    {
      "parameters": {
        "operation": "upload",
        "bucketName": "={{$json.s3_bucket}}",
        "binaryData": true,
        "binaryPropertyName": "data",
        "fileName": "={{$json.s3_key}}"
      },
      "id": "4",
      "name": "S3 Upload Events",
      "type": "n8n-nodes-base.awsS3",
      "typeVersion": 1,
      "position": [
        960,
        140
      ],
      "continueOnFail": true,
      "alwaysOutputData": true,
      "credentials": {
        "aws": {
          "id": "aiops-aws",
          "name": "aiops-aws"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.record_type}}",
              "value2": "daily_metrics"
            }
          ]
        }
      },
      "id": "5",
      "name": "IF Metrics",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        720,
        260
      ]
    },
    {
      "parameters": {
        "operation": "upload",
        "bucketName": "={{$json.s3_bucket}}",
        "binaryData": true,
        "binaryPropertyName": "data",
        "fileName": "={{$json.s3_key}}"
      },
      "id": "6",
      "name": "S3 Upload Metrics",
      "type": "n8n-nodes-base.awsS3",
      "typeVersion": 1,
      "position": [
        960,
        260
      ],
      "continueOnFail": true,
      "alwaysOutputData": true,
      "credentials": {
        "aws": {
          "id": "aiops-aws",
          "name": "aiops-aws"
        }
      }
    }
  ],
  "connections": {
    "Cron Sync": {
      "main": [
        [
          {
            "node": "Zulip to GitLab Sync",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook (OQ)": {
      "main": [
        [
          {
            "node": "Zulip to GitLab Sync",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Zulip to GitLab Sync": {
      "main": [
        [
          {
            "node": "IF Events",
            "type": "main",
            "index": 0
          },
          {
            "node": "IF Metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Events": {
      "main": [
        [
          {
            "node": "S3 Upload Events",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "IF Metrics": {
      "main": [
        [
          {
            "node": "S3 Upload Metrics",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    }
  },
  "active": false,
  "settings": {},
  "versionId": "1",
  "meta": {
    "workflowId": "wf.zulip_gitlab_issue_sync",
    "revision": 1,
    "aiops_catalog": {
      "summary": "ZulipトピックをGitLab Issueへ同期（作成/更新/クローズ）",
      "realm": "default",
      "platform": "n8n",
      "required_roles": [
        "service_desk"
      ],
      "required_groups": [],
      "required_users": [],
      "risk_level": "low",
      "impact_scope": "service",
      "category": "service_request",
      "workflow_class": "service_request"
    }
  }
}
