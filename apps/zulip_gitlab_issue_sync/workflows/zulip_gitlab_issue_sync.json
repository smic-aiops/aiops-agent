{
  "name": "Zulip GitLab Issue Sync",
  "nodes": [
    {
      "parameters": {
        "triggerTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        }
      },
      "id": "1",
      "name": "Cron Sync",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [
        200,
        200
      ]
    },
    {
      "parameters": {
        "path": "zulip/gitlab/issue/sync/oq",
        "httpMethod": "POST",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "7",
      "name": "Webhook (OQ)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        200,
        40
      ]
    },
    {
      "parameters": {
        "jsCode": "const workflowContext = this;\nconst env = $env || {};\n\nconst missing = [];\n\nfunction required(value, name) {\n  if (value === undefined || value === null || String(value).trim() === '') {\n    missing.push(name);\n    return '';\n  }\n  return value;\n}\n\nfunction trimSlash(value) {\n  return String(value || '').replace(/\\/+$/, '');\n}\n\nfunction toDateKey(dateObj) {\n  const year = dateObj.getUTCFullYear();\n  const month = String(dateObj.getUTCMonth() + 1).padStart(2, '0');\n  const day = String(dateObj.getUTCDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\nfunction dateKeyFromIso(iso) {\n  if (!iso) return '';\n  const dt = new Date(iso);\n  if (Number.isNaN(dt.getTime())) return '';\n  return toDateKey(dt);\n}\n\nfunction toMinutes(start, end) {\n  if (!start || !end) return null;\n  const diff = (end.getTime() - start.getTime()) / 60000;\n  return Number.isFinite(diff) ? diff : null;\n}\n\nfunction percentile(values, p) {\n  const list = values.filter((v) => Number.isFinite(v)).sort((a, b) => a - b);\n  if (!list.length) return null;\n  const idx = Math.ceil((p / 100) * list.length) - 1;\n  return list[Math.max(0, Math.min(idx, list.length - 1))];\n}\n\nfunction buildZulipApiBase(baseOverride) {\n  const baseRaw = trimSlash(baseOverride || env.N8N_ZULIP_API_BASE_URL || env.ZULIP_API_BASE_URL || env.N8N_ZULIP_BASE_URL || env.ZULIP_BASE_URL || env.SERVICE_URL_ZULIP || env.ZULIP_URL || '');\n  if (!baseRaw) return '';\n  if (baseRaw.endsWith('/api/v1')) return baseRaw;\n  return `${baseRaw}/api/v1`;\n}\n\nfunction buildZulipUiBase(apiBase) {\n  const raw = trimSlash(env.N8N_ZULIP_BASE_URL || env.ZULIP_BASE_URL || env.SERVICE_URL_ZULIP || env.ZULIP_URL || '');\n  if (raw) return raw;\n  return trimSlash(String(apiBase || '').replace(/\\/api\\/v1$/, ''));\n}\n\nfunction buildGitlabApiBase() {\n  const baseRaw = trimSlash(env.GITLAB_API_BASE_URL || env.GITLAB_API_BASE_URL || '');\n  if (baseRaw) return baseRaw;\n  const uiBase = trimSlash(env.N8N_GITLAB_BASE_URL || env.GITLAB_BASE_URL || env.GITLAB_URL || env.SERVICE_URL_GITLAB || '');\n  if (!uiBase) return '';\n  if (uiBase.endsWith('/api/v4')) return uiBase;\n  return `${uiBase}/api/v4`;\n}\n\nfunction parseList(value) {\n  if (!value) return [];\n  if (Array.isArray(value)) return value.filter(Boolean);\n  return String(value)\n    .split(',')\n    .map((v) => v.trim())\n    .filter(Boolean);\n}\n\nfunction toInt(value, fallback) {\n  const parsed = Number.parseInt(String(value), 10);\n  return Number.isFinite(parsed) ? parsed : fallback;\n}\n\nfunction toBool(value, fallback = false) {\n  if (value === undefined || value === null) return fallback;\n  const raw = String(value).trim().toLowerCase();\n  if (!raw) return fallback;\n  return ['1', 'true', 'yes', 'y', 'on', 'enabled'].includes(raw);\n}\n\nfunction normalizeTopic(topic) {\n  const raw = String(topic || '').trim();\n  if (!raw) return '';\n  return raw.replace(/^\\[ARCHIVED\\]\\s*/i, '').trim();\n}\n\nfunction normalizeStreamName(name) {\n  return String(name || '').trim().replace(/^#/, '');\n}\n\nfunction buildStreamLabel(streamName) {\n  const name = normalizeStreamName(streamName);\n  if (!name) return '';\n  const match = name.match(/^cust-([^\\(]+)\\(([^\\)]+)\\)-/i);\n  if (!match) return '';\n  return `STREAM::${match[1]}(${match[2]}`;\n}\n\nfunction isArchivedTopic(topic) {\n  return /^\\[ARCHIVED\\]/i.test(String(topic || '').trim());\n}\n\nfunction stripHtml(value) {\n  return String(value || '')\n    .replace(/<br\\s*\\/?>/gi, '\\n')\n    .replace(/<\\/p>/gi, '\\n')\n    .replace(/<[^>]+>/g, '')\n    .replace(/\\n{3,}/g, '\\n\\n')\n    .trim();\n}\n\nfunction formatBlockquote(text) {\n  if (!text) return '';\n  return text.split('\\n').map((line) => `> ${line}`).join('\\n');\n}\n\nfunction messageLink(uiBase, streamId, topic, messageId) {\n  if (!uiBase || !streamId || !topic || !messageId) return '';\n  const encodedTopic = encodeURIComponent(topic);\n  return `${uiBase}#narrow/stream/${streamId}/topic/${encodedTopic}/near/${messageId}`;\n}\n\nfunction formatTimestamp(ts) {\n  const num = Number(ts);\n  if (!Number.isFinite(num)) return '';\n  return new Date(num * 1000).toISOString();\n}\n\nfunction inferRecordTypeFromLabels(labels, defaultType) {\n  const list = Array.isArray(labels) ? labels.map((v) => String(v || '').trim()) : [];\n  const typeLabel = list.find((v) => v.startsWith('種別：')) || '';\n  const t = typeLabel ? typeLabel.replace(/^種別：/, '').trim() : String(defaultType || '').trim();\n  if (/障害|インシデント/i.test(t)) return 'incident';\n  if (/変更|RFC|change/i.test(t)) return 'change_request';\n  if (/問題|problem/i.test(t)) return 'problem';\n  return 'service_request';\n}\n\nfunction buildIssueDescription(params) {\n  const textBlock = params.messageText ? formatBlockquote(params.messageText) : '';\n  return [\n    '## 種別',\n    `種別：${params.defaultType}`,\n    '',\n    '## 依頼者',\n    `- 顧客名：${params.customerName || ''}`,\n    `- 依頼者：${params.senderName || ''}`,\n    `- 連絡先：${params.senderEmail || ''}`,\n    '',\n    '## 受付チャネル',\n    '- 受付チャネル：Zulip',\n    `- トピックURL：${params.topicUrl || ''}`,\n    `- 受付日時：${params.receivedAt || ''}`,\n    '',\n    '## 対象サービス/CI',\n    '- サービス：',\n    '- CI：',\n    '',\n    '## 影響度/緊急度/優先度',\n    '- 影響度：全社 / 部門 / 個人',\n    '- 緊急度：高 / 中 / 低',\n    '- 優先度：P1 / P2 / P3 / P4',\n    '',\n    '## 依頼内容',\n    textBlock || '(本文なし)',\n    '',\n    '## 期待成果 / 受入基準',\n    '（完了と見なす条件）',\n    '',\n    '## 希望期限 / SLA',\n    '- 希望期限：',\n    '- SLA期限：',\n    '',\n    '## 担当部門',\n    '担当：インフラ / アプリ / ネットワーク / サービスデスク',\n    '',\n    '## 関連',\n    `- Zulipリンク：${params.messageUrl || ''}`,\n    `- ストリーム：${params.streamName || ''}`,\n    `- トピック：${params.topic || ''}`,\n  ].join('\\n');\n}\n\nfunction buildComment(params) {\n  const textBlock = params.messageText ? formatBlockquote(params.messageText) : '(本文なし)';\n  return [\n    '### Zulip更新',\n    `- 送信者：${params.senderName || ''} (${params.senderEmail || ''})`,\n    `- 時刻：${params.receivedAt || ''}`,\n    `- トピック：${params.topic || ''}`,\n    '',\n    textBlock,\n    '',\n    `- Zulip：${params.messageUrl || ''}`\n  ].join('\\n');\n}\n\nfunction buildCloseComment(params) {\n  return [\n    '### Zulipクローズ',\n    `- 理由：${params.reason || ''}`,\n    `- 時刻：${params.receivedAt || ''}`,\n    `- トピック：${params.topic || ''}`,\n    `- Zulip：${params.messageUrl || ''}`\n  ].join('\\n');\n}\n\nfunction buildReopenComment(params) {\n  return [\n    '### Zulip再オープン',\n    `- 理由：${params.reason || ''}`,\n    `- 時刻：${params.receivedAt || ''}`,\n    `- トピック：${params.topic || ''}`,\n    `- Zulip：${params.messageUrl || ''}`\n  ].join('\\n');\n}\n\nfunction matchPrefix(normalizedLowerText, prefixes) {\n  if (!normalizedLowerText) return '';\n  for (const prefix of prefixes || []) {\n    const p = String(prefix || '').trim();\n    if (!p) continue;\n    if (normalizedLowerText.startsWith(p.toLowerCase())) return p;\n  }\n  return '';\n}\n\nfunction stripAnyPrefix(text, prefixes) {\n  const trimmed = String(text || '').trim();\n  const normalized = trimmed.toLowerCase();\n  const matched = matchPrefix(normalized, prefixes);\n  if (!matched) return trimmed;\n  let rest = trimmed.slice(matched.length);\n  rest = rest.replace(/^\\s*[:：]\\s*/, '');\n  return rest.trim();\n}\n\nfunction pruneDecisionLlmCache(maxSize = 2000) {\n  if (!Array.isArray(decisionLlmCacheOrder) || !decisionLlmCache) return;\n  while (decisionLlmCacheOrder.length > maxSize) {\n    const id = decisionLlmCacheOrder.shift();\n    if (id) delete decisionLlmCache[id];\n  }\n}\n\nfunction parseJsonFromText(text) {\n  const raw = String(text || '').trim();\n  if (!raw) return null;\n  const cleaned = raw.replace(/^```(?:json)?\\s*/i, '').replace(/```\\s*$/i, '').trim();\n  try {\n    return JSON.parse(cleaned);\n  } catch (error) {\n    // try to extract JSON object substring\n  }\n  const start = cleaned.indexOf('{');\n  const end = cleaned.lastIndexOf('}');\n  if (start >= 0 && end > start) {\n    const slice = cleaned.slice(start, end + 1);\n    try {\n      return JSON.parse(slice);\n    } catch (error) {\n      return null;\n    }\n  }\n  return null;\n}\n\nasync function detectDecisionByLlm(params) {\n  if (!decisionLlmEnabled) return null;\n  if (!decisionLlmApiKey || !decisionLlmApiBase || !decisionLlmModel) return null;\n  if (decisionLlmMaxCalls <= 0) return null;\n  const messageId = params?.messageId ? String(params.messageId) : '';\n  if (messageId && decisionLlmCache[messageId]) return decisionLlmCache[messageId];\n  const textRaw = String(params?.text || '').trim();\n  if (!textRaw) return null;\n  if (decisionLlmCalls >= decisionLlmMaxCalls) return null;\n\n  const text = textRaw.slice(0, decisionLlmMaxTextChars);\n  const payload = {\n    text,\n    topic: params?.topic || '',\n    stream: params?.streamName || '',\n    sender_email: params?.senderEmail || ''\n  };\n\n  decisionLlmCalls += 1;\n  let response;\n  try {\n    response = await workflowContext.helpers.httpRequest({\n      method: 'POST',\n      url: `${decisionLlmApiBase}/chat/completions`,\n      json: true,\n      timeout: 8000,\n      headers: {\n        Authorization: `Bearer ${decisionLlmApiKey}`\n      },\n      body: {\n        model: decisionLlmModel,\n        temperature: 0,\n        max_tokens: 200,\n        messages: [\n          {\n            role: 'system',\n            content: 'あなたはITSMの監査ログ向けに、短文が「決定/承認（実施・採用・却下・クローズ等の意思決定）」に該当するかを判定する分類器です。出力は必ずJSONのみ。キーは is_decision(boolean), confidence(0-1), category(string), reason(string,短く)。疑わしい場合は is_decision=false。'\n          },\n          { role: 'user', content: JSON.stringify(payload) }\n        ]\n      }\n    });\n  } catch (error) {\n    if (decisionLlmLogErrors) {\n      try {\n        if (workflowContext?.logger?.warn) {\n          workflowContext.logger.warn(`decision_llm_failed: ${String(error?.message || error)}`);\n        } else {\n          console.log(`decision_llm_failed: ${String(error?.message || error)}`);\n        }\n      } catch (e) {\n        // ignore\n      }\n    }\n    return null;\n  }\n\n  const content = response?.choices?.[0]?.message?.content ?? '';\n  const parsed = parseJsonFromText(content);\n  const confidenceRaw = Number(parsed?.confidence);\n  const confidence = Number.isFinite(confidenceRaw) ? Math.max(0, Math.min(1, confidenceRaw)) : 0;\n  const rawDecision = Boolean(parsed?.is_decision);\n  const isDecision = rawDecision && confidence >= decisionLlmMinConfidence;\n\n  const result = {\n    is_decision: isDecision,\n    confidence,\n    category: parsed?.category ? String(parsed.category) : null,\n    reason: parsed?.reason ? String(parsed.reason) : null,\n    method: 'llm'\n  };\n\n  if (messageId) {\n    decisionLlmCache[messageId] = result;\n    decisionLlmCacheOrder.push(messageId);\n    pruneDecisionLlmCache();\n  }\n  return result;\n}\n\nfunction buildDecisionComment(params) {\n  const decisionText = params.decisionText ? String(params.decisionText) : '';\n  const textBlock = decisionText ? formatBlockquote(decisionText) : '(本文なし)';\n  return [\n    '### 決定（Zulip）',\n    `- 決定者：${params.senderName || ''} (${params.senderEmail || ''})`,\n    (params.decisionMethod && params.decisionMethod !== 'prefix')\n      ? `- 判定：${params.decisionMethod}${(typeof params.decisionConfidence === 'number') ? `（信頼度: ${params.decisionConfidence.toFixed(2)}）` : ''}`\n      : '',\n    `- 時刻：${params.receivedAt || ''}`,\n    `- トピック：${params.topic || ''}`,\n    '',\n    textBlock,\n    '',\n    `- Zulip：${params.messageUrl || ''}`\n  ].join('\\n');\n}\n\nfunction ensure(obj, key, fallback) {\n  if (!obj[key]) obj[key] = fallback;\n  return obj[key];\n}\n\nconst realm = String(env.N8N_REALM || env.N8N_OBSERVER_REALM || env.ZULIP_REALM || 'default').trim() || 'default';\n\nfunction parseJsonMap(text) {\n  if (!text) return {};\n  try {\n    const obj = JSON.parse(String(text));\n    if (obj && typeof obj === 'object' && !Array.isArray(obj)) return obj;\n  } catch (error) {\n    // ignore\n  }\n  return {};\n}\n\nfunction parseYamlMap(text) {\n  const map = {};\n  if (!text) return map;\n  const newlineRe = new RegExp('(?:\\r?\\n|\\\\n)');\n  const lines = String(text || '').split(newlineRe);\n  for (const line of lines) {\n    const trimmed = String(line || '').trim();\n    if (!trimmed || trimmed.startsWith('#')) continue;\n    const idx = trimmed.indexOf(':');\n    if (idx <= 0) continue;\n    const key = trimmed.slice(0, idx).trim();\n    let value = trimmed.slice(idx + 1).trim();\n    if (!key) continue;\n    if ((value.startsWith('\"') && value.endsWith('\"')) || (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\n      value = value.slice(1, -1);\n    }\n    map[key] = value;\n  }\n  return map;\n}\n\nfunction loadRealmMap(jsonText, yamlText) {\n  const jsonMap = parseJsonMap(jsonText);\n  if (jsonMap && Object.keys(jsonMap).length) return jsonMap;\n  return parseYamlMap(yamlText);\n}\n\nfunction pickRealmValue(map, realmKey) {\n  if (!map || typeof map !== 'object') return '';\n  const realmStr = String(realmKey || '').trim();\n  const candidates = [realmStr, realmStr.toLowerCase(), 'default', '*'];\n  for (const key of candidates) {\n    if (!key) continue;\n    const value = map[key];\n    if (value === undefined || value === null) continue;\n    const trimmed = String(value).trim();\n    if (trimmed) return trimmed;\n  }\n  return '';\n}\n\nconst zulipApiBaseFromMap = pickRealmValue(loadRealmMap(env.N8N_ZULIP_API_BASE_URL, env.N8N_ZULIP_API_BASE_URL), realm);\n\nlet zulipUiBaseOverride = zulipApiBaseFromMap;\nif (!zulipUiBaseOverride && env.ZULIP_REALM_URL_TEMPLATE) {\n  zulipUiBaseOverride = String(env.ZULIP_REALM_URL_TEMPLATE).replace(/\\{realm\\}/g, realm);\n}\nif (!zulipUiBaseOverride && env.HOSTED_ZONE_NAME) {\n  zulipUiBaseOverride = `https://${realm}.zulip.${String(env.HOSTED_ZONE_NAME).replace(/^\\.+|\\.+$/g, '')}`;\n}\n\nconst zulipApiBase = buildZulipApiBase(zulipUiBaseOverride);\nconst zulipUiBase = buildZulipUiBase(zulipApiBase);\n\n\nconst zulipEmail = pickRealmValue(loadRealmMap(env.N8N_ZULIP_BOT_EMAIL, env.N8N_ZULIP_BOT_EMAIL), realm)\n  || env.ZULIP_BOT_EMAIL || env.N8N_ZULIP_BOT_EMAIL || '';\n\nconst zulipToken = pickRealmValue(loadRealmMap(env.N8N_ZULIP_BOT_TOKEN, env.N8N_ZULIP_BOT_TOKEN), realm)\n  || pickRealmValue(loadRealmMap(env.ZULIP_BOT_TOKEN, env.ZULIP_BOT_TOKEN), realm)\n  || env.ZULIP_API_KEY || env.ZULIP_BOT_API_KEY || env.ZULIP_BOT_TOKEN || env.N8N_ZULIP_BOT_API_KEY || env.N8N_ZULIP_BOT_TOKEN || '';\n\nrequired(zulipApiBase, 'N8N_ZULIP_API_BASE_URL/YAML or ZULIP_REALM_URL_TEMPLATE or HOSTED_ZONE_NAME or N8N_ZULIP_API_BASE_URL or ZULIP_API_BASE_URL or ZULIP_BASE_URL');\nrequired(zulipEmail, 'N8N_ZULIP_BOT_EMAIL/YAML or ZULIP_BOT_EMAIL');\nrequired(zulipToken, 'N8N_ZULIP_BOT_TOKEN/YAML or ZULIP_BOT_TOKEN or ZULIP_API_KEY');\n\nconst gitlabApiBase = buildGitlabApiBase();\nconst gitlabToken = env.N8N_GITLAB_TOKEN || env.GITLAB_TOKEN || env.GITLAB_ADMIN_TOKEN || '';\nconst projectRef = env.N8N_GITLAB_PROJECT_ID || env.GITLAB_PROJECT_ID || env.N8N_GITLAB_PROJECT_PATH || env.GITLAB_PROJECT_PATH || `${realm}/service-management`;\nrequired(gitlabApiBase, 'GITLAB_API_BASE_URL or GITLAB_BASE_URL or GITLAB_URL or SERVICE_URL_GITLAB');\nrequired(gitlabToken, 'GITLAB_TOKEN');\nrequired(projectRef, 'GITLAB_PROJECT_ID or GITLAB_PROJECT_PATH');\n\nif (missing.length) {\n  return [\n    {\n      json: {\n        record_type: 'sync_summary',\n        ok: false,\n        realm,\n        missing,\n        received: 0,\n        created: 0,\n        updated: 0,\n        closed: 0,\n        reopened: 0,\n        skipped: 0,\n        errors: []\n      }\n    }\n  ];\n}\n\nconst defaultType = env.ZULIP_GITLAB_DEFAULT_TYPE || '問い合わせ';\nconst defaultLabels = parseList(env.ZULIP_GITLAB_DEFAULT_LABELS || '種別：問い合わせ,状態：新規,チャネル：Zulip,自動：Zulip同期,自動：自動作成');\nconst closeLabel = env.ZULIP_GITLAB_CLOSE_LABEL || '状態：クローズ';\nconst reopenLabel = env.ZULIP_GITLAB_REOPEN_LABEL || '状態：対応中';\nconst decisionPrefixes = parseList(env.ZULIP_GITLAB_DECISION_PREFIXES || '/decision,[decision],[DECISION],決定:');\nconst decisionLabel = String(env.ZULIP_GITLAB_DECISION_LABEL || '').trim();\nconst decisionLlmEnabled = toBool(env.ZULIP_GITLAB_DECISION_LLM_ENABLED, true);\nconst decisionLlmApiBase = trimSlash(env.ZULIP_GITLAB_DECISION_LLM_API_BASE_URL || env.OPENAI_BASE_URL || env.N8N_LLM_API_BASE_URL || 'https://api.openai.com/v1');\nconst decisionLlmApiKey = String(env.ZULIP_GITLAB_DECISION_LLM_API_KEY || env.OPENAI_MODEL_API_KEY || env.OPENAI_API_KEY || env.N8N_LLM_API_KEY || '').trim();\nconst decisionLlmModel = String(env.ZULIP_GITLAB_DECISION_LLM_MODEL || env.OPENAI_MODEL || env.N8N_LLM_MODEL || 'gpt-4o-mini').trim();\nconst decisionLlmMinConfidence = Math.max(0, Math.min(1, Number(env.ZULIP_GITLAB_DECISION_LLM_MIN_CONFIDENCE || 0.75)));\nconst decisionLlmMaxCalls = Math.max(0, Math.min(50, toInt(env.ZULIP_GITLAB_DECISION_LLM_MAX_CALLS_PER_RUN, 10)));\nconst decisionLlmMaxTextChars = Math.max(50, Math.min(2000, toInt(env.ZULIP_GITLAB_DECISION_LLM_MAX_TEXT_CHARS, 400)));\nconst decisionLlmLogErrors = toBool(env.ZULIP_GITLAB_DECISION_LLM_LOG_ERRORS, false);\nlet decisionLlmCalls = 0;\nconst escalationLabel = env.N8N_GITLAB_ESCALATION_LABEL || env.GITLAB_ESCALATION_LABEL || '一次対応：エスカレーション';\nconst firstContactDoneLabel = env.N8N_GITLAB_FIRST_CONTACT_DONE_LABEL || env.GITLAB_FIRST_CONTACT_DONE_LABEL || '一次対応：完了';\nconst pollLimit = Math.max(1, Math.min(200, toInt(env.ZULIP_POLL_LIMIT, 50)));\nconst initialAnchor = String(env.ZULIP_INITIAL_ANCHOR || 'newest').trim() || 'newest';\n\nconst streamNamePrefixRaw = String(env.ZULIP_STREAM_NAME_PREFIX ?? 'cust-').trim();\nconst streamNamePrefix = normalizeStreamName(streamNamePrefixRaw).toLowerCase();\nconst enforceStreamNamePrefix = streamNamePrefix.length > 0;\nconst streamIds = parseList(env.ZULIP_STREAM_IDS || env.ZULIP_STREAM_ID || '');\n\nconst s3Bucket = env.N8N_S3_BUCKET || env.S3_BUCKET || '';\nconst s3Prefix = String(env.N8N_S3_PREFIX || 'itsm/customer_request').replace(/\\/+$/, '');\nconst metricsTargetDate = String(env.N8N_METRICS_TARGET_DATE || '').trim();\nconst exportEnabled = Boolean(s3Bucket);\n\nconst state = (() => {\n  if (typeof workflowContext.getWorkflowStaticData === 'function') {\n    return workflowContext.getWorkflowStaticData('global');\n  }\n  if (typeof $getWorkflowStaticData === 'function') {\n    return $getWorkflowStaticData('global');\n  }\n  return {};\n})();\nconst root = ensure(state, 'zulip_gitlab_sync', {});\nconst realmState = ensure(root, realm, { last_message_id: null, topic_map: {} });\nconst topicMap = ensure(realmState, 'topic_map', {});\nconst decisionLlmCache = ensure(realmState, 'decision_llm_cache', {});\nconst decisionLlmCacheOrder = ensure(realmState, 'decision_llm_cache_order', []);\nconst metricsByDate = ensure(realmState, 'metrics_by_date', {});\nconst lastMessageId = Number.isFinite(Number(realmState.last_message_id)) ? Number(realmState.last_message_id) : null;\n\nfunction ensureMetricsBucket(dt) {\n  if (!dt) return null;\n  if (!metricsByDate[dt]) {\n    metricsByDate[dt] = {\n      request_count: 0,\n      first_response_minutes: [],\n      resolution_minutes: [],\n      closed_count: 0,\n      escalated_count: 0,\n      fcr_count: 0,\n      reopened_count: 0,\n      backlog_count: null,\n      has_data: false\n    };\n  }\n  return metricsByDate[dt];\n}\n\nfunction recordRequest(receivedAt) {\n  const dt = dateKeyFromIso(receivedAt);\n  const bucket = ensureMetricsBucket(dt);\n  if (!bucket) return;\n  bucket.request_count += 1;\n  bucket.has_data = true;\n}\n\nfunction recordFirstResponse(entry, receivedAt) {\n  if (!entry || entry.first_response_at || !entry.created_at || !receivedAt) return;\n  const minutes = toMinutes(new Date(entry.created_at), new Date(receivedAt));\n  const dt = dateKeyFromIso(receivedAt);\n  const bucket = ensureMetricsBucket(dt);\n  if (bucket && minutes !== null) {\n    bucket.first_response_minutes.push(minutes);\n    bucket.has_data = true;\n  }\n  entry.first_response_at = receivedAt;\n}\n\nfunction recordResolution(entry, receivedAt) {\n  if (!entry || !entry.created_at || !receivedAt) return;\n  const minutes = toMinutes(new Date(entry.created_at), new Date(receivedAt));\n  const dt = dateKeyFromIso(receivedAt);\n  const bucket = ensureMetricsBucket(dt);\n  if (!bucket) return;\n  bucket.closed_count += 1;\n  if (entry.escalated) {\n    bucket.escalated_count += 1;\n  }\n  if (entry.first_contact_done && !entry.escalated) {\n    bucket.fcr_count += 1;\n  }\n  if (minutes !== null) {\n    bucket.resolution_minutes.push(minutes);\n  }\n  bucket.has_data = true;\n}\n\nfunction recordReopen(receivedAt) {\n  const dt = dateKeyFromIso(receivedAt);\n  const bucket = ensureMetricsBucket(dt);\n  if (!bucket) return;\n  bucket.reopened_count += 1;\n  bucket.has_data = true;\n}\n\nfunction backlogCountAtDate(dt) {\n  if (!dt) return null;\n  const end = new Date(`${dt}T23:59:59Z`);\n  let count = 0;\n  for (const entry of Object.values(topicMap)) {\n    if (!entry || !entry.created_at) continue;\n    const createdAt = new Date(entry.created_at);\n    if (Number.isNaN(createdAt.getTime()) || createdAt > end) continue;\n    if (entry.closed_at) {\n      const closedAt = new Date(entry.closed_at);\n      const reopenedAt = entry.reopened_at ? new Date(entry.reopened_at) : null;\n      if (!Number.isNaN(closedAt.getTime()) && closedAt <= end) {\n        if (!reopenedAt || Number.isNaN(reopenedAt.getTime()) || reopenedAt > end) {\n          continue;\n        }\n      }\n    }\n    count += 1;\n  }\n  return count;\n}\n\nfunction buildMetrics(bucket) {\n  const firstContactResolutionRate = bucket.closed_count > 0\n    ? bucket.fcr_count / bucket.closed_count\n    : null;\n  const reopenRate = bucket.closed_count > 0\n    ? bucket.reopened_count / bucket.closed_count\n    : null;\n  return {\n    realm,\n    request_count: bucket.request_count,\n    first_response_p50_minutes: percentile(bucket.first_response_minutes, 50),\n    first_response_p95_minutes: percentile(bucket.first_response_minutes, 95),\n    resolution_p50_minutes: percentile(bucket.resolution_minutes, 50),\n    resolution_p95_minutes: percentile(bucket.resolution_minutes, 95),\n    first_contact_resolution_rate: firstContactResolutionRate,\n    reopen_rate: reopenRate,\n    backlog_count: bucket.backlog_count,\n    escalated_count: bucket.escalated_count\n  };\n}\n\nfunction buildAuthHeader() {\n  return 'Basic ' + Buffer.from(`${zulipEmail}:${zulipToken}`).toString('base64');\n}\n\nasync function fetchStreamsByPrefix() {\n  if (!enforceStreamNamePrefix) return [];\n  const response = await workflowContext.helpers.httpRequest({\n    method: 'GET',\n    url: `${zulipApiBase}/streams`,\n    qs: {\n      include_public: 'true',\n      include_subscribed: 'true',\n      include_all_active: 'true'\n    },\n    json: true,\n    headers: { Authorization: buildAuthHeader() }\n  });\n  const streams = Array.isArray(response?.streams) ? response.streams : [];\n  return streams\n    .filter((stream) => {\n      const name = normalizeStreamName(stream?.name || '');\n      return name.toLowerCase().startsWith(streamNamePrefix);\n    })\n    .map((stream) => stream.stream_id)\n    .filter((id) => Number.isFinite(Number(id)) || String(id).trim() !== '');\n}\n\nasync function zulipFetch(anchor, numBefore, numAfter, narrow) {\n  const qs = {\n    anchor,\n    num_before: numBefore,\n    num_after: numAfter,\n    apply_markdown: 'false'\n  };\n  if (narrow) {\n    qs.narrow = JSON.stringify(narrow);\n  }\n  return await workflowContext.helpers.httpRequest({\n    method: 'GET',\n    url: `${zulipApiBase}/messages`,\n    qs,\n    json: true,\n    headers: { Authorization: buildAuthHeader() }\n  });\n}\n\nfunction encodeForm(params) {\n  return Object.entries(params)\n    .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`)\n    .join('&');\n}\n\nasync function zulipSendStreamMessage(stream, topic, content) {\n  if (!stream || !topic || !content) return null;\n  const payload = encodeForm({\n    type: 'stream',\n    to: String(stream),\n    topic: String(topic),\n    content: String(content)\n  });\n\n  return await workflowContext.helpers.httpRequest({\n    method: 'POST',\n    url: `${zulipApiBase}/messages`,\n    body: payload,\n    headers: {\n      Authorization: buildAuthHeader(),\n      'Content-Type': 'application/x-www-form-urlencoded'\n    },\n    json: true\n  });\n}\n\n\nasync function gitlabRequest(method, path, body) {\n  const options = {\n    method,\n    url: `${gitlabApiBase}${path}`,\n    headers: { 'PRIVATE-TOKEN': gitlabToken },\n    json: true\n  };\n  if (body) options.body = body;\n  return await workflowContext.helpers.httpRequest(options);\n}\n\nasync function fetchIssue(issueIid) {\n  return await gitlabRequest('GET', `/projects/${encodeURIComponent(projectRef)}/issues/${issueIid}`);\n}\n\nasync function createIssue(title, description, labels) {\n  const payload = {\n    title,\n    description,\n    labels: labels.join(',')\n  };\n  return await gitlabRequest('POST', `/projects/${encodeURIComponent(projectRef)}/issues`, payload);\n}\n\nasync function addNote(issueIid, body) {\n  return await gitlabRequest('POST', `/projects/${encodeURIComponent(projectRef)}/issues/${issueIid}/notes`, { body });\n}\n\nasync function closeIssue(issueIid) {\n  return await gitlabRequest('PUT', `/projects/${encodeURIComponent(projectRef)}/issues/${issueIid}`, {\n    state_event: 'close',\n    add_labels: closeLabel\n  });\n}\n\nasync function reopenIssue(issueIid) {\n  const payload = { state_event: 'reopen' };\n  if (reopenLabel) payload.add_labels = reopenLabel;\n  if (closeLabel) payload.remove_labels = closeLabel;\n  return await gitlabRequest('PUT', `/projects/${encodeURIComponent(projectRef)}/issues/${issueIid}`, payload);\n}\n\nasync function addIssueLabel(issueIid, label) {\n  if (!label) return null;\n  return await gitlabRequest('PUT', `/projects/${encodeURIComponent(projectRef)}/issues/${issueIid}`, {\n    add_labels: String(label)\n  });\n}\n\nfunction buildEventBase(params) {\n  return {\n    event_at: params.receivedAt || null,\n    realm,\n    stream_id: params.streamId ? String(params.streamId) : null,\n    topic: params.topic || null,\n    zulip_message_id: params.messageId ? String(params.messageId) : null,\n    zulip_sender_email: params.senderEmail || null,\n    zulip_message_url: params.messageUrl || null,\n    gitlab_project_path: String(projectRef)\n  };\n}\n\nasync function processMessages(messages) {\n  const created = [];\n  const updated = [];\n  const closed = [];\n  const reopened = [];\n  const skipped = [];\n  const errors = [];\n  const events = [];\n\n  const sorEvents = [];\n\n  const recordUpserts = [];\n\n  const sorted = messages.slice().sort((a, b) => (a.id || 0) - (b.id || 0));\n  for (const message of sorted) {\n    const messageId = message.id;\n    if (!messageId) continue;\n\n    if (lastMessageId && messageId <= lastMessageId) continue;\n\n    const streamId = message.stream_id;\n    const topicRaw = message.subject || message.topic || '';\n    const topic = normalizeTopic(topicRaw);\n    if (!streamId || !topic) {\n      skipped.push({ message_id: messageId, reason: 'missing_topic' });\n      continue;\n    }\n\n    const senderEmail = message.sender_email || '';\n\n    const messageText = stripHtml(message.content || message.content_text || message.text || '');\n    const normalizedText = messageText.trim().toLowerCase();\n\n\n    const botOqSeed = normalizedText.startsWith('/oq-seed');\n    const decisionMarker = matchPrefix(normalizedText, decisionPrefixes);\n\n    let decisionDetection = null;\n    if (decisionMarker) {\n      decisionDetection = { is_decision: true, confidence: 1, method: 'prefix' };\n    } else {\n      decisionDetection = await detectDecisionByLlm({\n        messageId,\n        text: messageText,\n        topic,\n        streamName: (typeof message.display_recipient === 'string' ? message.display_recipient : (message.display_recipient?.name || message.stream || '')) || '',\n        senderEmail\n      });\n    }\n\n    const isDecision = Boolean(decisionDetection?.is_decision);\n    const decisionMethod = decisionDetection?.method || null;\n    const decisionConfidence = (typeof decisionDetection?.confidence === 'number') ? decisionDetection.confidence : null;\n    const decisionText = isDecision\n      ? (decisionMarker ? stripAnyPrefix(messageText, [decisionMarker]) : String(messageText || '').trim())\n      : '';\n\n    if (senderEmail && zulipEmail && senderEmail === zulipEmail && !(botOqSeed || isDecision)) {\n      skipped.push({ message_id: messageId, reason: 'bot_message' });\n      continue;\n    }\n\n    const streamName = typeof message.display_recipient === 'string' ? message.display_recipient : '';\n    const streamLabel = buildStreamLabel(streamName);\n    const issueLabels = streamLabel ? [...defaultLabels, streamLabel] : defaultLabels;\n    const receivedAt = formatTimestamp(message.timestamp);\n    const topicUrl = messageLink(zulipUiBase, streamId, topicRaw || topic, messageId);\n    const closeRequested = normalizedText.startsWith('/close');\n    const reopenRequested = normalizedText.startsWith('/reopen');\n    const archived = isArchivedTopic(topicRaw);\n\n    const key = `${streamId}:${topic}`;\n    let entry = topicMap[key];\n\n    if (!entry) {\n      try {\n        const description = buildIssueDescription({\n          defaultType,\n          customerName: '',\n          senderName: message.sender_full_name || '',\n          senderEmail,\n          receivedAt,\n          topicUrl,\n          messageUrl: topicUrl,\n          messageText: isDecision ? decisionText : messageText,\n          streamName,\n          topic\n        });\n        const issue = await createIssue(topic, description, issueLabels);\n        entry = {\n          issue_iid: issue.iid,\n          issue_url: issue.web_url || issue.url || null,\n          status: 'open',\n          stream_id: streamId,\n          topic,\n          created_at: receivedAt || null,\n          creator_email: senderEmail || null,\n          first_response_at: null,\n          first_contact_done: null,\n          escalated: null,\n          decision_label_added: false\n        };\n        topicMap[key] = entry;\n\n        if (isDecision) {\n          const decisionComment = buildDecisionComment({\n            senderName: message.sender_full_name || '',\n            senderEmail,\n            receivedAt,\n            topic,\n            messageUrl: topicUrl,\n            decisionText,\n            decisionMethod,\n            decisionConfidence\n          });\n          await addNote(entry.issue_iid, decisionComment);\n\n          sorEvents.push({\n            realm,\n            occurred_at: receivedAt || null,\n            action: 'decision.recorded',\n            source: 'zulip',\n            actor_type: senderEmail ? 'human' : 'unknown',\n            actor: { name: message.sender_full_name || null, email: senderEmail || null },\n            resource_type: 'gitlab_issue',\n            correlation_id: `gitlab:${String(projectRef)}#${String(entry.issue_iid)}`,\n            reply_target: {\n              source: 'zulip',\n              stream_id: String(streamId),\n              topic,\n              message_id: String(messageId),\n              url: topicUrl || null\n            },\n            summary: `決定（Zulip）: ${topic}`,\n            message: decisionText || null,\n            after: {\n              gitlab_project_path: String(projectRef),\n              gitlab_issue_iid: entry.issue_iid,\n              gitlab_issue_url: entry.issue_url || null,\n              gitlab_labels: issueLabels\n            },\n            integrity: {\n              event_key: `zulip:decision:${String(messageId)}`,\n              decision_method: decisionMethod || null,\n              decision_confidence: (typeof decisionConfidence === 'number') ? decisionConfidence : null,\n              decision_marker: decisionMarker || null\n            }\n          });\n\n          if (decisionLabel && !entry.decision_label_added) {\n            try {\n              await addIssueLabel(entry.issue_iid, decisionLabel);\n              entry.decision_label_added = true;\n            } catch (error) {\n              errors.push({ message_id: messageId, error: `gitlab_label_failed: ${String(error?.message || error)}` });\n            }\n          }\n        }\n        const inferredRecordType = inferRecordTypeFromLabels(issueLabels, defaultType);\n        recordUpserts.push({\n          record_type: 'itsm_record_upsert',\n          realm,\n          record_type_hint: inferredRecordType,\n          occurred_at: receivedAt || null,\n          title: topic,\n          description: description,\n          status: 'open',\n          actor: { name: message.sender_full_name || null, email: senderEmail || null },\n          reply_target: { source: 'zulip', stream_id: String(streamId), topic, message_id: String(messageId), url: topicUrl || null },\n          gitlab: { project_path: String(projectRef), issue_iid: issue.iid, issue_url: entry.issue_url || null, labels: issueLabels }\n        });\n        created.push({ message_id: messageId, issue_iid: issue.iid, topic });\n        recordRequest(receivedAt);\n\n        const eventBase = buildEventBase({\n          receivedAt,\n          streamId,\n          topic,\n          messageId,\n          senderEmail,\n          messageUrl: topicUrl\n        });\n        events.push({\n          ...eventBase,\n          event_id: `${messageId}-topic`,\n          event_type: 'topic_created',\n          gitlab_issue_iid: issue.iid,\n          gitlab_issue_state: 'opened',\n          gitlab_labels: issueLabels,\n          issue_title: topic,\n          issue_url: entry.issue_url,\n          issue_created_at: entry.created_at,\n          issue_updated_at: receivedAt || null\n        });\n\n        if (isDecision) {\n          events.push({\n            ...eventBase,\n            event_id: `${messageId}-decision`,\n            event_type: 'decision_recorded',\n            decision_marker: decisionMarker || (decisionMethod === 'llm' ? 'llm' : null),\n            decision_method: decisionMethod || null,\n            decision_confidence: (typeof decisionConfidence === 'number') ? decisionConfidence : null,\n            gitlab_issue_iid: entry.issue_iid,\n            gitlab_issue_state: 'opened',\n            gitlab_labels: issueLabels,\n            issue_title: topic,\n            issue_url: entry.issue_url,\n            issue_created_at: entry.created_at,\n            issue_updated_at: receivedAt || null\n          });\n        }\n\n        try {\n          await zulipSendStreamMessage(streamName || streamId, topicRaw || topic, isDecision\n            ? `GitLab Issueを作成し、決定を証跡として記録しました: ${entry.issue_url || ''} (#${issue.iid})`\n            : `GitLab Issueを作成しました: ${entry.issue_url || ''} (#${issue.iid})`);\n        } catch (error) {\n          errors.push({ message_id: messageId, error: `zulip_notify_failed: ${String(error?.message || error)}` });\n        }\n      } catch (error) {\n        errors.push({ message_id: messageId, error: String(error?.message || error) });\n        continue;\n      }\n    } else {\n      try {\n        const comment = isDecision\n          ? buildDecisionComment({\n              senderName: message.sender_full_name || '',\n              senderEmail,\n              receivedAt,\n              topic,\n              messageUrl: topicUrl,\n              decisionText\n            })\n          : buildComment({\n              senderName: message.sender_full_name || '',\n              senderEmail,\n              receivedAt,\n              topic,\n              messageUrl: topicUrl,\n              messageText\n            });\n        await addNote(entry.issue_iid, comment);\n\n        if (isDecision) {\n          sorEvents.push({\n            realm,\n            occurred_at: receivedAt || null,\n            action: 'decision.recorded',\n            source: 'zulip',\n            actor_type: senderEmail ? 'human' : 'unknown',\n            actor: { name: message.sender_full_name || null, email: senderEmail || null },\n            resource_type: 'gitlab_issue',\n            correlation_id: `gitlab:${String(projectRef)}#${String(entry.issue_iid)}`,\n            reply_target: {\n              source: 'zulip',\n              stream_id: String(streamId),\n              topic,\n              message_id: String(messageId),\n              url: topicUrl || null\n            },\n            summary: `決定（Zulip）: ${topic}`,\n            message: decisionText || null,\n            after: {\n              gitlab_project_path: String(projectRef),\n              gitlab_issue_iid: entry.issue_iid,\n              gitlab_issue_url: entry.issue_url || null,\n              gitlab_labels: issueLabels\n            },\n            integrity: {\n              event_key: `zulip:decision:${String(messageId)}`,\n              decision_method: decisionMethod || null,\n              decision_confidence: (typeof decisionConfidence === 'number') ? decisionConfidence : null,\n              decision_marker: decisionMarker || null\n            }\n          });\n        }\n\n        if (isDecision && decisionLabel && !entry.decision_label_added) {\n          try {\n            await addIssueLabel(entry.issue_iid, decisionLabel);\n            entry.decision_label_added = true;\n          } catch (error) {\n            errors.push({ message_id: messageId, error: `gitlab_label_failed: ${String(error?.message || error)}` });\n          }\n        }\n        updated.push({ message_id: messageId, issue_iid: entry.issue_iid, topic });\n        recordUpserts.push({\n          record_type: 'itsm_record_upsert',\n          realm,\n          record_type_hint: null,\n          occurred_at: receivedAt || null,\n          title: topic,\n          description: messageText,\n          status: 'open',\n          actor: { name: message.sender_full_name || null, email: senderEmail || null },\n          reply_target: { source: 'zulip', stream_id: String(streamId), topic, message_id: String(messageId), url: topicUrl || null },\n          gitlab: { project_path: String(projectRef), issue_iid: entry.issue_iid, issue_url: entry.issue_url || null, labels: issueLabels }\n        });\n        entry.updated_at = receivedAt || null;\n        const sameSender = senderEmail && entry.creator_email && senderEmail === entry.creator_email;\n        if (!entry.first_response_at && !sameSender) {\n          recordFirstResponse(entry, receivedAt);\n        }\n\n        const eventBase = buildEventBase({\n          receivedAt,\n          streamId,\n          topic,\n          messageId,\n          senderEmail,\n          messageUrl: topicUrl\n        });\n        events.push({\n          ...eventBase,\n          event_id: `${messageId}-message`,\n          event_type: isDecision ? 'decision_recorded' : 'message_added',\n          decision_marker: decisionMarker || null,\n          gitlab_issue_iid: entry.issue_iid,\n          gitlab_issue_state: entry.status === 'closed' ? 'closed' : 'opened',\n          gitlab_labels: issueLabels,\n          issue_title: entry.topic || topic,\n          issue_url: entry.issue_url,\n          issue_created_at: entry.created_at || null,\n          issue_updated_at: entry.updated_at || null\n        });\n\n        try {\n          await zulipSendStreamMessage(streamName || streamId, topicRaw || topic, isDecision\n            ? `決定をGitLabへ証跡として記録しました: ${entry.issue_url || ''} (#${entry.issue_iid})`\n            : `GitLabへコメントを同期しました: ${entry.issue_url || ''} (#${entry.issue_iid})`);\n        } catch (error) {\n          errors.push({ message_id: messageId, error: `zulip_notify_failed: ${String(error?.message || error)}` });\n        }\n      } catch (error) {\n        errors.push({ message_id: messageId, error: String(error?.message || error) });\n      }\n    }\n\n    if (reopenRequested) {\n      if (entry && entry.status === 'closed') {\n        try {\n          await reopenIssue(entry.issue_iid);\n          const reopenComment = buildReopenComment({\n            reason: '/reopen 指示',\n            receivedAt,\n            topic,\n            messageUrl: topicUrl\n          });\n          await addNote(entry.issue_iid, reopenComment);\n          entry.status = 'open';\n          entry.reopened_at = receivedAt || null;\n          reopened.push({ message_id: messageId, issue_iid: entry.issue_iid, topic });\n          recordUpserts.push({ record_type: 'itsm_record_upsert', realm, record_type_hint: null, occurred_at: receivedAt || null, title: entry.topic || topic, description: null, status: 'open', actor: { name: message.sender_full_name || null, email: senderEmail || null }, reply_target: { source: 'zulip', stream_id: String(streamId), topic, message_id: String(messageId), url: topicUrl || null }, gitlab: { project_path: String(projectRef), issue_iid: entry.issue_iid, issue_url: entry.issue_url || null, labels: issueLabels } });\n          recordReopen(receivedAt);\n\n          const eventBase = buildEventBase({\n            receivedAt,\n            streamId,\n            topic,\n            messageId,\n            senderEmail,\n            messageUrl: topicUrl\n          });\n          events.push({\n            ...eventBase,\n            event_id: `${messageId}-reopen`,\n            event_type: 'issue_reopened',\n            gitlab_issue_iid: entry.issue_iid,\n            gitlab_issue_state: 'opened',\n            gitlab_labels: [...issueLabels, reopenLabel].filter(Boolean),\n            issue_title: entry.topic || topic,\n            issue_url: entry.issue_url,\n            issue_created_at: entry.created_at || null,\n            issue_updated_at: receivedAt || null\n          });\n\n          try {\n            await zulipSendStreamMessage(streamName || streamId, topicRaw || topic, `GitLab Issueを再オープンしました: ${entry.issue_url || ''} (#${entry.issue_iid})`);\n          } catch (error) {\n            errors.push({ message_id: messageId, error: `zulip_notify_failed: ${String(error?.message || error)}` });\n          }\n        } catch (error) {\n          errors.push({ message_id: messageId, error: String(error?.message || error) });\n        }\n      }\n    } else if (closeRequested || archived) {\n      if (entry && entry.status !== 'closed') {\n        try {\n          await closeIssue(entry.issue_iid);\n          const reason = closeRequested ? '/close 指示' : '[ARCHIVED] 付与';\n          const closeComment = buildCloseComment({\n            reason,\n            receivedAt,\n            topic,\n            messageUrl: topicUrl\n          });\n          await addNote(entry.issue_iid, closeComment);\n          entry.status = 'closed';\n          entry.closed_at = receivedAt || null;\n\n          try {\n            const issue = await fetchIssue(entry.issue_iid);\n            const labels = Array.isArray(issue?.labels) ? issue.labels : [];\n            entry.escalated = labels.includes(escalationLabel);\n            entry.first_contact_done = labels.includes(firstContactDoneLabel);\n          } catch (error) {\n            entry.escalated = entry.escalated ?? null;\n            entry.first_contact_done = entry.first_contact_done ?? null;\n          }\n\n          closed.push({ message_id: messageId, issue_iid: entry.issue_iid, topic });\n          recordUpserts.push({ record_type: 'itsm_record_upsert', realm, record_type_hint: null, occurred_at: entry.closed_at || receivedAt || null, title: entry.topic || topic, description: null, status: 'closed', actor: { name: message.sender_full_name || null, email: senderEmail || null }, reply_target: { source: 'zulip', stream_id: String(streamId), topic, message_id: String(messageId), url: topicUrl || null }, gitlab: { project_path: String(projectRef), issue_iid: entry.issue_iid, issue_url: entry.issue_url || null, labels: issueLabels } });\n          recordResolution(entry, receivedAt);\n\n          const eventBase = buildEventBase({\n            receivedAt,\n            streamId,\n            topic,\n            messageId,\n            senderEmail,\n            messageUrl: topicUrl\n          });\n          events.push({\n            ...eventBase,\n            event_id: `${messageId}-close`,\n            event_type: 'issue_closed',\n            gitlab_issue_iid: entry.issue_iid,\n            gitlab_issue_state: 'closed',\n            gitlab_labels: [...issueLabels, closeLabel],\n            issue_title: entry.topic || topic,\n            issue_url: entry.issue_url,\n            issue_created_at: entry.created_at || null,\n            issue_closed_at: entry.closed_at || null,\n            issue_updated_at: entry.closed_at || null\n          });\n\n          try {\n            await zulipSendStreamMessage(streamName || streamId, topicRaw || topic, `GitLab Issueをクローズしました: ${entry.issue_url || ''} (#${entry.issue_iid})`);\n          } catch (error) {\n            errors.push({ message_id: messageId, error: `zulip_notify_failed: ${String(error?.message || error)}` });\n          }\n        } catch (error) {\n          errors.push({ message_id: messageId, error: String(error?.message || error) });\n        }\n      }\n    }\n  }\n\n  return { created, updated, closed, reopened, skipped, errors, events, sorEvents, recordUpserts };\n}\n\nasync function fetchAllMessages() {\n  const numBefore = (!lastMessageId && initialAnchor === 'newest') ? pollLimit : 0;\n  const numAfter = (!lastMessageId && initialAnchor === 'newest') ? 0 : pollLimit;\n  const anchor = lastMessageId || initialAnchor;\n\n  if (!streamIds.length && !enforceStreamNamePrefix) {\n    const response = await zulipFetch(anchor, numBefore, numAfter, null);\n    return Array.isArray(response?.messages) ? response.messages : [];\n  }\n\n  const resolvedStreamIds = streamIds.length ? streamIds : await fetchStreamsByPrefix();\n  if (!resolvedStreamIds.length) return [];\n\n  const all = [];\n  for (const streamId of resolvedStreamIds) {\n    const narrow = [{ operator: 'stream', operand: Number.isFinite(Number(streamId)) ? Number(streamId) : streamId }];\n    const response = await zulipFetch(anchor, numBefore, numAfter, narrow);\n    if (Array.isArray(response?.messages)) {\n      all.push(...response.messages);\n    }\n  }\n  return all;\n}\n\nconst messages = await fetchAllMessages();\nconst result = await processMessages(messages);\nconst runId = new Date().toISOString().replace(/[-:.TZ]/g, '');\n\nconst skippedReasons = {};\nfor (const item of result.skipped || []) {\n  const reason = String(item?.reason || 'unknown');\n  skippedReasons[reason] = (skippedReasons[reason] || 0) + 1;\n}\n\nconst outputItems = [\n  {\n    json: {\n      record_type: 'sync_summary',\n      ok: true,\n      realm,\n      received: messages.length,\n      created: result.created.length,\n      updated: result.updated.length,\n      closed: result.closed.length,\n      reopened: result.reopened.length,\n      skipped: result.skipped.length,\n      skipped_reasons: skippedReasons,\n      errors: result.errors\n    }\n  }\n];\n\n\nfor (const ev of result.sorEvents || []) {\n  outputItems.push({\n    json: {\n      record_type: 'sor_audit_event',\n      realm: ev.realm || realm,\n      occurred_at: ev.occurred_at || null,\n      action: ev.action,\n      source: ev.source,\n      actor_type: ev.actor_type,\n      actor: ev.actor || {},\n      resource_type: ev.resource_type || null,\n      correlation_id: ev.correlation_id || null,\n      reply_target: ev.reply_target || {},\n      summary: ev.summary || null,\n      message: ev.message || null,\n      after: ev.after || {},\n      integrity: ev.integrity || {}\n    }\n  });\n}\nfor (const rec of result.recordUpserts || []) {\n  outputItems.push({ json: rec });\n}\n\n\nif (exportEnabled && result.events.length) {\n  const eventGroups = {};\n  for (const event of result.events) {\n    const dt = dateKeyFromIso(event.event_at);\n    if (!dt) continue;\n    if (!eventGroups[dt]) eventGroups[dt] = [];\n    eventGroups[dt].push(event);\n  }\n\n  for (const [dt, events] of Object.entries(eventGroups)) {\n    const eventsBody = events.map((item) => JSON.stringify(item)).join('\\n') + '\\n';\n    const eventsKey = `${s3Prefix}/events/dt=${dt}/realm=${realm}/zulip_events_${runId}.jsonl`;\n\n    outputItems.push({\n      json: {\n        record_type: 'events',\n        s3_bucket: s3Bucket,\n        s3_key: eventsKey,\n        dt,\n        realm\n      },\n      binary: {\n        data: {\n          data: Buffer.from(eventsBody, 'utf8').toString('base64'),\n          mimeType: 'application/json',\n          fileName: `zulip_events_${runId}.jsonl`\n        }\n      }\n    });\n  }\n}\n\nif (exportEnabled) {\n  const today = toDateKey(new Date());\n  const dates = metricsTargetDate\n    ? [metricsTargetDate]\n    : Object.keys(metricsByDate).filter((dt) => dt < today).sort();\n\n  for (const dt of dates) {\n    const bucket = ensureMetricsBucket(dt);\n    if (!bucket) continue;\n    bucket.backlog_count = backlogCountAtDate(dt);\n\n    const shouldExport = metricsTargetDate\n      ? true\n      : (bucket.has_data || (bucket.backlog_count && bucket.backlog_count > 0));\n    if (!shouldExport) {\n      if (metricsTargetDate) {\n        delete metricsByDate[dt];\n      }\n      continue;\n    }\n\n    const metrics = buildMetrics(bucket);\n    const metricsBody = JSON.stringify(metrics);\n    const metricsKey = `${s3Prefix}/daily_metrics/dt=${dt}/realm=${realm}/zulip_metrics_${runId}.json`;\n\n    outputItems.push({\n      json: {\n        record_type: 'daily_metrics',\n        s3_bucket: s3Bucket,\n        s3_key: metricsKey,\n        dt,\n        realm\n      },\n      binary: {\n        data: {\n          data: Buffer.from(metricsBody, 'utf8').toString('base64'),\n          mimeType: 'application/json',\n          fileName: `zulip_metrics_${dt}_${runId}.json`\n        }\n      }\n    });\n\n    delete metricsByDate[dt];\n  }\n}\n\nreturn outputItems;\n"
      },
      "id": "2",
      "name": "Zulip to GitLab Sync",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        200
      ]
    },
    {
      "parameters": {
        "content": "Env\n- N8N_REALM (or N8N_OBSERVER_REALM)\n- (realm map) N8N_ZULIP_API_BASE_URL/YAML\n- (realm map) N8N_ZULIP_BOT_EMAIL/YAML\n- (realm map) N8N_ZULIP_BOT_TOKEN/YAML\n- (fallback) N8N_ZULIP_API_BASE_URL or ZULIP_API_BASE_URL or ZULIP_BASE_URL\n- (fallback) ZULIP_BOT_EMAIL\n- (fallback) ZULIP_API_KEY or ZULIP_BOT_API_KEY\n- ZULIP_STREAM_NAME_PREFIX (default: cust-)\n- ZULIP_STREAM_IDS (optional)\n- GITLAB_API_BASE_URL or GITLAB_BASE_URL or GITLAB_URL or SERVICE_URL_GITLAB\n- GITLAB_TOKEN or GITLAB_ADMIN_TOKEN\n- GITLAB_PROJECT_ID or GITLAB_PROJECT_PATH\n- ZULIP_GITLAB_DEFAULT_LABELS (optional)\n- ZULIP_GITLAB_CLOSE_LABEL (optional)\n- ZULIP_GITLAB_REOPEN_LABEL (optional)\n- ZULIP_GITLAB_DECISION_PREFIXES (optional)\n- ZULIP_GITLAB_DECISION_LABEL (optional)\n- N8N_GITLAB_ESCALATION_LABEL (optional)\n- N8N_GITLAB_FIRST_CONTACT_DONE_LABEL (optional)\n- ZULIP_INITIAL_ANCHOR (optional)\n- N8N_S3_BUCKET (optional)\n- N8N_S3_PREFIX (optional)\n- N8N_METRICS_TARGET_DATE (optional)\n- (notify) 同期結果は対象 stream/topic へ bot が投稿します（ZULIP_BOT_EMAIL）\n- (fallback) ZULIP_REALM_URL_TEMPLATE or HOSTED_ZONE_NAME",
        "height": 220,
        "width": 420,
        "color": 6
      },
      "id": "100",
      "name": "Sticky Note: env",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        200,
        420
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.record_type}}",
              "value2": "events"
            }
          ]
        }
      },
      "id": "3",
      "name": "IF Events",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        720,
        140
      ]
    },
    {
      "parameters": {
        "operation": "upload",
        "bucketName": "={{$json.s3_bucket}}",
        "binaryData": true,
        "binaryPropertyName": "data",
        "fileName": "={{$json.s3_key}}"
      },
      "id": "4",
      "name": "S3 Upload Events",
      "type": "n8n-nodes-base.awsS3",
      "typeVersion": 1,
      "position": [
        960,
        140
      ],
      "continueOnFail": true,
      "alwaysOutputData": true,
      "credentials": {
        "aws": {
          "id": "aiops-aws",
          "name": "aiops-aws"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.record_type}}",
              "value2": "daily_metrics"
            }
          ]
        }
      },
      "id": "5",
      "name": "IF Metrics",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        720,
        260
      ]
    },
    {
      "parameters": {
        "operation": "upload",
        "bucketName": "={{$json.s3_bucket}}",
        "binaryData": true,
        "binaryPropertyName": "data",
        "fileName": "={{$json.s3_key}}"
      },
      "id": "6",
      "name": "S3 Upload Metrics",
      "type": "n8n-nodes-base.awsS3",
      "typeVersion": 1,
      "position": [
        960,
        260
      ],
      "continueOnFail": true,
      "alwaysOutputData": true,
      "credentials": {
        "aws": {
          "id": "aiops-aws",
          "name": "aiops-aws"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.record_type}}",
              "value2": "sor_audit_event"
            }
          ]
        }
      },
      "id": "101",
      "name": "IF SoR Audit Event",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        680,
        40
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH v AS (\n  SELECT\n    itsm.get_realm_id(NULLIF('{{ $json.realm }}','')) AS realm_id,\n    COALESCE(NULLIF(NULLIF('{{ $json.occurred_at }}',''), 'undefined')::timestamptz, NOW()) AS occurred_at,\n    COALESCE(NULLIF('{{ JSON.stringify($json.actor || {}).replace(/'/g, \"''\") }}', 'undefined')::jsonb, '{}'::jsonb) AS actor,\n    COALESCE(NULLIF('{{ String($json.actor_type ?? \"unknown\").replace(/'/g, \"''\") }}', 'undefined'), 'unknown') AS actor_type,\n    '{{ String($json.action || '').replace(/'/g, \"''\") }}' AS action,\n    '{{ String($json.source || '').replace(/'/g, \"''\") }}' AS source,\n    NULLIF('{{ String($json.resource_type || '').replace(/'/g, \"''\") }}','') AS resource_type,\n    NULLIF('{{ String($json.correlation_id || '').replace(/'/g, \"''\") }}','') AS correlation_id,\n    COALESCE(NULLIF('{{ JSON.stringify($json.reply_target || {}).replace(/'/g, \"''\") }}', 'undefined')::jsonb, '{}'::jsonb) AS reply_target,\n    NULLIF('{{ String($json.summary || '').replace(/'/g, \"''\") }}','') AS summary,\n    NULLIF('{{ String($json.message || '').replace(/'/g, \"''\") }}','') AS message,\n    COALESCE(NULLIF('{{ JSON.stringify($json.after || {}).replace(/'/g, \"''\") }}', 'undefined')::jsonb, '{}'::jsonb) AS after,\n    COALESCE(NULLIF('{{ JSON.stringify($json.integrity || {}).replace(/'/g, \"''\") }}', 'undefined')::jsonb, '{}'::jsonb) AS integrity\n)\nINSERT INTO itsm.audit_event (\n  realm_id, occurred_at, actor, actor_type, action, source,\n  resource_type, correlation_id, reply_target, summary, message, after, integrity\n)\nSELECT\n  v.realm_id, v.occurred_at, v.actor, v.actor_type, v.action, v.source,\n  v.resource_type, v.correlation_id, v.reply_target, v.summary, v.message, v.after, v.integrity\nFROM v\nON CONFLICT DO NOTHING\nRETURNING id;"
      },
      "id": "102",
      "name": "Insert SoR Audit Event",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        900,
        40
      ],
      "credentials": {
        "postgres": {
          "name": "RDS Postgres"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.record_type}}",
              "value2": "itsm_record_upsert"
            }
          ]
        }
      },
      "id": "103",
      "name": "IF ITSM Record Upsert",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        680,
        -120
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH incoming AS (\n  SELECT\n    itsm.get_realm_id(NULLIF('{{ $json.realm }}','')) AS realm_id,\n    '{{ String(($json.gitlab?.project_path ?? '')).replace(/'/g, \"''\") }}' AS project_path,\n    NULLIF('{{ String(($json.gitlab?.issue_iid ?? '')).replace(/'/g, \"''\") }}','')::int AS issue_iid,\n    NULLIF('{{ String(($json.gitlab?.issue_url ?? '')).replace(/'/g, \"''\") }}','') AS issue_url,\n    COALESCE(NULLIF('{{ JSON.stringify($json.gitlab || {}).replace(/'/g, \"''\") }}', 'undefined')::jsonb, '{}'::jsonb) AS gitlab_meta,\n    NULLIF('{{ String($json.title || '').replace(/'/g, \"''\") }}','') AS title,\n    NULLIF('{{ String($json.description || '').replace(/'/g, \"''\") }}','') AS description,\n    LOWER(NULLIF('{{ String($json.status || '').replace(/'/g, \"''\") }}','')) AS status,\n    COALESCE(NULLIF('{{ JSON.stringify($json.actor || {}).replace(/'/g, \"''\") }}', 'undefined')::jsonb, '{}'::jsonb) AS actor,\n    COALESCE(NULLIF('{{ JSON.stringify($json.reply_target || {}).replace(/'/g, \"''\") }}', 'undefined')::jsonb, '{}'::jsonb) AS reply_target,\n    NULLIF('{{ String($json.record_type_hint || '').replace(/'/g, \"''\") }}','') AS record_type_hint\n), ref AS (\n  SELECT\n    realm_id,\n    'gitlab_issue'::text AS ref_type,\n    ('gitlab:issue:' || project_path || '#' || issue_iid::text) AS ref_key,\n    issue_url,\n    jsonb_build_object(\n      'project_path', project_path,\n      'issue_iid', issue_iid,\n      'issue_url', issue_url,\n      'gitlab', gitlab_meta,\n      'reply_target', reply_target\n    ) AS meta,\n    title,\n    description,\n    status,\n    actor,\n    reply_target,\n    COALESCE(NULLIF(record_type_hint,''), 'service_request') AS desired_type\n  FROM incoming\n), existing AS (\n  SELECT r.id AS external_ref_id, r.resource_type, r.resource_id\n  FROM itsm.external_ref r\n  JOIN ref v ON v.realm_id = r.realm_id AND r.ref_type = v.ref_type AND r.ref_key = v.ref_key\n  LIMIT 1\n), eff AS (\n  SELECT\n    v.*, \n    COALESCE(existing.resource_type, v.desired_type) AS resource_type_effective,\n    existing.resource_id AS existing_resource_id\n  FROM ref v\n  LEFT JOIN existing ON TRUE\n), ins_incident AS (\n  INSERT INTO itsm.incident (realm_id, number, title, description, status, requester_principal_id)\n  SELECT\n    e.realm_id,\n    itsm.next_record_number(e.realm_id, 'incident', 'INC'),\n    e.title,\n    e.description,\n    CASE WHEN e.status = 'closed' THEN 'closed' ELSE 'new' END,\n    NULLIF(e.actor #>> '{email}', '')\n  FROM eff e\n  WHERE e.resource_type_effective = 'incident' AND e.existing_resource_id IS NULL\n  RETURNING id\n), ins_srq AS (\n  INSERT INTO itsm.service_request (realm_id, number, title, description, status, requester_principal_id)\n  SELECT\n    e.realm_id,\n    itsm.next_record_number(e.realm_id, 'service_request', 'SRQ'),\n    e.title,\n    e.description,\n    CASE WHEN e.status = 'closed' THEN 'closed' ELSE 'new' END,\n    NULLIF(e.actor #>> '{email}', '')\n  FROM eff e\n  WHERE e.resource_type_effective = 'service_request' AND e.existing_resource_id IS NULL\n  RETURNING id\n), ins_prb AS (\n  INSERT INTO itsm.problem (realm_id, number, title, description, status)\n  SELECT\n    e.realm_id,\n    itsm.next_record_number(e.realm_id, 'problem', 'PRB'),\n    e.title,\n    e.description,\n    CASE WHEN e.status = 'closed' THEN 'closed' ELSE 'new' END\n  FROM eff e\n  WHERE e.resource_type_effective = 'problem' AND e.existing_resource_id IS NULL\n  RETURNING id\n), ins_chg AS (\n  INSERT INTO itsm.change_request (realm_id, number, title, description, status)\n  SELECT\n    e.realm_id,\n    itsm.next_record_number(e.realm_id, 'change_request', 'CHG'),\n    e.title,\n    e.description,\n    CASE WHEN e.status = 'closed' THEN 'closed' ELSE 'new' END\n  FROM eff e\n  WHERE e.resource_type_effective = 'change_request' AND e.existing_resource_id IS NULL\n  RETURNING id\n), resolved AS (\n  SELECT\n    e.realm_id,\n    e.ref_type,\n    e.ref_key,\n    e.issue_url,\n    e.meta,\n    e.resource_type_effective AS resource_type,\n    COALESCE(\n      e.existing_resource_id,\n      (SELECT id FROM ins_incident LIMIT 1),\n      (SELECT id FROM ins_srq LIMIT 1),\n      (SELECT id FROM ins_prb LIMIT 1),\n      (SELECT id FROM ins_chg LIMIT 1)\n    ) AS resource_id,\n    e.title,\n    e.description,\n    e.status\n  FROM eff e\n), upd_inc AS (\n  UPDATE itsm.incident i\n  SET\n    title = COALESCE(r.title, i.title),\n    description = COALESCE(r.description, i.description),\n    status = CASE WHEN r.status = 'closed' THEN 'closed' ELSE i.status END\n  FROM resolved r\n  WHERE r.resource_type = 'incident' AND i.id = r.resource_id\n  RETURNING i.id\n), upd_srq AS (\n  UPDATE itsm.service_request s\n  SET\n    title = COALESCE(r.title, s.title),\n    description = COALESCE(r.description, s.description),\n    status = CASE WHEN r.status = 'closed' THEN 'closed' ELSE s.status END\n  FROM resolved r\n  WHERE r.resource_type = 'service_request' AND s.id = r.resource_id\n  RETURNING s.id\n), upd_prb AS (\n  UPDATE itsm.problem p\n  SET\n    title = COALESCE(r.title, p.title),\n    description = COALESCE(r.description, p.description),\n    status = CASE WHEN r.status = 'closed' THEN 'closed' ELSE p.status END\n  FROM resolved r\n  WHERE r.resource_type = 'problem' AND p.id = r.resource_id\n  RETURNING p.id\n), upd_chg AS (\n  UPDATE itsm.change_request c\n  SET\n    title = COALESCE(r.title, c.title),\n    description = COALESCE(r.description, c.description),\n    status = CASE WHEN r.status = 'closed' THEN 'closed' ELSE c.status END\n  FROM resolved r\n  WHERE r.resource_type = 'change_request' AND c.id = r.resource_id\n  RETURNING c.id\n)\nINSERT INTO itsm.external_ref (realm_id, resource_type, resource_id, ref_type, ref_key, ref_url, meta)\nSELECT\n  r.realm_id,\n  r.resource_type,\n  r.resource_id,\n  r.ref_type,\n  r.ref_key,\n  r.issue_url,\n  r.meta\nFROM resolved r\nWHERE r.resource_id IS NOT NULL\nON CONFLICT (realm_id, resource_type, resource_id, ref_type, ref_key) DO UPDATE\nSET ref_url = EXCLUDED.ref_url,\n    meta = COALESCE(EXCLUDED.meta, itsm.external_ref.meta)\nRETURNING id;"
      },
      "id": "104",
      "name": "Upsert ITSM Record + External Ref",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        920,
        -120
      ],
      "continueOnFail": true
    }
  ],
  "connections": {
    "Cron Sync": {
      "main": [
        [
          {
            "node": "Zulip to GitLab Sync",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook (OQ)": {
      "main": [
        [
          {
            "node": "Zulip to GitLab Sync",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Zulip to GitLab Sync": {
      "main": [
        [
          {
            "node": "IF Events",
            "type": "main",
            "index": 0
          },
          {
            "node": "IF Metrics",
            "type": "main",
            "index": 0
          },
          {
            "node": "IF SoR Audit Event",
            "type": "main",
            "index": 0
          },
          {
            "node": "IF ITSM Record Upsert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Events": {
      "main": [
        [
          {
            "node": "S3 Upload Events",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "IF Metrics": {
      "main": [
        [
          {
            "node": "S3 Upload Metrics",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "IF SoR Audit Event": {
      "main": [
        [
          {
            "node": "Insert SoR Audit Event",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Insert SoR Audit Event": {},
    "IF ITSM Record Upsert": {
      "main": [
        [
          {
            "node": "Upsert ITSM Record + External Ref",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    }
  },
  "active": false,
  "settings": {},
  "versionId": "1",
  "meta": {
    "workflowId": "wf.zulip_gitlab_issue_sync",
    "revision": 1,
    "aiops_catalog": {
      "summary": "ZulipトピックをGitLab Issueへ同期（作成/更新/クローズ）",
      "realm": "default",
      "platform": "n8n",
      "required_roles": [
        "service_desk"
      ],
      "required_groups": [],
      "required_users": [],
      "risk_level": "low",
      "impact_scope": "service",
      "category": "service_request",
      "workflow_class": "service_request"
    }
  }
}