{
  "name": "aiops-adapter-feedback",
  "nodes": [
    {
  "parameters": {
    "path": "feedback/job",
    "httpMethod": "POST",
    "responseMode": "responseNode",
    "options": {}
  },
      "id": "1",
      "name": "Webhook (Job Feedback)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        260,
        240
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { ok: true } }}",
        "options": {}
      },
      "id": "2",
      "name": "Respond 200",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        480,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst incoming = $json ?? {};\nconst body = (incoming && typeof incoming === 'object' && incoming.body && typeof incoming.body === 'object')\n  ? incoming.body\n  : incoming;\nconst headers = (incoming && typeof incoming === 'object' && incoming.headers && typeof incoming.headers === 'object')\n  ? incoming.headers\n  : (incoming && typeof incoming === 'object' && incoming.raw_headers && typeof incoming.raw_headers === 'object')\n    ? incoming.raw_headers\n    : {};\n\nlet interactionGrammar = null;\ntry {\n  interactionGrammar = JSON.parse(\"__POLICY__INTERACTION_GRAMMAR__\");\n} catch (error) {\n  interactionGrammar = null;\n}\n\nlet decisionPolicyDoc = null;\ntry {\n  decisionPolicyDoc = JSON.parse(\"__POLICY__DECISION__\");\n} catch (error) {\n  decisionPolicyDoc = null;\n}\n\nconst fallbackScoreRange = decisionPolicyDoc?.defaults?.feedback?.smile_score_range ?? { min: 1, max: 4 };\nconst scoreRange = interactionGrammar?.feedback?.smile_score_range ?? fallbackScoreRange;\nconst minScore = Number.parseInt(String(scoreRange.min ?? 1), 10);\nconst maxScore = Number.parseInt(String(scoreRange.max ?? 4), 10);\n\nconst fallbackResolvedValues = decisionPolicyDoc?.defaults?.feedback?.resolved_values ?? ['true', 'false'];\nconst resolvedValues = Array.isArray(interactionGrammar?.feedback?.resolved_values)\n  ? interactionGrammar.feedback.resolved_values.map((v) => String(v).trim().toLowerCase()).filter(Boolean)\n  : fallbackResolvedValues;\n\nconst jobId = body.job_id ?? body.jobId ?? null;\nif (!jobId) throw new Error('job_id は必須です');\n\nconst resolvedRaw = body.resolved;\nif (resolvedRaw === undefined || resolvedRaw === null) {\n  throw new Error('resolved は必須です');\n}\n\nconst resolved = (() => {\n  if (typeof resolvedRaw === 'boolean') return resolvedRaw;\n  const v = String(resolvedRaw).trim().toLowerCase();\n  if (v === 'true' && resolvedValues.includes('true')) return true;\n  if (v === 'false' && resolvedValues.includes('false')) return false;\n  throw new Error(`resolved は ${resolvedValues.join('|')} のいずれかで指定してください`);\n})();\n\nconst scoreRaw = body.smile_score ?? body.smileScore ?? body.score ?? null;\nconst score = Number.parseInt(String(scoreRaw ?? ''), 10);\nif (!Number.isInteger(score) || score < minScore || score > maxScore) {\n  throw new Error(`smile_score は ${minScore}..${maxScore} の整数で指定してください`);\n}\n\nconst commentRaw = body.comment ?? body.message ?? '';\nconst comment = String(commentRaw).trim();\n\nconst actor = (() => {\n  if (body.actor && typeof body.actor === 'object') return body.actor;\n  return {\n    source: 'feedback',\n    remote_ip: headers['x-forwarded-for'] ?? null,\n    user_agent: headers['user-agent'] ?? null\n  };\n})();\n\nreturn [\n  {\n    json: {\n      feedback_id: crypto.randomUUID(),\n      job_id: String(jobId),\n      resolved,\n      smile_score: score,\n      comment,\n      actor\n    }\n  }\n];\n"
      },
      "id": "3",
      "name": "Parse Feedback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        440
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH ctx AS (\n  SELECT q.context_id, c.status AS current_status, c.reply_target, c.normalized_event\n  FROM aiops_job_queue q\n  JOIN aiops_context c ON c.context_id = q.context_id\n  WHERE q.job_id = '{{$json.job_id}}'::uuid\n  LIMIT 1\n), jr AS (\n  SELECT status, result_payload, error_payload\n  FROM aiops_job_results\n  WHERE job_id = '{{$json.job_id}}'::uuid\n  LIMIT 1\n)\nSELECT\n  '{{$json.feedback_id}}'::uuid AS feedback_id,\n  '{{$json.job_id}}'::uuid AS job_id,\n  {{$json.resolved}} AS resolved,\n  {{$json.smile_score}} AS smile_score,\n  NULLIF(('{{ JSON.stringify($json.comment || '').replace(/'/g, \"''\") }}'::jsonb #>> '{}'), '') AS comment,\n  '{{ JSON.stringify($json.actor || {}).replace(/'/g, \"''\") }}'::jsonb AS actor,\n  (SELECT context_id FROM ctx) AS context_id,\n  (SELECT current_status FROM ctx) AS current_status,\n  (SELECT reply_target FROM ctx) AS reply_target,\n  (SELECT normalized_event FROM ctx) AS normalized_event,\n  (SELECT status FROM jr) AS job_status,\n  (SELECT result_payload FROM jr) AS result_payload,\n  (SELECT error_payload FROM jr) AS error_payload;"
      },
      "id": "5",
      "name": "Load Feedback Context",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        720,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst base = $json ?? {};\n\nconst normalizedEvent = { ...(base.normalized_event ?? {}) };\ndelete normalizedEvent.raw_headers;\ndelete normalizedEvent.raw_body;\n\nlet decisionPolicyDoc = null;\ntry {\n  decisionPolicyDoc = JSON.parse(\"__POLICY__DECISION__\");\n} catch (error) {\n  decisionPolicyDoc = null;\n}\n\nconst policyContext = {\n  limits: decisionPolicyDoc?.limits ?? {},\n  taxonomy: decisionPolicyDoc?.taxonomy ?? {},\n  thresholds: decisionPolicyDoc?.thresholds ?? {},\n  defaults: decisionPolicyDoc?.defaults ?? {},\n  rules: decisionPolicyDoc?.rules ?? {},\n  fallbacks: decisionPolicyDoc?.fallbacks ?? {}\n};\n\nconst input = {\n  policy_context: policyContext,\n  feedback: {\n    resolved: base.resolved,\n    smile_score: base.smile_score,\n    comment: base.comment ?? ''\n  },\n  job_result: {\n    status: base.job_status ?? null,\n    result_payload: base.result_payload ?? null,\n    error_payload: base.error_payload ?? null\n  },\n  context: {\n    context_id: base.context_id ?? null,\n    status: base.current_status ?? null,\n    normalized_event: normalizedEvent\n  }\n};\n\nconst promptText = \"__PROMPT__FEEDBACK_DECIDE__\";\nconst promptHash = crypto.createHash('sha256').update(promptText).digest('hex');\n\nreturn [{\n  json: {\n    ...base,\n    policy_context: policyContext,\n    prompt_key: 'adapter.feedback_decide.v1',\n    prompt_version: 'ja-1',\n    prompt_text: promptText,\n    prompt_hash: promptHash,\n    prompt_input: JSON.stringify(input)\n  }\n}];\n"
      },
      "id": "6",
      "name": "Build Feedback Decision Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        440
      ]
    },
	    {
	      "parameters": {
	        "operation": "executeQuery",
	        "query": "INSERT INTO aiops_prompt_history (prompt_key, prompt_version, prompt_text, prompt_hash, source_workflow, source_node)\nVALUES (\n  NULLIF('{{ String($json.prompt_key || \"\").replace(/'/g, \"''\") }}',''),\n  NULLIF('{{ String($json.prompt_version || \"\").replace(/'/g, \"''\") }}',''),\n  NULLIF(( '{{ JSON.stringify($json.prompt_text || \"\").replace(/'/g, \"''\") }}'::jsonb #>> '{}' ), ''),\n  NULLIF('{{ String($json.prompt_hash || \"\").replace(/'/g, \"''\") }}',''),\n  'aiops-adapter-feedback',\n  'OpenAI Feedback Decide'\n)\nON CONFLICT (prompt_key, prompt_hash) DO NOTHING;"
	      },
	      "id": "7",
	      "name": "Record Prompt History (Feedback)",
	      "type": "n8n-nodes-base.postgres",
	      "typeVersion": 2,
	      "position": [
	        1180,
	        440
	      ],
	      "continueOnFail": true
	    },
    {
      "parameters": {
        "resource": "chat",
        "operation": "complete",
        "model": "={{$env.OPENAI_MODEL || 'gpt-4o-mini'}}",
        "prompt": {
          "messages": [
            {
              "role": "system",
              "content": "={{ $node['Build Feedback Decision Prompt (JP)'].json.prompt_text }}"
            },
            {
              "role": "user",
              "content": "={{ '入力:\\n' + $node['Build Feedback Decision Prompt (JP)'].json.prompt_input }}"
            }
          ]
        },
        "options": {
          "temperature": 0.2,
          "baseURL": "={{$env.OPENAI_BASE_URL}}",
          "maxTokens": "={{$json.policy_context?.limits?.llm_output_tokens || 1200}}"
        }
      },
      "id": "8",
      "name": "OpenAI Feedback Decide",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        1400,
        440
      ],
      "credentials": {
        "openAiApi": {
          "name": "aiops-openai"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const base = $node['Build Feedback Decision Prompt (JP)'].json ?? {};\nconst response = $json ?? {};\n\nconst extractContent = (payload) => {\n  return payload?.choices?.[0]?.message?.content\n    ?? payload?.choices?.[0]?.text\n    ?? payload?.data?.choices?.[0]?.message?.content\n    ?? '';\n};\n\nconst rawContent = extractContent(response);\nlet parsed = null;\nif (typeof rawContent === 'string') {\n  try {\n    parsed = JSON.parse(rawContent);\n  } catch (error) {\n    const match = rawContent.match(/\\{[\\s\\S]*\\}/);\n    if (match) {\n      try {\n        parsed = JSON.parse(match[0]);\n      } catch (inner) {\n        parsed = null;\n      }\n    }\n  }\n} else if (rawContent && typeof rawContent === 'object') {\n  parsed = rawContent;\n}\n\nconst isObject = (v) => Boolean(v) && typeof v === 'object' && !Array.isArray(v);\n\nlet ok = isObject(parsed);\nif (ok) {\n  ok = (parsed.case_status === 'closed' || parsed.case_status === 'open')\n    && Array.isArray(parsed.followups)\n    && typeof parsed.confidence === 'number'\n    && typeof parsed.rationale === 'string';\n}\n\nconst policyContext = base.policy_context ?? {};\nconst fallbacks = policyContext?.fallbacks?.feedback_decide ?? {};\n\nconst safeDecision = ok ? parsed : {\n  case_status: fallbacks.case_status ?? 'open',\n  followups: Array.isArray(fallbacks.followups) ? fallbacks.followups : [],\n  confidence: typeof fallbacks.confidence === 'number' ? fallbacks.confidence : 0,\n  rationale: fallbacks.rationale ?? 'モデル出力が無効なため安全側（open）にフォールバック'\n};\n\nreturn [{\n  json: {\n    ...base,\n    llm_feedback_ok: ok,\n    feedback_decision: safeDecision,\n    feedback_decision_raw: typeof rawContent === 'string' ? rawContent : JSON.stringify(rawContent ?? ''),\n    case_status: safeDecision.case_status,\n    followups: safeDecision.followups\n  }\n}];\n"
      },
      "id": "9",
      "name": "Parse Feedback Decision Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1620,
        440
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH ctx AS (\n  SELECT q.context_id\n  FROM aiops_job_queue q\n  WHERE q.job_id = '{{$json.job_id}}'::uuid\n  LIMIT 1\n), ins AS (\n  INSERT INTO aiops_job_feedback (feedback_id, job_id, context_id, actor, resolved, smile_score, comment)\n  SELECT\n    '{{$json.feedback_id}}'::uuid,\n    '{{$json.job_id}}'::uuid,\n    ctx.context_id,\n    '{{ JSON.stringify($json.actor || {}).replace(/'/g, \"''\") }}'::jsonb,\n    {{$json.resolved}},\n    {{$json.smile_score}},\n    NULLIF(('{{ JSON.stringify($json.comment || '').replace(/'/g, \"''\") }}'::jsonb #>> '{}'), '')\n  FROM ctx\n  RETURNING context_id\n), upd AS (\n  UPDATE aiops_context\n  SET\n    normalized_event = normalized_event || jsonb_build_object(\n      'feedback', jsonb_build_object(\n        'job_id', '{{$json.job_id}}'::text,\n        'resolved', {{$json.resolved}},\n        'smile_score', {{$json.smile_score}},\n        'comment', NULLIF(('{{ JSON.stringify($json.comment || '').replace(/'/g, \"''\") }}'::jsonb #>> '{}'), '')\n      ),\n      'feedback_decision', '{{ JSON.stringify($json.feedback_decision || {}).replace(/'/g, \"''\") }}'::jsonb\n    ),\n    status = CASE WHEN '{{$json.case_status}}' = 'closed' THEN 'closed' ELSE COALESCE(status, 'open') END,\n    closed_at = CASE WHEN '{{$json.case_status}}' = 'closed' THEN NOW() ELSE closed_at END\n  WHERE context_id = (SELECT context_id FROM ctx)\n  RETURNING context_id\n)\nSELECT\n  (SELECT context_id FROM ctx) AS context_id,\n  (SELECT COUNT(*) FROM ins) AS inserted,\n  '{{$json.case_status}}' AS case_status;"
      },
      "id": "4",
      "name": "Store Feedback",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        1840,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Webhook (Job Feedback)',\n  target: 'Respond 200',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "10",
      "name": "Debug Log After: Webhook (Job Feedback) -> Respond 200",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Webhook (Job Feedback)',\n  target: 'Respond 200',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "11",
      "name": "Debug Log Before: Respond 200 <- Webhook (Job Feedback)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        340,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Webhook (Job Feedback)',\n  target: 'Parse Feedback',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "12",
      "name": "Debug Log After: Webhook (Job Feedback) -> Parse Feedback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Webhook (Job Feedback)',\n  target: 'Parse Feedback',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "13",
      "name": "Debug Log Before: Parse Feedback <- Webhook (Job Feedback)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        340,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Parse Feedback',\n  target: 'Load Feedback Context',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "14",
      "name": "Debug Log After: Parse Feedback -> Load Feedback Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        620,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Parse Feedback',\n  target: 'Load Feedback Context',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "15",
      "name": "Debug Log Before: Load Feedback Context <- Parse Feedback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        580,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Load Feedback Context',\n  target: 'Build Feedback Decision Prompt (JP)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "16",
      "name": "Debug Log After: Load Feedback Context -> Build Feedback Decision Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        860,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Load Feedback Context',\n  target: 'Build Feedback Decision Prompt (JP)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "17",
      "name": "Debug Log Before: Build Feedback Decision Prompt (JP) <- Load Feedback Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        820,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Feedback Decision Prompt (JP)',\n  target: 'Record Prompt History (Feedback)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "18",
      "name": "Debug Log After: Build Feedback Decision Prompt (JP) -> Record Prompt History (Feedback)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Feedback Decision Prompt (JP)',\n  target: 'Record Prompt History (Feedback)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "19",
      "name": "Debug Log Before: Record Prompt History (Feedback) <- Build Feedback Decision Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Record Prompt History (Feedback)',\n  target: 'OpenAI Feedback Decide',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "20",
      "name": "Debug Log After: Record Prompt History (Feedback) -> OpenAI Feedback Decide",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1320,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Record Prompt History (Feedback)',\n  target: 'OpenAI Feedback Decide',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "21",
      "name": "Debug Log Before: OpenAI Feedback Decide <- Record Prompt History (Feedback)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1260,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'OpenAI Feedback Decide',\n  target: 'Parse Feedback Decision Response',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "22",
      "name": "Debug Log After: OpenAI Feedback Decide -> Parse Feedback Decision Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1540,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'OpenAI Feedback Decide',\n  target: 'Parse Feedback Decision Response',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "23",
      "name": "Debug Log Before: Parse Feedback Decision Response <- OpenAI Feedback Decide",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1480,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Parse Feedback Decision Response',\n  target: 'Store Feedback',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "24",
      "name": "Debug Log After: Parse Feedback Decision Response -> Store Feedback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Parse Feedback Decision Response',\n  target: 'Store Feedback',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "25",
      "name": "Debug Log Before: Store Feedback <- Parse Feedback Decision Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1700,
        440
      ]
    }
  ],
  "connections": {
    "Webhook (Job Feedback)": {
      "main": [
        [
          {
            "node": "Debug Log After: Webhook (Job Feedback) -> Respond 200",
            "type": "main",
            "index": 0
          },
          {
            "node": "Debug Log After: Webhook (Job Feedback) -> Parse Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Feedback": {
      "main": [
        [
          {
            "node": "Debug Log After: Parse Feedback -> Load Feedback Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Feedback Context": {
      "main": [
        [
          {
            "node": "Debug Log After: Load Feedback Context -> Build Feedback Decision Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Feedback Decision Prompt (JP)": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Feedback Decision Prompt (JP) -> Record Prompt History (Feedback)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Record Prompt History (Feedback)": {
      "main": [
        [
          {
            "node": "Debug Log After: Record Prompt History (Feedback) -> OpenAI Feedback Decide",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Feedback Decide": {
      "main": [
        [
          {
            "node": "Debug Log After: OpenAI Feedback Decide -> Parse Feedback Decision Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Feedback Decision Response": {
      "main": [
        [
          {
            "node": "Debug Log After: Parse Feedback Decision Response -> Store Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Webhook (Job Feedback) -> Respond 200": {
      "main": [
        [
          {
            "node": "Debug Log Before: Respond 200 <- Webhook (Job Feedback)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Respond 200 <- Webhook (Job Feedback)": {
      "main": [
        [
          {
            "node": "Respond 200",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Webhook (Job Feedback) -> Parse Feedback": {
      "main": [
        [
          {
            "node": "Debug Log Before: Parse Feedback <- Webhook (Job Feedback)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Parse Feedback <- Webhook (Job Feedback)": {
      "main": [
        [
          {
            "node": "Parse Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Parse Feedback -> Load Feedback Context": {
      "main": [
        [
          {
            "node": "Debug Log Before: Load Feedback Context <- Parse Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Load Feedback Context <- Parse Feedback": {
      "main": [
        [
          {
            "node": "Load Feedback Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Load Feedback Context -> Build Feedback Decision Prompt (JP)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Feedback Decision Prompt (JP) <- Load Feedback Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Feedback Decision Prompt (JP) <- Load Feedback Context": {
      "main": [
        [
          {
            "node": "Build Feedback Decision Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Feedback Decision Prompt (JP) -> Record Prompt History (Feedback)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Record Prompt History (Feedback) <- Build Feedback Decision Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Record Prompt History (Feedback) <- Build Feedback Decision Prompt (JP)": {
      "main": [
        [
          {
            "node": "Record Prompt History (Feedback)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Record Prompt History (Feedback) -> OpenAI Feedback Decide": {
      "main": [
        [
          {
            "node": "Debug Log Before: OpenAI Feedback Decide <- Record Prompt History (Feedback)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: OpenAI Feedback Decide <- Record Prompt History (Feedback)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Parse Feedback Decision Response <- OpenAI Feedback Decide",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: OpenAI Feedback Decide -> Parse Feedback Decision Response": {
      "main": [
        [
          {
            "node": "Debug Log Before: Parse Feedback Decision Response <- OpenAI Feedback Decide",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Parse Feedback Decision Response <- OpenAI Feedback Decide": {
      "main": [
        [
          {
            "node": "Parse Feedback Decision Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Parse Feedback Decision Response -> Store Feedback": {
      "main": [
        [
          {
            "node": "Debug Log Before: Store Feedback <- Parse Feedback Decision Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Store Feedback <- Parse Feedback Decision Response": {
      "main": [
        [
          {
            "node": "Store Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionTimeout": 60
  },
  "versionId": "00000000-0000-0000-0000-000000000000",
  "meta": {
    "aiops": {
      "purpose": "Adapter: job feedback -> store -> close"
    }
  }
}
