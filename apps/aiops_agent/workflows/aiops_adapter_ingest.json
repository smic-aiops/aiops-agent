{
  "name": "aiops-adapter-ingest",
  "nodes": [
    {
      "parameters": {
        "path": "ingest/slack",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "1",
      "name": "Webhook (Slack Ingest)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        240,
        0
      ]
    },
    {
      "parameters": {
        "path": "ingest/zulip",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "2",
      "name": "Webhook (Zulip Ingest)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        240,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const debug = String($env.N8N_INGEST_DEBUG_LOG ?? 'true').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debug);\n\nfunction redactSecretsInText(raw) {\n  const text = String(raw ?? '');\n  if (!text) return text;\n  let out = text;\n  out = out.replace(/\\bxox[baprs]-[A-Za-z0-9-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bglpat-[A-Za-z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bghp_[A-Za-z0-9]{20,}\\b/g, '(masked)');\n  out = out.replace(/\\bAKIA[0-9A-Z]{16}\\b/g, '(masked)');\n  out = out.replace(/\\beyJ[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bBearer\\s+[A-Za-z0-9._-]{20,}\\b/gi, 'Bearer (masked)');\n  out = out.replace(/([?&](?:token|access_token|id_token|refresh_token|api_key|apikey|secret|password)=)([^&\\s]+)/gi, (m, p1) => `${p1}(masked)`);\n  return out;\n}\n\nfunction scrub(value, depth = 0) {\n  if (depth > 6) return '[max-depth]';\n  if (value === null || value === undefined) return value;\n  if (typeof value === 'string') return redactSecretsInText(value);\n  if (Array.isArray(value)) return value.map((v) => scrub(v, depth + 1));\n  if (typeof value === 'object') {\n    const result = {};\n    for (const [k, v] of Object.entries(value)) {\n      const keyLower = String(k).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[k] = '***';\n      } else {\n        result[k] = scrub(v, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nif (enabled) {\n  const request = $json ?? {};\n  const headers = (request && typeof request === 'object' && request.headers && typeof request.headers === 'object')\n    ? request.headers\n    : {};\n\n  const safe = scrub(JSON.parse(JSON.stringify(request.body ?? request)));\n\n  const path = headers['x-forwarded-uri'] || headers['x-original-uri'] || headers['x-forwarded-path'] || headers['x-amzn-trace-id'] || '';\n  const line = JSON.stringify({ tag: 'aiops_ingest_zulip', path, payload: safe });\n\n  try {\n    if (this?.logger?.error) {\n      this.logger.error(line);\n    } else {\n      console.error(line);\n    }\n  } catch (error) {\n    console.error(line);\n  }\n}\n\nreturn $input.all();\n"
      },
      "id": "9000",
      "name": "Debug Log (Zulip Payload)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        280
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ !!$env.N8N_SULU_MONITORING_WEBHOOK_URL }}",
              "value2": true,
              "operation": "equal"
            }
          ]
        }
      },
      "id": "9001",
      "name": "IF Sulu Monitoring Enabled",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        680,
        280
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "function redactSecretsInText(raw) {\n  const text = String(raw ?? '');\n  if (!text) return text;\n  let out = text;\n  out = out.replace(/\\bxox[baprs]-[A-Za-z0-9-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bglpat-[A-Za-z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bghp_[A-Za-z0-9]{20,}\\b/g, '(masked)');\n  out = out.replace(/\\bAKIA[0-9A-Z]{16}\\b/g, '(masked)');\n  out = out.replace(/\\beyJ[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bBearer\\s+[A-Za-z0-9._-]{20,}\\b/gi, 'Bearer (masked)');\n  out = out.replace(/([?&](?:token|access_token|id_token|refresh_token|api_key|apikey|secret|password)=)([^&\\s]+)/gi, (m, p1) => `${p1}(masked)`);\n  return out;\n}\n\nfunction scrub(value, depth = 0) {\n  if (depth > 6) return '[max-depth]';\n  if (value === null || value === undefined) return value;\n  if (typeof value === 'string') return redactSecretsInText(value);\n  if (Array.isArray(value)) return value.map((v) => scrub(v, depth + 1));\n  if (typeof value === 'object') {\n    const result = {};\n    for (const [k, v] of Object.entries(value)) {\n      const keyLower = String(k).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[k] = '***';\n      } else {\n        result[k] = scrub(v, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nfunction build(aiNodeName) {\n  const items = $input.all();\n  const now = new Date().toISOString();\n  return items.map((item) => {\n    const j = item.json ?? {};\n    const traceId = j.trace_id ?? j.traceId ?? j.normalized_event?.trace_id ?? j.normalized_event?.traceId ?? null;\n    const contextId = j.context_id ?? j.contextId ?? j.normalized_event?.context_id ?? null;\n    let safe = null;\n    try {\n      safe = scrub(JSON.parse(JSON.stringify(j)));\n    } catch (error) {\n      safe = scrub(j);\n    }\n    return {\n      json: {\n        kind: 'aiops.sulu_log',\n        phase: 'after',\n        ai_node: aiNodeName,\n        sent_at: now,\n        trace_id: traceId,\n        context_id: contextId,\n        payload: safe\n      }\n    };\n  });\n}\n\n// Note: duplicated per OpenAI node to include ai_node name.\nreturn build('OpenAI Classify Event');\n"
      },
      "id": "sulu-after-openai-classify-event",
      "name": "Build Sulu Monitoring Payload (After: OpenAI Classify Event)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        120
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "function redactSecretsInText(raw) {\n  const text = String(raw ?? '');\n  if (!text) return text;\n  let out = text;\n  out = out.replace(/\\bxox[baprs]-[A-Za-z0-9-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bglpat-[A-Za-z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bghp_[A-Za-z0-9]{20,}\\b/g, '(masked)');\n  out = out.replace(/\\bAKIA[0-9A-Z]{16}\\b/g, '(masked)');\n  out = out.replace(/\\beyJ[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bBearer\\s+[A-Za-z0-9._-]{20,}\\b/gi, 'Bearer (masked)');\n  out = out.replace(/([?&](?:token|access_token|id_token|refresh_token|api_key|apikey|secret|password)=)([^&\\s]+)/gi, (m, p1) => `${p1}(masked)`);\n  return out;\n}\n\nfunction scrub(value, depth = 0) {\n  if (depth > 6) return '[max-depth]';\n  if (value === null || value === undefined) return value;\n  if (typeof value === 'string') return redactSecretsInText(value);\n  if (Array.isArray(value)) return value.map((v) => scrub(v, depth + 1));\n  if (typeof value === 'object') {\n    const result = {};\n    for (const [k, v] of Object.entries(value)) {\n      const keyLower = String(k).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[k] = '***';\n      } else {\n        result[k] = scrub(v, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst items = $input.all();\nconst now = new Date().toISOString();\n\nreturn items.map((item) => {\n  const j = item.json ?? {};\n  const traceId = j.trace_id ?? j.traceId ?? j.normalized_event?.trace_id ?? j.normalized_event?.traceId ?? null;\n  const contextId = j.context_id ?? j.contextId ?? j.normalized_event?.context_id ?? null;\n  let safe = null;\n  try {\n    safe = scrub(JSON.parse(JSON.stringify(j)));\n  } catch (error) {\n    safe = scrub(j);\n  }\n  return {\n    json: {\n      kind: 'aiops.sulu_log',\n      phase: 'after',\n      ai_node: 'OpenAI Context Summary',\n      sent_at: now,\n      trace_id: traceId,\n      context_id: contextId,\n      payload: safe\n    }\n  };\n});\n"
      },
      "id": "sulu-after-openai-context-summary",
      "name": "Build Sulu Monitoring Payload (After: OpenAI Context Summary)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        160
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "function redactSecretsInText(raw) {\n  const text = String(raw ?? '');\n  if (!text) return text;\n  let out = text;\n  out = out.replace(/\\bxox[baprs]-[A-Za-z0-9-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bglpat-[A-Za-z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bghp_[A-Za-z0-9]{20,}\\b/g, '(masked)');\n  out = out.replace(/\\bAKIA[0-9A-Z]{16}\\b/g, '(masked)');\n  out = out.replace(/\\beyJ[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bBearer\\s+[A-Za-z0-9._-]{20,}\\b/gi, 'Bearer (masked)');\n  out = out.replace(/([?&](?:token|access_token|id_token|refresh_token|api_key|apikey|secret|password)=)([^&\\s]+)/gi, (m, p1) => `${p1}(masked)`);\n  return out;\n}\n\nfunction scrub(value, depth = 0) {\n  if (depth > 6) return '[max-depth]';\n  if (value === null || value === undefined) return value;\n  if (typeof value === 'string') return redactSecretsInText(value);\n  if (Array.isArray(value)) return value.map((v) => scrub(v, depth + 1));\n  if (typeof value === 'object') {\n    const result = {};\n    for (const [k, v] of Object.entries(value)) {\n      const keyLower = String(k).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[k] = '***';\n      } else {\n        result[k] = scrub(v, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst items = $input.all();\nconst now = new Date().toISOString();\n\nreturn items.map((item) => {\n  const j = item.json ?? {};\n  const traceId = j.trace_id ?? j.traceId ?? j.normalized_event?.trace_id ?? j.normalized_event?.traceId ?? null;\n  const contextId = j.context_id ?? j.contextId ?? j.normalized_event?.context_id ?? null;\n  let safe = null;\n  try {\n    safe = scrub(JSON.parse(JSON.stringify(j)));\n  } catch (error) {\n    safe = scrub(j);\n  }\n  return {\n    json: {\n      kind: 'aiops.sulu_log',\n      phase: 'after',\n      ai_node: 'OpenAI Routing Decide',\n      sent_at: now,\n      trace_id: traceId,\n      context_id: contextId,\n      payload: safe\n    }\n  };\n});\n"
      },
      "id": "sulu-after-openai-routing-decide",
      "name": "Build Sulu Monitoring Payload (After: OpenAI Routing Decide)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        200
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "function redactSecretsInText(raw) {\n  const text = String(raw ?? '');\n  if (!text) return text;\n  let out = text;\n  out = out.replace(/\\bxox[baprs]-[A-Za-z0-9-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bglpat-[A-Za-z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bghp_[A-Za-z0-9]{20,}\\b/g, '(masked)');\n  out = out.replace(/\\bAKIA[0-9A-Z]{16}\\b/g, '(masked)');\n  out = out.replace(/\\beyJ[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bBearer\\s+[A-Za-z0-9._-]{20,}\\b/gi, 'Bearer (masked)');\n  out = out.replace(/([?&](?:token|access_token|id_token|refresh_token|api_key|apikey|secret|password)=)([^&\\s]+)/gi, (m, p1) => `${p1}(masked)`);\n  return out;\n}\n\nfunction scrub(value, depth = 0) {\n  if (depth > 6) return '[max-depth]';\n  if (value === null || value === undefined) return value;\n  if (typeof value === 'string') return redactSecretsInText(value);\n  if (Array.isArray(value)) return value.map((v) => scrub(v, depth + 1));\n  if (typeof value === 'object') {\n    const result = {};\n    for (const [k, v] of Object.entries(value)) {\n      const keyLower = String(k).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[k] = '***';\n      } else {\n        result[k] = scrub(v, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst items = $input.all();\nconst now = new Date().toISOString();\n\nreturn items.map((item) => {\n  const j = item.json ?? {};\n  const traceId = j.trace_id ?? j.traceId ?? j.normalized_event?.trace_id ?? j.normalized_event?.traceId ?? null;\n  const contextId = j.context_id ?? j.contextId ?? j.normalized_event?.context_id ?? null;\n  let safe = null;\n  try {\n    safe = scrub(JSON.parse(JSON.stringify(j)));\n  } catch (error) {\n    safe = scrub(j);\n  }\n  return {\n    json: {\n      kind: 'aiops.sulu_log',\n      phase: 'after',\n      ai_node: 'OpenAI Chat Core',\n      sent_at: now,\n      trace_id: traceId,\n      context_id: contextId,\n      payload: safe\n    }\n  };\n});\n"
      },
      "id": "sulu-after-openai-chat-core",
      "name": "Build Sulu Monitoring Payload (After: OpenAI Chat Core)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        240
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "function redactSecretsInText(raw) {\n  const text = String(raw ?? '');\n  if (!text) return text;\n  let out = text;\n  out = out.replace(/\\bxox[baprs]-[A-Za-z0-9-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bglpat-[A-Za-z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bghp_[A-Za-z0-9]{20,}\\b/g, '(masked)');\n  out = out.replace(/\\bAKIA[0-9A-Z]{16}\\b/g, '(masked)');\n  out = out.replace(/\\beyJ[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bBearer\\s+[A-Za-z0-9._-]{20,}\\b/gi, 'Bearer (masked)');\n  out = out.replace(/([?&](?:token|access_token|id_token|refresh_token|api_key|apikey|secret|password)=)([^&\\s]+)/gi, (m, p1) => `${p1}(masked)`);\n  return out;\n}\n\nfunction scrub(value, depth = 0) {\n  if (depth > 6) return '[max-depth]';\n  if (value === null || value === undefined) return value;\n  if (typeof value === 'string') return redactSecretsInText(value);\n  if (Array.isArray(value)) return value.map((v) => scrub(v, depth + 1));\n  if (typeof value === 'object') {\n    const result = {};\n    for (const [k, v] of Object.entries(value)) {\n      const keyLower = String(k).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[k] = '***';\n      } else {\n        result[k] = scrub(v, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst items = $input.all();\nconst now = new Date().toISOString();\n\nreturn items.map((item) => {\n  const j = item.json ?? {};\n  const traceId = j.trace_id ?? j.traceId ?? j.normalized_event?.trace_id ?? j.normalized_event?.traceId ?? null;\n  const contextId = j.context_id ?? j.contextId ?? j.normalized_event?.context_id ?? null;\n  let safe = null;\n  try {\n    safe = scrub(JSON.parse(JSON.stringify(j)));\n  } catch (error) {\n    safe = scrub(j);\n  }\n  return {\n    json: {\n      kind: 'aiops.sulu_log',\n      phase: 'after',\n      ai_node: 'OpenAI Initial Reply',\n      sent_at: now,\n      trace_id: traceId,\n      context_id: contextId,\n      payload: safe\n    }\n  };\n});\n"
      },
      "id": "sulu-after-openai-initial-reply",
      "name": "Build Sulu Monitoring Payload (After: OpenAI Initial Reply)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        280
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "function redactSecretsInText(raw) {\n  const text = String(raw ?? '');\n  if (!text) return text;\n  let out = text;\n  out = out.replace(/\\bxox[baprs]-[A-Za-z0-9-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bglpat-[A-Za-z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bghp_[A-Za-z0-9]{20,}\\b/g, '(masked)');\n  out = out.replace(/\\bAKIA[0-9A-Z]{16}\\b/g, '(masked)');\n  out = out.replace(/\\beyJ[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bBearer\\s+[A-Za-z0-9._-]{20,}\\b/gi, 'Bearer (masked)');\n  out = out.replace(/([?&](?:token|access_token|id_token|refresh_token|api_key|apikey|secret|password)=)([^&\\s]+)/gi, (m, p1) => `${p1}(masked)`);\n  return out;\n}\n\nfunction scrub(value, depth = 0) {\n  if (depth > 6) return '[max-depth]';\n  if (value === null || value === undefined) return value;\n  if (typeof value === 'string') return redactSecretsInText(value);\n  if (Array.isArray(value)) return value.map((v) => scrub(v, depth + 1));\n  if (typeof value === 'object') {\n    const result = {};\n    for (const [k, v] of Object.entries(value)) {\n      const keyLower = String(k).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[k] = '***';\n      } else {\n        result[k] = scrub(v, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst items = $input.all();\nconst now = new Date().toISOString();\n\nreturn items.map((item) => {\n  const j = item.json ?? {};\n  const traceId = j.trace_id ?? j.traceId ?? j.normalized_event?.trace_id ?? j.normalized_event?.traceId ?? null;\n  const contextId = j.context_id ?? j.contextId ?? j.normalized_event?.context_id ?? null;\n  let safe = null;\n  try {\n    safe = scrub(JSON.parse(JSON.stringify(j)));\n  } catch (error) {\n    safe = scrub(j);\n  }\n  return {\n    json: {\n      kind: 'aiops.sulu_log',\n      phase: 'after',\n      ai_node: 'OpenAI Feedback Decide (Ingest)',\n      sent_at: now,\n      trace_id: traceId,\n      context_id: contextId,\n      payload: safe\n    }\n  };\n});\n"
      },
      "id": "sulu-after-openai-feedback-decide-ingest",
      "name": "Build Sulu Monitoring Payload (After: OpenAI Feedback Decide (Ingest))",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        320
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "function redactSecretsInText(raw) {\n  const text = String(raw ?? '');\n  if (!text) return text;\n  let out = text;\n  out = out.replace(/\\bxox[baprs]-[A-Za-z0-9-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bglpat-[A-Za-z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bghp_[A-Za-z0-9]{20,}\\b/g, '(masked)');\n  out = out.replace(/\\bAKIA[0-9A-Z]{16}\\b/g, '(masked)');\n  out = out.replace(/\\beyJ[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bBearer\\s+[A-Za-z0-9._-]{20,}\\b/gi, 'Bearer (masked)');\n  out = out.replace(/([?&](?:token|access_token|id_token|refresh_token|api_key|apikey|secret|password)=)([^&\\s]+)/gi, (m, p1) => `${p1}(masked)`);\n  return out;\n}\n\nfunction scrub(value, depth = 0) {\n  if (depth > 6) return '[max-depth]';\n  if (value === null || value === undefined) return value;\n  if (typeof value === 'string') return redactSecretsInText(value);\n  if (Array.isArray(value)) return value.map((v) => scrub(v, depth + 1));\n  if (typeof value === 'object') {\n    const result = {};\n    for (const [k, v] of Object.entries(value)) {\n      const keyLower = String(k).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[k] = '***';\n      } else {\n        result[k] = scrub(v, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst items = $input.all();\nconst now = new Date().toISOString();\n\nreturn items.map((item) => {\n  const j = item.json ?? {};\n  const traceId = j.trace_id ?? j.traceId ?? j.normalized_event?.trace_id ?? j.normalized_event?.traceId ?? null;\n  const contextId = j.context_id ?? j.contextId ?? j.normalized_event?.context_id ?? null;\n  let safe = null;\n  try {\n    safe = scrub(JSON.parse(JSON.stringify(j)));\n  } catch (error) {\n    safe = scrub(j);\n  }\n  return {\n    json: {\n      kind: 'aiops.sulu_log',\n      phase: 'after',\n      ai_node: 'OpenAI Enrichment Plan',\n      sent_at: now,\n      trace_id: traceId,\n      context_id: contextId,\n      payload: safe\n    }\n  };\n});\n"
      },
      "id": "sulu-after-openai-enrichment-plan",
      "name": "Build Sulu Monitoring Payload (After: OpenAI Enrichment Plan)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        360
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "function redactSecretsInText(raw) {\n  const text = String(raw ?? '');\n  if (!text) return text;\n  let out = text;\n  out = out.replace(/\\bxox[baprs]-[A-Za-z0-9-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bglpat-[A-Za-z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bghp_[A-Za-z0-9]{20,}\\b/g, '(masked)');\n  out = out.replace(/\\bAKIA[0-9A-Z]{16}\\b/g, '(masked)');\n  out = out.replace(/\\beyJ[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\b/g, '(masked)');\n  out = out.replace(/\\bBearer\\s+[A-Za-z0-9._-]{20,}\\b/gi, 'Bearer (masked)');\n  out = out.replace(/([?&](?:token|access_token|id_token|refresh_token|api_key|apikey|secret|password)=)([^&\\s]+)/gi, (m, p1) => `${p1}(masked)`);\n  return out;\n}\n\nfunction scrub(value, depth = 0) {\n  if (depth > 6) return '[max-depth]';\n  if (value === null || value === undefined) return value;\n  if (typeof value === 'string') return redactSecretsInText(value);\n  if (Array.isArray(value)) return value.map((v) => scrub(v, depth + 1));\n  if (typeof value === 'object') {\n    const result = {};\n    for (const [k, v] of Object.entries(value)) {\n      const keyLower = String(k).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[k] = '***';\n      } else {\n        result[k] = scrub(v, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst items = $input.all();\nconst now = new Date().toISOString();\n\nreturn items.map((item) => {\n  const j = item.json ?? {};\n  const traceId = j.trace_id ?? j.traceId ?? j.normalized_event?.trace_id ?? j.normalized_event?.traceId ?? null;\n  const contextId = j.context_id ?? j.contextId ?? j.normalized_event?.context_id ?? null;\n  let safe = null;\n  try {\n    safe = scrub(JSON.parse(JSON.stringify(j)));\n  } catch (error) {\n    safe = scrub(j);\n  }\n  return {\n    json: {\n      kind: 'aiops.sulu_log',\n      phase: 'after',\n      ai_node: 'OpenAI Enrichment Summary',\n      sent_at: now,\n      trace_id: traceId,\n      context_id: contextId,\n      payload: safe\n    }\n  };\n});\n"
      },
      "id": "sulu-after-openai-enrichment-summary",
      "name": "Build Sulu Monitoring Payload (After: OpenAI Enrichment Summary)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        400
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.N8N_SULU_MONITORING_WEBHOOK_URL }}",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {
          "timeout": 5000
        }
      },
      "id": "9003",
      "name": "Post to Sulu Monitoring",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1120,
        280
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "path": "ingest/mattermost",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "3",
      "name": "Webhook (Mattermost Ingest)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        240,
        440
      ]
    },
    {
      "parameters": {
        "path": "ingest/teams",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "4",
      "name": "Webhook (Teams Ingest)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        240,
        660
      ]
    },
    {
      "parameters": {
        "path": "ingest/cloudwatch",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "5",
      "name": "Webhook (CloudWatch Ingest)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        240,
        880
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst body = $json ?? {};\nconst headers = $headers ?? {};\n\nfunction getHeader(name) {\n  const lower = name.toLowerCase();\n  if (headers[lower] !== undefined) return headers[lower];\n  if (headers[name] !== undefined) return headers[name];\n  const key = Object.keys(headers).find((k) => k.toLowerCase() === lower);\n  return key ? headers[key] : undefined;\n}\n\nfunction error(status, message) {\n  return [{ json: { valid: '', status_code: status, error: message } }];\n}\n\nlet ingestPolicyDoc = null;\ntry {\n  ingestPolicyDoc = JSON.parse(\"__POLICY__INGEST__\");\n} catch (error) {\n  ingestPolicyDoc = null;\n}\n\nconst workflowContext = this;\n\nfunction toNumber(value) {\n  const parsed = Number(value);\n  if (!Number.isFinite(parsed)) return null;\n  return parsed;\n}\n\nfunction readEnvNumber(name) {\n  const raw = $env?.[name];\n  if (raw === undefined || raw === null || raw === '') return null;\n  return toNumber(raw);\n}\n\nfunction resolvePayloadLimitBytes() {\n  const payloadPolicy = ingestPolicyDoc?.payload_limits ?? {};\n  return (\n    readEnvNumber('N8N_INGEST_PAYLOAD_MAX_BYTES')\n    ?? readEnvNumber('N8N_INGEST_MAX_BYTES')\n    ?? toNumber(payloadPolicy.ingest_payload_max_bytes)\n    ?? toNumber(payloadPolicy.ingest_max_bytes)\n    ?? null\n  );\n}\n\nfunction resolvePayloadRejectStatus() {\n  const payloadPolicy = ingestPolicyDoc?.payload_limits ?? {};\n  const status = toNumber(payloadPolicy.reject_status);\n  return status && status >= 400 ? status : 413;\n}\n\nfunction getPayloadBytes() {\n  const raw = body.rawBody ?? body.raw_body ?? null;\n  if (typeof raw === 'string') return Buffer.byteLength(raw, 'utf8');\n  if (raw && typeof raw === 'object') {\n    try {\n      return Buffer.byteLength(JSON.stringify(raw), 'utf8');\n    } catch (error) {}\n  }\n  const headerLen = toNumber(getHeader('content-length'));\n  if (headerLen && headerLen > 0) return headerLen;\n  try {\n    return Buffer.byteLength(JSON.stringify(body ?? {}), 'utf8');\n  } catch (error) {\n    return 0;\n  }\n}\n\nfunction checkPayloadLimit() {\n  const limit = resolvePayloadLimitBytes();\n  if (!limit || limit <= 0) return null;\n  const bytes = getPayloadBytes();\n  if (bytes > limit) {\n    return error(resolvePayloadRejectStatus(), `payload too large (${bytes} bytes)`);\n  }\n  return null;\n}\n\nfunction resolveTenantFromBody(payload) {\n  if (!payload || typeof payload !== 'object') return null;\n  return (\n    payload.tenant ||\n    payload.realm ||\n    payload.team_id ||\n    payload.team?.id ||\n    null\n  );\n}\n\nfunction resolveRateLimitConfig(source) {\n  const ratePolicy = ingestPolicyDoc?.rate_limit ?? {};\n  const sourceKey = String(source || '').trim().toUpperCase();\n  const envSourceLimit = sourceKey\n    ? readEnvNumber(`N8N_INGEST_RATE_LIMIT_RPS_${sourceKey}`)\n    : null;\n  const envSourceBurst = sourceKey\n    ? readEnvNumber(`N8N_INGEST_BURST_RPS_${sourceKey}`)\n    : null;\n  const perSourceLimit = ratePolicy?.per_source_rps?.[source] ?? ratePolicy?.per_source_qps?.[source] ?? null;\n  const limit = envSourceLimit\n    ?? readEnvNumber('N8N_INGEST_RATE_LIMIT_RPS')\n    ?? toNumber(perSourceLimit)\n    ?? toNumber(ratePolicy.ingest_rate_limit_rps)\n    ?? toNumber(ratePolicy.default_rps)\n    ?? toNumber(ratePolicy.default_qps)\n    ?? null;\n  const burst = envSourceBurst\n    ?? readEnvNumber('N8N_INGEST_BURST_RPS')\n    ?? toNumber(ratePolicy.burst_rps)\n    ?? toNumber(ratePolicy.default_burst_rps)\n    ?? toNumber(ratePolicy.default_burst_qps)\n    ?? null;\n  const tenantLimit = readEnvNumber('N8N_TENANT_RATE_LIMIT_RPS')\n    ?? toNumber(ratePolicy.tenant_rate_limit_rps)\n    ?? null;\n  return { limit, burst, tenantLimit };\n}\n\nfunction checkRateLimit(source, tenant) {\n  const { limit, burst, tenantLimit } = resolveRateLimitConfig(source);\n  const maxPerSource = limit && limit > 0 ? (burst && burst > limit ? burst : limit) : null;\n  const maxPerTenant = tenantLimit && tenantLimit > 0 ? tenantLimit : null;\n  if (!maxPerSource && !maxPerTenant) return null;\n\n  let staticData = null;\n  try {\n    staticData = workflowContext.getWorkflowStaticData('global');\n  } catch (error) {\n    staticData = null;\n  }\n  const state = staticData ? (staticData.rate_limit_state ?? (staticData.rate_limit_state = {})) : {};\n  const now = Math.floor(Date.now() / 1000);\n\n  function bump(key, maxAllowed) {\n    if (!maxAllowed) return false;\n    const entry = state[key] ?? { window: now, count: 0 };\n    if (entry.window !== now) {\n      entry.window = now;\n      entry.count = 0;\n    }\n    entry.count += 1;\n    state[key] = entry;\n    return entry.count > maxAllowed;\n  }\n\n  const sourceKey = `source:${source}`;\n  if (bump(sourceKey, maxPerSource)) return error(429, 'rate limit exceeded');\n  if (tenant) {\n    const tenantKey = `tenant:${tenant}`;\n    if (bump(tenantKey, maxPerTenant)) return error(429, 'tenant rate limit exceeded');\n  }\n  return null;\n}\n\nfunction getByPath(obj, path) {\n  if (!obj || typeof obj !== 'object') return undefined;\n  const parts = String(path).split('.').filter(Boolean);\n  let cur = obj;\n  for (const part of parts) {\n    if (cur === null || cur === undefined) return undefined;\n    cur = cur?.[part];\n  }\n  return cur;\n}\n\nfunction pickFirst(obj, paths, fallback) {\n  const candidates = Array.isArray(paths) ? paths : null;\n  const list = (candidates && candidates.length > 0)\n    ? candidates\n    : (Array.isArray(fallback) ? fallback : []);\n  for (const p of list) {\n    const v = getByPath(obj, p);\n    if (v !== undefined && v !== null && String(v).trim() !== '') return v;\n  }\n  return null;\n}\n\nfunction applyTemplate(template, vars) {\n  const raw = template ?? '{source}:{event_id}';\n  return String(raw)\n    .split('{source}').join(String(vars.source ?? 'unknown'))\n    .split('{event_id}').join(String(vars.event_id ?? ''));\n}\n\nconst source = 'slack';\nconst payloadCheck = checkPayloadLimit();\nif (payloadCheck) return payloadCheck;\nconst rateCheck = checkRateLimit(source, resolveTenantFromBody(body));\nif (rateCheck) return rateCheck;\nconst sourcePolicy = ingestPolicyDoc?.sources?.[source] ?? null;\nconst eventId = pickFirst(body, sourcePolicy?.event_id_paths, ['event_id', 'id']);\nif (!eventId) return error(400, 'event_id は必須です');\n\nconst keyTemplate = sourcePolicy?.dedupe_key_template\n  ?? ingestPolicyDoc?.dedupe?.default_key_template\n  ?? '{source}:{event_id}';\nconst maxLen = ingestPolicyDoc?.dedupe?.max_key_length ?? 256;\nlet dedupeKey = applyTemplate(keyTemplate, { source, event_id: String(eventId) });\nif (dedupeKey.length > maxLen) dedupeKey = dedupeKey.slice(0, maxLen);\n\n\nconst timestamp = getHeader('x-slack-request-timestamp');\nconst signature = getHeader('x-slack-signature');\n\nif (!timestamp || !signature) {\n  return error(401, 'Slack 署名ヘッダが不足しています');\n}\n\nconst secret = $env.N8N_SLACK_SIGNING_SECRET;\nif (!secret) return error(500, 'N8N_SLACK_SIGNING_SECRET が未設定です');\n\nfunction sortKeysDeep(value) {\n  if (Array.isArray(value)) return value.map(sortKeysDeep);\n  if (value && typeof value === 'object') {\n    return Object.keys(value)\n      .sort()\n      .reduce((acc, key) => {\n        acc[key] = sortKeysDeep(value[key]);\n        return acc;\n      }, {});\n  }\n  return value;\n}\n\nfunction stableStringify(value) {\n  return JSON.stringify(sortKeysDeep(value));\n}\n\nconst rawBody = body.rawBody ?? body.raw_body ?? null;\nconst signaturePayload = typeof rawBody === 'string'\n  ? rawBody\n  : rawBody && typeof rawBody === 'object'\n    ? JSON.stringify(rawBody)\n    : stableStringify(body);\nconst base = `v0:${timestamp}:${signaturePayload}`;\nconst expected = 'v0=' + crypto.createHmac('sha256', secret).update(base).digest('hex');\nif (signature !== expected) return error(401, 'Slack 署名が不正です');\n\nconst event = body.event || {};\nconst traceId = getHeader('x-aiops-trace-id') || crypto.randomUUID();\n\nconst normalizedEvent = {\n  source: 'slack',\n  event_id: String(eventId),\n  received_at: new Date().toISOString(),\n  text: event.text ?? '',\n  trace_id: traceId,\n  raw_headers: headers,\n  raw_body: body\n};\n\nconst actor = {\n  source: 'slack',\n  user_id: event.user ?? null,\n  team_id: body.team_id ?? null\n};\n\nconst replyTarget = {\n  source: 'slack',\n  channel: event.channel ?? null,\n  thread_ts: event.thread_ts ?? null,\n  ts: event.ts ?? null\n};\n\nconst contextId = crypto.randomUUID();\n\nreturn [{\n  json: {\n    valid: true,\n    source: 'slack',\n    trace_id: traceId,\n    context_id: contextId,\n    dedupe_key: dedupeKey,\n    actor,\n    reply_target: replyTarget,\n    normalized_event: normalizedEvent\n  }\n}];\n\n"
      },
      "id": "6",
      "name": "Validate Slack",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        0
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.valid}}",
              "value2": "true",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "7",
      "name": "IF Slack Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        680,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst request = $json ?? {};\nconst headers = (request && typeof request === 'object' && request.headers && typeof request.headers === 'object')\n  ? request.headers\n  : {};\nconst body = (request && typeof request === 'object' && request.body !== undefined)\n  ? (request.body ?? {})\n  : request;\nconst params = (request && typeof request === 'object')\n  ? (request.params ?? request.pathParameters ?? request.path_parameters ?? body.params ?? body.pathParameters ?? body.path_parameters ?? {})\n  : (body.params ?? body.pathParameters ?? body.path_parameters ?? {});\n\nfunction getHeader(name) {\n  const lower = name.toLowerCase();\n  if (headers[lower] !== undefined) return headers[lower];\n  if (headers[name] !== undefined) return headers[name];\n  const key = Object.keys(headers).find((k) => k.toLowerCase() === lower);\n  return key ? headers[key] : undefined;\n}\n\nfunction error(status, message) {\n  return [{ json: { valid: '', status_code: status, error: message } }];\n}\n\nlet ingestPolicyDoc = null;\ntry {\n  ingestPolicyDoc = JSON.parse(\"__POLICY__INGEST__\");\n} catch (error) {\n  ingestPolicyDoc = null;\n}\n\nconst workflowContext = this;\n\nfunction toNumber(value) {\n  const parsed = Number(value);\n  if (!Number.isFinite(parsed)) return null;\n  return parsed;\n}\n\nfunction readEnvNumber(name) {\n  const raw = $env?.[name];\n  if (raw === undefined || raw === null || raw === '') return null;\n  return toNumber(raw);\n}\n\nfunction resolvePayloadLimitBytes() {\n  const payloadPolicy = ingestPolicyDoc?.payload_limits ?? {};\n  return (\n    readEnvNumber('N8N_INGEST_PAYLOAD_MAX_BYTES')\n    ?? readEnvNumber('N8N_INGEST_MAX_BYTES')\n    ?? toNumber(payloadPolicy.ingest_payload_max_bytes)\n    ?? toNumber(payloadPolicy.ingest_max_bytes)\n    ?? null\n  );\n}\n\nfunction resolvePayloadRejectStatus() {\n  const payloadPolicy = ingestPolicyDoc?.payload_limits ?? {};\n  const status = toNumber(payloadPolicy.reject_status);\n  return status && status >= 400 ? status : 413;\n}\n\nfunction getPayloadBytes() {\n  const raw = body.rawBody ?? body.raw_body ?? null;\n  if (typeof raw === 'string') return Buffer.byteLength(raw, 'utf8');\n  if (raw && typeof raw === 'object') {\n    try {\n      return Buffer.byteLength(JSON.stringify(raw), 'utf8');\n    } catch (error) {}\n  }\n  const headerLen = toNumber(getHeader('content-length'));\n  if (headerLen && headerLen > 0) return headerLen;\n  try {\n    return Buffer.byteLength(JSON.stringify(body ?? {}), 'utf8');\n  } catch (error) {\n    return 0;\n  }\n}\n\nfunction checkPayloadLimit() {\n  const limit = resolvePayloadLimitBytes();\n  if (!limit || limit <= 0) return null;\n  const bytes = getPayloadBytes();\n  if (bytes > limit) {\n    return error(resolvePayloadRejectStatus(), `payload too large (${bytes} bytes)`);\n  }\n  return null;\n}\n\nfunction resolveTenantFromBody(payload) {\n  if (!payload || typeof payload !== 'object') return null;\n  return (\n    payload.tenant ||\n    payload.realm ||\n    payload.team_id ||\n    payload.team?.id ||\n    null\n  );\n}\n\nfunction resolveRateLimitConfig(source) {\n  const ratePolicy = ingestPolicyDoc?.rate_limit ?? {};\n  const sourceKey = String(source || '').trim().toUpperCase();\n  const envSourceLimit = sourceKey\n    ? readEnvNumber(`N8N_INGEST_RATE_LIMIT_RPS_${sourceKey}`)\n    : null;\n  const envSourceBurst = sourceKey\n    ? readEnvNumber(`N8N_INGEST_BURST_RPS_${sourceKey}`)\n    : null;\n  const perSourceLimit = ratePolicy?.per_source_rps?.[source] ?? ratePolicy?.per_source_qps?.[source] ?? null;\n  const limit = envSourceLimit\n    ?? readEnvNumber('N8N_INGEST_RATE_LIMIT_RPS')\n    ?? toNumber(perSourceLimit)\n    ?? toNumber(ratePolicy.ingest_rate_limit_rps)\n    ?? toNumber(ratePolicy.default_rps)\n    ?? toNumber(ratePolicy.default_qps)\n    ?? null;\n  const burst = envSourceBurst\n    ?? readEnvNumber('N8N_INGEST_BURST_RPS')\n    ?? toNumber(ratePolicy.burst_rps)\n    ?? toNumber(ratePolicy.default_burst_rps)\n    ?? toNumber(ratePolicy.default_burst_qps)\n    ?? null;\n  const tenantLimit = readEnvNumber('N8N_TENANT_RATE_LIMIT_RPS')\n    ?? toNumber(ratePolicy.tenant_rate_limit_rps)\n    ?? null;\n  return { limit, burst, tenantLimit };\n}\n\nfunction checkRateLimit(source, tenant) {\n  const { limit, burst, tenantLimit } = resolveRateLimitConfig(source);\n  const maxPerSource = limit && limit > 0 ? (burst && burst > limit ? burst : limit) : null;\n  const maxPerTenant = tenantLimit && tenantLimit > 0 ? tenantLimit : null;\n  if (!maxPerSource && !maxPerTenant) return null;\n\n  let staticData = null;\n  try {\n    staticData = workflowContext.getWorkflowStaticData('global');\n  } catch (error) {\n    staticData = null;\n  }\n  const state = staticData ? (staticData.rate_limit_state ?? (staticData.rate_limit_state = {})) : {};\n  const now = Math.floor(Date.now() / 1000);\n\n  function bump(key, maxAllowed) {\n    if (!maxAllowed) return false;\n    const entry = state[key] ?? { window: now, count: 0 };\n    if (entry.window !== now) {\n      entry.window = now;\n      entry.count = 0;\n    }\n    entry.count += 1;\n    state[key] = entry;\n    return entry.count > maxAllowed;\n  }\n\n  const sourceKey = `source:${source}`;\n  if (bump(sourceKey, maxPerSource)) return error(429, 'rate limit exceeded');\n  if (resolvedTenant) {\n    const tenantKey = `tenant:${tenant}`;\n    if (bump(tenantKey, maxPerTenant)) return error(429, 'tenant rate limit exceeded');\n  }\n  return null;\n}\n\nfunction getByPath(obj, path) {\n  if (!obj || typeof obj !== 'object') return undefined;\n  const parts = String(path).split('.').filter(Boolean);\n  let cur = obj;\n  for (const part of parts) {\n    if (cur === null || cur === undefined) return undefined;\n    cur = cur?.[part];\n  }\n  return cur;\n}\n\nfunction pickFirst(obj, paths, fallback) {\n  const candidates = Array.isArray(paths) ? paths : null;\n  const list = (candidates && candidates.length > 0)\n    ? candidates\n    : (Array.isArray(fallback) ? fallback : []);\n  for (const p of list) {\n    const v = getByPath(obj, p);\n    if (v !== undefined && v !== null && String(v).trim() !== '') return v;\n  }\n  return null;\n}\n\nfunction applyTemplate(template, vars) {\n  const raw = template ?? '{source}:{event_id}';\n  return String(raw)\n    .split('{source}').join(String(vars.source ?? 'unknown'))\n    .split('{event_id}').join(String(vars.event_id ?? ''));\n}\n\nfunction parseSimpleYamlMap(text) {\n  const map = {};\n  const lines = String(text).split(/\\r?\\n/);\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed.startsWith('#')) continue;\n    const idx = trimmed.indexOf(':');\n    if (idx <= 0) continue;\n    const key = trimmed.slice(0, idx).trim();\n    let value = trimmed.slice(idx + 1).trim();\n    if (!key) continue;\n    if ((value.startsWith('\"') && value.endsWith('\"')) || (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\n      value = value.slice(1, -1);\n    }\n    map[key] = value;\n  }\n  return map;\n}\n\nfunction parseTokenMap() {\n  const jsonRaw = $env.N8N_ZULIP_OUTGOING_TOKENS_JSON || $env.N8N_ZULIP_OUTGOING_TOKEN;\n  if (jsonRaw) {\n    try {\n      const parsed = JSON.parse(jsonRaw);\n      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) return parsed;\n    } catch (error) {\n      // ignore\n    }\n  }\n  const yamlRaw = $env.N8N_ZULIP_OUTGOING_TOKENS_YAML || $env.N8N_ZULIP_OUTGOING_TOKEN;\n  if (yamlRaw) {\n    const parsed = parseSimpleYamlMap(yamlRaw);\n    if (Object.keys(parsed).length > 0) return parsed;\n  }\n  return null;\n}\n\nconst source = 'zulip';\nconst payloadCheck = checkPayloadLimit();\nif (payloadCheck) return payloadCheck;\nconst sourcePolicy = ingestPolicyDoc?.sources?.[source] ?? null;\nconst eventId = pickFirst(body, sourcePolicy?.event_id_paths, ['event_id', 'id']);\nif (!eventId) return error(400, 'message.id は必須です');\n\nconst keyTemplate = sourcePolicy?.dedupe_key_template\n  ?? ingestPolicyDoc?.dedupe?.default_key_template\n  ?? '{source}:{event_id}';\nconst maxLen = ingestPolicyDoc?.dedupe?.max_key_length ?? 256;\nlet dedupeKey = applyTemplate(keyTemplate, { source, event_id: String(eventId) });\nif (dedupeKey.length > maxLen) dedupeKey = dedupeKey.slice(0, maxLen);\n\nconst tokenMap = parseTokenMap();\nconst fallbackToken = $env.N8N_ZULIP_OUTGOING_TOKEN || null;\nconst tenant = pickFirst(\n  { params, body },\n  ['params.tenant', 'params.realm', 'body.tenant', 'body.realm', 'body.message.tenant', 'body.message.realm'],\n  []\n) || null;\n\nlet resolvedTenant = tenant || resolveTenantFromBody(body) || null;\n\nconst tenantRateCheck = checkRateLimit(source, resolvedTenant);\nif (tenantRateCheck) return tenantRateCheck;\n\nconst token = body.token;\nif (!token) return error(401, 'Zulip トークンが不足しています');\n\nif (!resolvedTenant && tokenMap && Object.keys(tokenMap).length > 0) {\n  const matched = Object.entries(tokenMap).find(([k, v]) => k && k !== 'default' && String(v) === String(token));\n  if (matched) resolvedTenant = matched[0];\n}\n\nlet expectedToken = null;\nif (tokenMap && Object.keys(tokenMap).length > 0) {\n  if (resolvedTenant) {\n    expectedToken = tokenMap[resolvedTenant] ?? null;\n    if (!expectedToken && tokenMap.default) expectedToken = tokenMap.default;\n    if (!expectedToken && fallbackToken) expectedToken = fallbackToken;\n    if (!expectedToken) return error(401, `Zulip トークンが未登録です (tenant=${resolvedTenant})`);\n  } else {\n    expectedToken = tokenMap.default || fallbackToken;\n    if (!expectedToken) return error(400, 'Zulip tenant が未指定です');\n  }\n} else {\n  expectedToken = fallbackToken;\n}\n\nif (!expectedToken) {\n  return error(500, 'N8N_ZULIP_OUTGOING_TOKENS_YAML または N8N_ZULIP_OUTGOING_TOKEN が未設定です');\n}\n\nif (token !== expectedToken) return error(401, 'Zulip トークンが不正です');\n\nconst traceId = getHeader('x-aiops-trace-id') || crypto.randomUUID();\n\nconst stream = body.message?.display_recipient ?? body.message?.stream_id ?? body.stream ?? null;\nconst topic = body.message?.subject ?? body.topic ?? null;\n\nconst messageType = body.message?.type || (Array.isArray(body.message?.display_recipient) ? 'private' : 'stream');\nconst recipients = Array.isArray(body.message?.display_recipient)\n  ? body.message.display_recipient.map((r) => r && r.email).filter(Boolean)\n  : (body.message?.sender_email ? [body.message.sender_email] : []);\n\nconst actor = {\n  source: 'zulip',\n  user_id: body.message?.sender_id ?? body.user_id ?? null,\n  email: body.message?.sender_email ?? body.email ?? null,\n  full_name: body.message?.sender_full_name ?? body.full_name ?? null,\n  realm: resolvedTenant ?? null,\n  tenant: resolvedTenant ?? null\n};\n\nconst replyTarget = {\n  source: 'zulip',\n  type: messageType,\n  stream: messageType === 'stream' ? stream : null,\n  topic: messageType === 'stream' ? topic : null,\n  recipients: messageType === 'private' ? recipients : [],\n  message_id: eventId,\n  realm: resolvedTenant ?? null,\n  tenant: resolvedTenant ?? null\n};\n\nconst normalizedEvent = {\n  source: 'zulip',\n  event_id: String(eventId),\n  received_at: new Date().toISOString(),\n  text: body.message?.content ?? body.text ?? '',\n  trace_id: traceId,\n  raw_headers: headers,\n  raw_body: body,\n  tenant: resolvedTenant ?? null\n};\n\nconst contextId = crypto.randomUUID();\n\nreturn [{\n  json: {\n    valid: true,\n    source: 'zulip',\n    trace_id: traceId,\n    context_id: contextId,\n    dedupe_key: dedupeKey,\n    actor,\n    reply_target: replyTarget,\n    normalized_event: normalizedEvent\n  }\n}];\n"
      },
      "id": "8",
      "name": "Validate Zulip",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        220
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.valid}}",
              "value2": "true",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "9",
      "name": "IF Zulip Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        680,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst body = $json ?? {};\nconst headers = $headers ?? {};\n\nfunction getHeader(name) {\n  const lower = name.toLowerCase();\n  if (headers[lower] !== undefined) return headers[lower];\n  if (headers[name] !== undefined) return headers[name];\n  const key = Object.keys(headers).find((k) => k.toLowerCase() === lower);\n  return key ? headers[key] : undefined;\n}\n\nfunction error(status, message) {\n  return [{ json: { valid: '', status_code: status, error: message } }];\n}\n\nconst expectedToken = $env.N8N_MATTERMOST_OUTGOING_TOKEN;\nif (!expectedToken) return error(500, 'N8N_MATTERMOST_OUTGOING_TOKEN が未設定です');\n\nconst token = body.token;\nif (!token || token !== expectedToken) return error(401, 'Mattermost トークンが不正です');\n\nlet ingestPolicyDoc = null;\ntry {\n  ingestPolicyDoc = JSON.parse(\"__POLICY__INGEST__\");\n} catch (error) {\n  ingestPolicyDoc = null;\n}\n\nconst workflowContext = this;\n\nfunction toNumber(value) {\n  const parsed = Number(value);\n  if (!Number.isFinite(parsed)) return null;\n  return parsed;\n}\n\nfunction readEnvNumber(name) {\n  const raw = $env?.[name];\n  if (raw === undefined || raw === null || raw === '') return null;\n  return toNumber(raw);\n}\n\nfunction resolvePayloadLimitBytes() {\n  const payloadPolicy = ingestPolicyDoc?.payload_limits ?? {};\n  return (\n    readEnvNumber('N8N_INGEST_PAYLOAD_MAX_BYTES')\n    ?? readEnvNumber('N8N_INGEST_MAX_BYTES')\n    ?? toNumber(payloadPolicy.ingest_payload_max_bytes)\n    ?? toNumber(payloadPolicy.ingest_max_bytes)\n    ?? null\n  );\n}\n\nfunction resolvePayloadRejectStatus() {\n  const payloadPolicy = ingestPolicyDoc?.payload_limits ?? {};\n  const status = toNumber(payloadPolicy.reject_status);\n  return status && status >= 400 ? status : 413;\n}\n\nfunction getPayloadBytes() {\n  const raw = body.rawBody ?? body.raw_body ?? null;\n  if (typeof raw === 'string') return Buffer.byteLength(raw, 'utf8');\n  if (raw && typeof raw === 'object') {\n    try {\n      return Buffer.byteLength(JSON.stringify(raw), 'utf8');\n    } catch (error) {}\n  }\n  const headerLen = toNumber(getHeader('content-length'));\n  if (headerLen && headerLen > 0) return headerLen;\n  try {\n    return Buffer.byteLength(JSON.stringify(body ?? {}), 'utf8');\n  } catch (error) {\n    return 0;\n  }\n}\n\nfunction checkPayloadLimit() {\n  const limit = resolvePayloadLimitBytes();\n  if (!limit || limit <= 0) return null;\n  const bytes = getPayloadBytes();\n  if (bytes > limit) {\n    return error(resolvePayloadRejectStatus(), `payload too large (${bytes} bytes)`);\n  }\n  return null;\n}\n\nfunction resolveTenantFromBody(payload) {\n  if (!payload || typeof payload !== 'object') return null;\n  return (\n    payload.tenant ||\n    payload.realm ||\n    payload.team_id ||\n    payload.team?.id ||\n    null\n  );\n}\n\nfunction resolveRateLimitConfig(source) {\n  const ratePolicy = ingestPolicyDoc?.rate_limit ?? {};\n  const sourceKey = String(source || '').trim().toUpperCase();\n  const envSourceLimit = sourceKey\n    ? readEnvNumber(`N8N_INGEST_RATE_LIMIT_RPS_${sourceKey}`)\n    : null;\n  const envSourceBurst = sourceKey\n    ? readEnvNumber(`N8N_INGEST_BURST_RPS_${sourceKey}`)\n    : null;\n  const perSourceLimit = ratePolicy?.per_source_rps?.[source] ?? ratePolicy?.per_source_qps?.[source] ?? null;\n  const limit = envSourceLimit\n    ?? readEnvNumber('N8N_INGEST_RATE_LIMIT_RPS')\n    ?? toNumber(perSourceLimit)\n    ?? toNumber(ratePolicy.ingest_rate_limit_rps)\n    ?? toNumber(ratePolicy.default_rps)\n    ?? toNumber(ratePolicy.default_qps)\n    ?? null;\n  const burst = envSourceBurst\n    ?? readEnvNumber('N8N_INGEST_BURST_RPS')\n    ?? toNumber(ratePolicy.burst_rps)\n    ?? toNumber(ratePolicy.default_burst_rps)\n    ?? toNumber(ratePolicy.default_burst_qps)\n    ?? null;\n  const tenantLimit = readEnvNumber('N8N_TENANT_RATE_LIMIT_RPS')\n    ?? toNumber(ratePolicy.tenant_rate_limit_rps)\n    ?? null;\n  return { limit, burst, tenantLimit };\n}\n\nfunction checkRateLimit(source, tenant) {\n  const { limit, burst, tenantLimit } = resolveRateLimitConfig(source);\n  const maxPerSource = limit && limit > 0 ? (burst && burst > limit ? burst : limit) : null;\n  const maxPerTenant = tenantLimit && tenantLimit > 0 ? tenantLimit : null;\n  if (!maxPerSource && !maxPerTenant) return null;\n\n  let staticData = null;\n  try {\n    staticData = workflowContext.getWorkflowStaticData('global');\n  } catch (error) {\n    staticData = null;\n  }\n  const state = staticData ? (staticData.rate_limit_state ?? (staticData.rate_limit_state = {})) : {};\n  const now = Math.floor(Date.now() / 1000);\n\n  function bump(key, maxAllowed) {\n    if (!maxAllowed) return false;\n    const entry = state[key] ?? { window: now, count: 0 };\n    if (entry.window !== now) {\n      entry.window = now;\n      entry.count = 0;\n    }\n    entry.count += 1;\n    state[key] = entry;\n    return entry.count > maxAllowed;\n  }\n\n  const sourceKey = `source:${source}`;\n  if (bump(sourceKey, maxPerSource)) return error(429, 'rate limit exceeded');\n  if (tenant) {\n    const tenantKey = `tenant:${tenant}`;\n    if (bump(tenantKey, maxPerTenant)) return error(429, 'tenant rate limit exceeded');\n  }\n  return null;\n}\n\nfunction getByPath(obj, path) {\n  if (!obj || typeof obj !== 'object') return undefined;\n  const parts = String(path).split('.').filter(Boolean);\n  let cur = obj;\n  for (const part of parts) {\n    if (cur === null || cur === undefined) return undefined;\n    cur = cur?.[part];\n  }\n  return cur;\n}\n\nfunction pickFirst(obj, paths, fallback) {\n  const candidates = Array.isArray(paths) ? paths : null;\n  const list = (candidates && candidates.length > 0)\n    ? candidates\n    : (Array.isArray(fallback) ? fallback : []);\n  for (const p of list) {\n    const v = getByPath(obj, p);\n    if (v !== undefined && v !== null && String(v).trim() !== '') return v;\n  }\n  return null;\n}\n\nfunction applyTemplate(template, vars) {\n  const raw = template ?? '{source}:{event_id}';\n  return String(raw)\n    .split('{source}').join(String(vars.source ?? 'unknown'))\n    .split('{event_id}').join(String(vars.event_id ?? ''));\n}\n\nconst source = 'mattermost';\nconst payloadCheck = checkPayloadLimit();\nif (payloadCheck) return payloadCheck;\nconst rateCheck = checkRateLimit(source, resolveTenantFromBody(body));\nif (rateCheck) return rateCheck;\nconst sourcePolicy = ingestPolicyDoc?.sources?.[source] ?? null;\nconst eventId = pickFirst(body, sourcePolicy?.event_id_paths, ['event_id', 'id']);\nif (!eventId) return error(400, 'post_id は必須です');\n\nconst keyTemplate = sourcePolicy?.dedupe_key_template\n  ?? ingestPolicyDoc?.dedupe?.default_key_template\n  ?? '{source}:{event_id}';\nconst maxLen = ingestPolicyDoc?.dedupe?.max_key_length ?? 256;\nlet dedupeKey = applyTemplate(keyTemplate, { source, event_id: String(eventId) });\nif (dedupeKey.length > maxLen) dedupeKey = dedupeKey.slice(0, maxLen);\n\n\nconst traceId = getHeader('x-aiops-trace-id') || crypto.randomUUID();\n\nconst actor = {\n  source: 'mattermost',\n  user_id: body.user_id ?? null,\n  user_name: body.user_name ?? null\n};\n\nconst replyTarget = {\n  source: 'mattermost',\n  team_id: body.team_id ?? null,\n  channel_id: body.channel_id ?? null,\n  post_id: eventId\n};\n\nconst normalizedEvent = {\n  source: 'mattermost',\n  event_id: String(eventId),\n  received_at: new Date().toISOString(),\n  text: body.text ?? '',\n  trace_id: traceId,\n  raw_headers: headers,\n  raw_body: body\n};\n\nconst contextId = crypto.randomUUID();\n\nreturn [{\n  json: {\n    valid: true,\n    source: 'mattermost',\n    trace_id: traceId,\n    context_id: contextId,\n    dedupe_key: dedupeKey,\n    actor,\n    reply_target: replyTarget,\n    normalized_event: normalizedEvent\n  }\n}];\n\n"
      },
      "id": "10",
      "name": "Validate Mattermost",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        440
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.valid}}",
              "value2": "true",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "11",
      "name": "IF Mattermost Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        680,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst body = $json ?? {};\nconst headers = $headers ?? {};\n\nfunction getHeader(name) {\n  const lower = name.toLowerCase();\n  if (headers[lower] !== undefined) return headers[lower];\n  if (headers[name] !== undefined) return headers[name];\n  const key = Object.keys(headers).find((k) => k.toLowerCase() === lower);\n  return key ? headers[key] : undefined;\n}\n\nfunction error(status, message) {\n  return [{ json: { valid: '', status_code: status, error: message } }];\n}\n\nconst expectedToken = $env.N8N_TEAMS_TEST_TOKEN;\nif (!expectedToken) return error(500, 'N8N_TEAMS_TEST_TOKEN が未設定です');\n\nconst token = getHeader('x-aiops-test-token');\nif (!token || token !== expectedToken) return error(401, 'Teams テストトークンが不正です');\n\nlet ingestPolicyDoc = null;\ntry {\n  ingestPolicyDoc = JSON.parse(\"__POLICY__INGEST__\");\n} catch (error) {\n  ingestPolicyDoc = null;\n}\n\nconst workflowContext = this;\n\nfunction toNumber(value) {\n  const parsed = Number(value);\n  if (!Number.isFinite(parsed)) return null;\n  return parsed;\n}\n\nfunction readEnvNumber(name) {\n  const raw = $env?.[name];\n  if (raw === undefined || raw === null || raw === '') return null;\n  return toNumber(raw);\n}\n\nfunction resolvePayloadLimitBytes() {\n  const payloadPolicy = ingestPolicyDoc?.payload_limits ?? {};\n  return (\n    readEnvNumber('N8N_INGEST_PAYLOAD_MAX_BYTES')\n    ?? readEnvNumber('N8N_INGEST_MAX_BYTES')\n    ?? toNumber(payloadPolicy.ingest_payload_max_bytes)\n    ?? toNumber(payloadPolicy.ingest_max_bytes)\n    ?? null\n  );\n}\n\nfunction resolvePayloadRejectStatus() {\n  const payloadPolicy = ingestPolicyDoc?.payload_limits ?? {};\n  const status = toNumber(payloadPolicy.reject_status);\n  return status && status >= 400 ? status : 413;\n}\n\nfunction getPayloadBytes() {\n  const raw = body.rawBody ?? body.raw_body ?? null;\n  if (typeof raw === 'string') return Buffer.byteLength(raw, 'utf8');\n  if (raw && typeof raw === 'object') {\n    try {\n      return Buffer.byteLength(JSON.stringify(raw), 'utf8');\n    } catch (error) {}\n  }\n  const headerLen = toNumber(getHeader('content-length'));\n  if (headerLen && headerLen > 0) return headerLen;\n  try {\n    return Buffer.byteLength(JSON.stringify(body ?? {}), 'utf8');\n  } catch (error) {\n    return 0;\n  }\n}\n\nfunction checkPayloadLimit() {\n  const limit = resolvePayloadLimitBytes();\n  if (!limit || limit <= 0) return null;\n  const bytes = getPayloadBytes();\n  if (bytes > limit) {\n    return error(resolvePayloadRejectStatus(), `payload too large (${bytes} bytes)`);\n  }\n  return null;\n}\n\nfunction resolveTenantFromBody(payload) {\n  if (!payload || typeof payload !== 'object') return null;\n  return (\n    payload.tenant ||\n    payload.realm ||\n    payload.team_id ||\n    payload.team?.id ||\n    null\n  );\n}\n\nfunction resolveRateLimitConfig(source) {\n  const ratePolicy = ingestPolicyDoc?.rate_limit ?? {};\n  const sourceKey = String(source || '').trim().toUpperCase();\n  const envSourceLimit = sourceKey\n    ? readEnvNumber(`N8N_INGEST_RATE_LIMIT_RPS_${sourceKey}`)\n    : null;\n  const envSourceBurst = sourceKey\n    ? readEnvNumber(`N8N_INGEST_BURST_RPS_${sourceKey}`)\n    : null;\n  const perSourceLimit = ratePolicy?.per_source_rps?.[source] ?? ratePolicy?.per_source_qps?.[source] ?? null;\n  const limit = envSourceLimit\n    ?? readEnvNumber('N8N_INGEST_RATE_LIMIT_RPS')\n    ?? toNumber(perSourceLimit)\n    ?? toNumber(ratePolicy.ingest_rate_limit_rps)\n    ?? toNumber(ratePolicy.default_rps)\n    ?? toNumber(ratePolicy.default_qps)\n    ?? null;\n  const burst = envSourceBurst\n    ?? readEnvNumber('N8N_INGEST_BURST_RPS')\n    ?? toNumber(ratePolicy.burst_rps)\n    ?? toNumber(ratePolicy.default_burst_rps)\n    ?? toNumber(ratePolicy.default_burst_qps)\n    ?? null;\n  const tenantLimit = readEnvNumber('N8N_TENANT_RATE_LIMIT_RPS')\n    ?? toNumber(ratePolicy.tenant_rate_limit_rps)\n    ?? null;\n  return { limit, burst, tenantLimit };\n}\n\nfunction checkRateLimit(source, tenant) {\n  const { limit, burst, tenantLimit } = resolveRateLimitConfig(source);\n  const maxPerSource = limit && limit > 0 ? (burst && burst > limit ? burst : limit) : null;\n  const maxPerTenant = tenantLimit && tenantLimit > 0 ? tenantLimit : null;\n  if (!maxPerSource && !maxPerTenant) return null;\n\n  let staticData = null;\n  try {\n    staticData = workflowContext.getWorkflowStaticData('global');\n  } catch (error) {\n    staticData = null;\n  }\n  const state = staticData ? (staticData.rate_limit_state ?? (staticData.rate_limit_state = {})) : {};\n  const now = Math.floor(Date.now() / 1000);\n\n  function bump(key, maxAllowed) {\n    if (!maxAllowed) return false;\n    const entry = state[key] ?? { window: now, count: 0 };\n    if (entry.window !== now) {\n      entry.window = now;\n      entry.count = 0;\n    }\n    entry.count += 1;\n    state[key] = entry;\n    return entry.count > maxAllowed;\n  }\n\n  const sourceKey = `source:${source}`;\n  if (bump(sourceKey, maxPerSource)) return error(429, 'rate limit exceeded');\n  if (tenant) {\n    const tenantKey = `tenant:${tenant}`;\n    if (bump(tenantKey, maxPerTenant)) return error(429, 'tenant rate limit exceeded');\n  }\n  return null;\n}\n\nfunction getByPath(obj, path) {\n  if (!obj || typeof obj !== 'object') return undefined;\n  const parts = String(path).split('.').filter(Boolean);\n  let cur = obj;\n  for (const part of parts) {\n    if (cur === null || cur === undefined) return undefined;\n    cur = cur?.[part];\n  }\n  return cur;\n}\n\nfunction pickFirst(obj, paths, fallback) {\n  const candidates = Array.isArray(paths) ? paths : null;\n  const list = (candidates && candidates.length > 0)\n    ? candidates\n    : (Array.isArray(fallback) ? fallback : []);\n  for (const p of list) {\n    const v = getByPath(obj, p);\n    if (v !== undefined && v !== null && String(v).trim() !== '') return v;\n  }\n  return null;\n}\n\nfunction applyTemplate(template, vars) {\n  const raw = template ?? '{source}:{event_id}';\n  return String(raw)\n    .split('{source}').join(String(vars.source ?? 'unknown'))\n    .split('{event_id}').join(String(vars.event_id ?? ''));\n}\n\nconst source = 'teams';\nconst payloadCheck = checkPayloadLimit();\nif (payloadCheck) return payloadCheck;\nconst rateCheck = checkRateLimit(source, resolveTenantFromBody(body));\nif (rateCheck) return rateCheck;\nconst sourcePolicy = ingestPolicyDoc?.sources?.[source] ?? null;\nconst eventId = pickFirst(body, sourcePolicy?.event_id_paths, ['event_id', 'id']);\nif (!eventId) return error(400, 'id は必須です');\n\nconst keyTemplate = sourcePolicy?.dedupe_key_template\n  ?? ingestPolicyDoc?.dedupe?.default_key_template\n  ?? '{source}:{event_id}';\nconst maxLen = ingestPolicyDoc?.dedupe?.max_key_length ?? 256;\nlet dedupeKey = applyTemplate(keyTemplate, { source, event_id: String(eventId) });\nif (dedupeKey.length > maxLen) dedupeKey = dedupeKey.slice(0, maxLen);\n\n\nconst conversationId = body.conversation?.id;\nif (!conversationId) return error(400, 'conversation.id は必須です');\n\nconst traceId = getHeader('x-aiops-trace-id') || crypto.randomUUID();\n\nconst actor = {\n  source: 'teams',\n  user_id: body.from?.id ?? null,\n  name: body.from?.name ?? null\n};\n\nconst replyTarget = {\n  source: 'teams',\n  conversation_id: conversationId,\n  service_url: body.serviceUrl ?? null,\n  channel_id: body.channelId ?? null\n};\n\nconst normalizedEvent = {\n  source: 'teams',\n  event_id: String(eventId),\n  received_at: new Date().toISOString(),\n  text: body.text ?? '',\n  trace_id: traceId,\n  raw_headers: headers,\n  raw_body: body\n};\n\nconst contextId = crypto.randomUUID();\n\nreturn [{\n  json: {\n    valid: true,\n    source: 'teams',\n    trace_id: traceId,\n    context_id: contextId,\n    dedupe_key: dedupeKey,\n    actor,\n    reply_target: replyTarget,\n    normalized_event: normalizedEvent\n  }\n}];\n\n"
      },
      "id": "12",
      "name": "Validate Teams",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        660
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.valid}}",
              "value2": "true",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "13",
      "name": "IF Teams Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        680,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst request = $json ?? {};\nconst body = (request && typeof request === 'object' && request.body !== undefined)\n  ? (request.body ?? {})\n  : request;\nconst headers = (typeof $headers !== 'undefined' && $headers)\n  ? $headers\n  : (request && typeof request === 'object' && request.headers && typeof request.headers === 'object')\n    ? request.headers\n    : {};\n\nfunction getHeader(name) {\n  const lower = name.toLowerCase();\n  if (headers[lower] !== undefined) return headers[lower];\n  if (headers[name] !== undefined) return headers[name];\n  const key = Object.keys(headers).find((k) => k.toLowerCase() === lower);\n  return key ? headers[key] : undefined;\n}\n\nfunction error(status, message) {\n  return [{ json: { valid: '', status_code: status, error: message } }];\n}\n\nconst expectedWebhookToken = String($env.N8N_CLOUDWATCH_WEBHOOK_SECRET || '');\nif (expectedWebhookToken) {\n  const providedWebhookToken = String(getHeader('x-aiops-webhook-token') || '');\n  if (providedWebhookToken !== expectedWebhookToken) return error(401, 'unauthorized');\n}\n\nlet ingestPolicyDoc = null;\ntry {\n  ingestPolicyDoc = JSON.parse(\"__POLICY__INGEST__\");\n} catch (error) {\n  ingestPolicyDoc = null;\n}\n\nconst workflowContext = this;\n\nfunction toNumber(value) {\n  const parsed = Number(value);\n  if (!Number.isFinite(parsed)) return null;\n  return parsed;\n}\n\nfunction readEnvNumber(name) {\n  const raw = $env?.[name];\n  if (raw === undefined || raw === null || raw === '') return null;\n  return toNumber(raw);\n}\n\nfunction resolvePayloadLimitBytes() {\n  const payloadPolicy = ingestPolicyDoc?.payload_limits ?? {};\n  return (\n    readEnvNumber('N8N_INGEST_PAYLOAD_MAX_BYTES')\n    ?? readEnvNumber('N8N_INGEST_MAX_BYTES')\n    ?? toNumber(payloadPolicy.ingest_payload_max_bytes)\n    ?? toNumber(payloadPolicy.ingest_max_bytes)\n    ?? null\n  );\n}\n\nfunction resolvePayloadRejectStatus() {\n  const payloadPolicy = ingestPolicyDoc?.payload_limits ?? {};\n  const status = toNumber(payloadPolicy.reject_status);\n  return status && status >= 400 ? status : 413;\n}\n\nfunction getPayloadBytes() {\n  const raw = body.rawBody ?? body.raw_body ?? null;\n  if (typeof raw === 'string') return Buffer.byteLength(raw, 'utf8');\n  if (raw && typeof raw === 'object') {\n    try {\n      return Buffer.byteLength(JSON.stringify(raw), 'utf8');\n    } catch (error) {}\n  }\n  const headerLen = toNumber(getHeader('content-length'));\n  if (headerLen && headerLen > 0) return headerLen;\n  try {\n    return Buffer.byteLength(JSON.stringify(body ?? {}), 'utf8');\n  } catch (error) {\n    return 0;\n  }\n}\n\nfunction checkPayloadLimit() {\n  const limit = resolvePayloadLimitBytes();\n  if (!limit || limit <= 0) return null;\n  const bytes = getPayloadBytes();\n  if (bytes > limit) {\n    return error(resolvePayloadRejectStatus(), `payload too large (${bytes} bytes)`);\n  }\n  return null;\n}\n\nfunction resolveTenantFromBody(payload) {\n  if (!payload || typeof payload !== 'object') return null;\n  return (\n    payload.tenant ||\n    payload.realm ||\n    payload.team_id ||\n    payload.team?.id ||\n    null\n  );\n}\n\nfunction resolveRateLimitConfig(source) {\n  const ratePolicy = ingestPolicyDoc?.rate_limit ?? {};\n  const sourceKey = String(source || '').trim().toUpperCase();\n  const envSourceLimit = sourceKey\n    ? readEnvNumber(`N8N_INGEST_RATE_LIMIT_RPS_${sourceKey}`)\n    : null;\n  const envSourceBurst = sourceKey\n    ? readEnvNumber(`N8N_INGEST_BURST_RPS_${sourceKey}`)\n    : null;\n  const perSourceLimit = ratePolicy?.per_source_rps?.[source] ?? ratePolicy?.per_source_qps?.[source] ?? null;\n  const limit = envSourceLimit\n    ?? readEnvNumber('N8N_INGEST_RATE_LIMIT_RPS')\n    ?? toNumber(perSourceLimit)\n    ?? toNumber(ratePolicy.ingest_rate_limit_rps)\n    ?? toNumber(ratePolicy.default_rps)\n    ?? toNumber(ratePolicy.default_qps)\n    ?? null;\n  const burst = envSourceBurst\n    ?? readEnvNumber('N8N_INGEST_BURST_RPS')\n    ?? toNumber(ratePolicy.burst_rps)\n    ?? toNumber(ratePolicy.default_burst_rps)\n    ?? toNumber(ratePolicy.default_burst_qps)\n    ?? null;\n  const tenantLimit = readEnvNumber('N8N_TENANT_RATE_LIMIT_RPS')\n    ?? toNumber(ratePolicy.tenant_rate_limit_rps)\n    ?? null;\n  return { limit, burst, tenantLimit };\n}\n\nfunction checkRateLimit(source, tenant) {\n  const { limit, burst, tenantLimit } = resolveRateLimitConfig(source);\n  const maxPerSource = limit && limit > 0 ? (burst && burst > limit ? burst : limit) : null;\n  const maxPerTenant = tenantLimit && tenantLimit > 0 ? tenantLimit : null;\n  if (!maxPerSource && !maxPerTenant) return null;\n\n  let staticData = null;\n  try {\n    staticData = workflowContext.getWorkflowStaticData('global');\n  } catch (error) {\n    staticData = null;\n  }\n  const state = staticData ? (staticData.rate_limit_state ?? (staticData.rate_limit_state = {})) : {};\n  const now = Math.floor(Date.now() / 1000);\n\n  function bump(key, maxAllowed) {\n    if (!maxAllowed) return false;\n    const entry = state[key] ?? { window: now, count: 0 };\n    if (entry.window !== now) {\n      entry.window = now;\n      entry.count = 0;\n    }\n    entry.count += 1;\n    state[key] = entry;\n    return entry.count > maxAllowed;\n  }\n\n  const sourceKey = `source:${source}`;\n  if (bump(sourceKey, maxPerSource)) return error(429, 'rate limit exceeded');\n  if (tenant) {\n    const tenantKey = `tenant:${tenant}`;\n    if (bump(tenantKey, maxPerTenant)) return error(429, 'tenant rate limit exceeded');\n  }\n  return null;\n}\n\nfunction getByPath(obj, path) {\n  if (!obj || typeof obj !== 'object') return undefined;\n  const parts = String(path).split('.').filter(Boolean);\n  let cur = obj;\n  for (const part of parts) {\n    if (cur === null || cur === undefined) return undefined;\n    cur = cur?.[part];\n  }\n  return cur;\n}\n\nfunction pickFirst(obj, paths, fallback) {\n  const candidates = Array.isArray(paths) ? paths : null;\n  const list = (candidates && candidates.length > 0)\n    ? candidates\n    : (Array.isArray(fallback) ? fallback : []);\n  for (const p of list) {\n    const v = getByPath(obj, p);\n    if (v !== undefined && v !== null && String(v).trim() !== '') return v;\n  }\n  return null;\n}\n\nfunction applyTemplate(template, vars) {\n  const raw = template ?? '{source}:{event_id}';\n  return String(raw)\n    .split('{source}').join(String(vars.source ?? 'unknown'))\n    .split('{event_id}').join(String(vars.event_id ?? ''));\n}\n\nconst source = 'cloudwatch';\nconst payloadCheck = checkPayloadLimit();\nif (payloadCheck) return payloadCheck;\nconst rateCheck = checkRateLimit(source, resolveTenantFromBody(body));\nif (rateCheck) return rateCheck;\nconst sourcePolicy = ingestPolicyDoc?.sources?.[source] ?? null;\nconst eventId = pickFirst(body, sourcePolicy?.event_id_paths, ['event_id', 'id']);\nif (!eventId) return error(400, 'id は必須です');\n\nconst keyTemplate = sourcePolicy?.dedupe_key_template\n  ?? ingestPolicyDoc?.dedupe?.default_key_template\n  ?? '{source}:{event_id}';\nconst maxLen = ingestPolicyDoc?.dedupe?.max_key_length ?? 256;\nlet dedupeKey = applyTemplate(keyTemplate, { source, event_id: String(eventId) });\nif (dedupeKey.length > maxLen) dedupeKey = dedupeKey.slice(0, maxLen);\n\n\nif (!body['detail-type']) return error(400, 'detail-type は必須です');\n\nconst detail = body.detail ?? {};\nconst traceId = getHeader('x-aiops-trace-id') || crypto.randomUUID();\n\nconst actor = {\n  source: 'cloudwatch',\n  account: body.account ?? null\n};\n\nconst replyTarget = {\n  source: 'cloudwatch',\n  alarm_name: detail.alarmName ?? null,\n  region: body.region ?? null\n};\n\nconst normalizedEvent = {\n  source: 'cloudwatch',\n  event_id: String(eventId),\n  received_at: new Date().toISOString(),\n  text: detail.alarmName ?? body['detail-type'] ?? '',\n  trace_id: traceId,\n  raw_headers: headers,\n  raw_body: body\n};\n\nconst contextId = crypto.randomUUID();\n\nreturn [{\n  json: {\n    valid: true,\n    source: 'cloudwatch',\n    trace_id: traceId,\n    context_id: contextId,\n    dedupe_key: dedupeKey,\n    actor,\n    reply_target: replyTarget,\n    normalized_event: normalizedEvent\n  }\n}];\n\n"
      },
      "id": "14",
      "name": "Validate CloudWatch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        880
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.valid}}",
              "value2": "true",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "15",
      "name": "IF CloudWatch Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        680,
        880
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json.valid === true ? { ok: true, receivedAt: new Date().toISOString() } : { ok: false, error: $json.error, status: $json.status_code } }}",
        "options": {
          "responseCode": "={{$json.status_code || 200}}"
        }
      },
      "id": "16",
      "name": "Respond 200",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        920,
        200
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { ok: false, error: $json.error, status: $json.status_code } }}",
        "options": {
          "responseCode": "={{$json.status_code}}"
        }
      },
      "id": "17",
      "name": "Respond Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        920,
        40
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { response_not_required: true } }}",
        "options": {
          "responseCode": "={{200}}"
        }
      },
      "id": "respond-zulip-ack",
      "name": "Respond Ack (Zulip Webhook)",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        920,
        120
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ (() => { const content = (typeof $json.content === 'string' ? $json.content : '').trim(); if (content) return { content }; return { response_not_required: true }; })() }}",
        "options": {
          "responseCode": "={{200}}"
        }
      },
      "id": "respond-zulip-message",
      "name": "Respond Zulip Message",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        920,
        360
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ ['1','true','yes','y','on'].includes(String($env.N8N_ZULIP_DEFER_SLOW_RESPONSE || '').toLowerCase()) }}",
              "value2": true
            }
          ]
        }
      },
      "id": "if-zulip-defer-slow-response",
      "name": "IF Defer Slow Response (Zulip)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1780,
        120
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { content: '後でメッセンジャーでお伝えします。' } }}",
        "options": {
          "responseCode": "={{200}}"
        }
      },
      "id": "respond-zulip-deferred",
      "name": "Respond Deferred (Zulip)",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        2000,
        40
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH insert_dedupe AS (\n  INSERT INTO aiops_dedupe (dedupe_key, context_id)\n  VALUES ('{{ String($json.dedupe_key ?? '').replace(/'/g, \"''\") }}', '{{ String($json.context_id ?? '') }}'::uuid)\n  ON CONFLICT (dedupe_key) DO NOTHING\n  RETURNING 1 AS inserted\n),\ninsert_context AS (\n  INSERT INTO aiops_context (context_id, source, reply_target, actor, normalized_event)\n  SELECT '{{ String($json.context_id ?? '') }}'::uuid, '{{ String($json.source ?? '').replace(/'/g, \"''\") }}', '{{ JSON.stringify($json.reply_target ?? {}).replace(/'/g, \"''\") }}'::jsonb, '{{ JSON.stringify($json.actor ?? {}).replace(/'/g, \"''\") }}'::jsonb, '{{ JSON.stringify($json.normalized_event ?? {}).replace(/'/g, \"''\") }}'::jsonb\n  WHERE EXISTS (SELECT 1 FROM insert_dedupe)\n  ON CONFLICT (context_id) DO NOTHING\n)\nSELECT\n  '{{ String($json.context_id ?? '') }}'::uuid AS context_id,\n  '{{ String($json.source ?? '').replace(/'/g, \"''\") }}' AS source,\n  '{{ JSON.stringify($json.reply_target ?? {}).replace(/'/g, \"''\") }}'::jsonb AS reply_target,\n  '{{ JSON.stringify($json.actor ?? {}).replace(/'/g, \"''\") }}'::jsonb AS actor,\n  '{{ JSON.stringify($json.normalized_event ?? {}).replace(/'/g, \"''\") }}'::jsonb AS normalized_event,\n  '{{ String($json.dedupe_key ?? '').replace(/'/g, \"''\") }}' AS dedupe_key,\n  CASE WHEN EXISTS (SELECT 1 FROM insert_dedupe) THEN false ELSE true END AS is_duplicate;"
      },
      "id": "18",
      "name": "Context Store (Insert)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        1160,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const row = $json ?? {};\nconst rawFlag = row.is_duplicate ?? row[0]?.is_duplicate ?? false;\nconst isDuplicate = rawFlag === true || rawFlag === 't' || rawFlag === 'true' || rawFlag === 1;\nconst dupFlag = isDuplicate ? 'true' : '';\n\nreturn [{\n  json: {\n    ...row,\n    is_duplicate: isDuplicate,\n    is_duplicate_flag: dupFlag\n  }\n}];\n"
      },
      "id": "19",
      "name": "Normalize Duplicate Flag",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const request = $json ?? {};\nconst headers = (request && typeof request === 'object' && request.headers && typeof request.headers === 'object')\n  ? request.headers\n  : (request.normalized_event && typeof request.normalized_event === 'object' && request.normalized_event.raw_headers && typeof request.normalized_event.raw_headers === 'object')\n    ? request.normalized_event.raw_headers\n    : ($node[\"Webhook (Zulip Ingest)\"]?.json?.headers ?? {});\nconst actor = request.actor ?? {};\n\nfunction getHeader(name) {\n  const lower = name.toLowerCase();\n  if (headers[lower] !== undefined) return headers[lower];\n  if (headers[name] !== undefined) return headers[name];\n  const key = Object.keys(headers).find((k) => k.toLowerCase() === lower);\n  return key ? headers[key] : undefined;\n}\n\nfunction parseList(value) {\n  if (!value) return null;\n  return value\n    .split(',')\n    .map((item) => item.trim())\n    .filter((item) => item !== '');\n}\n\nfunction multiSourceList(primary, fallback) {\n  if (primary && primary.length > 0) return primary;\n  return Array.isArray(fallback) ? fallback.filter((item) => typeof item === 'string' && item !== '') : [];\n}\n\nconst realm = getHeader('x-aiops-realm') || actor.realm || actor.tenant || request.reply_target?.realm || request.reply_target?.tenant || 'default';\nconst groups = multiSourceList(\n  parseList(getHeader('x-aiops-groups')),\n  actor.groups\n);\nconst roles = multiSourceList(\n  parseList(getHeader('x-aiops-roles')),\n  actor.roles\n);\n\nconst iamContext = {\n  realm,\n  groups,\n  roles\n};\n\nlet approvalPolicyDoc = null;\ntry {\n  approvalPolicyDoc = JSON.parse(\"__POLICY__APPROVAL__\");\n} catch (error) {\n  approvalPolicyDoc = null;\n}\n\nlet decisionPolicyDoc = null;\ntry {\n  decisionPolicyDoc = JSON.parse(\"__POLICY__DECISION__\");\n} catch (error) {\n  decisionPolicyDoc = null;\n}\n\nlet interactionGrammar = null;\ntry {\n  interactionGrammar = JSON.parse(\"__POLICY__INTERACTION_GRAMMAR__\");\n} catch (error) {\n  interactionGrammar = null;\n}\n\nlet ingestPolicyDoc = null;\ntry {\n  ingestPolicyDoc = JSON.parse(\"__POLICY__INGEST__\");\n} catch (error) {\n  ingestPolicyDoc = null;\n}\n\nconst defaultApprovalPolicy = decisionPolicyDoc?.defaults?.approval_policy\n  ?? $env.N8N_DEFAULT_APPROVAL_POLICY\n  ?? 'ops:standard';\n\nconst policyContext = {\n  approval_policy:\n    getHeader('x-aiops-approval-policy') ||\n    defaultApprovalPolicy,\n  approval_policy_doc: approvalPolicyDoc,\n  ingest_policy_doc: ingestPolicyDoc,\n  limits: decisionPolicyDoc?.limits ?? {},\n  taxonomy: decisionPolicyDoc?.taxonomy ?? {},\n  defaults: decisionPolicyDoc?.defaults ?? {},\n  thresholds: decisionPolicyDoc?.thresholds ?? {},\n  rules: decisionPolicyDoc?.rules ?? {},\n  fallbacks: decisionPolicyDoc?.fallbacks ?? {},\n  interaction_grammar: interactionGrammar\n};\n\nreturn [\n  {\n    json: {\n      ...$json,\n      iam_context: iamContext,\n      policy_context: policyContext\n    }\n  }\n];\n"
      },
      "id": "25",
      "name": "Build IAM & Policy Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        1520,
        320
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.is_duplicate_flag}}",
              "value2": "true",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "20",
      "name": "IF Duplicate",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1640,
        200
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.source}}",
              "value2": "cloudwatch",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "if-cloudwatch-direct-preview",
      "name": "IF CloudWatch Source (Direct Preview)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1760,
        340
      ]
    },
    {
      "parameters": {
        "url": "={{(() => {\n  const webhookUrl = (() => {\n    const candidates = [\n      'Webhook (CloudWatch Ingest)',\n      'Webhook (Zulip Ingest)',\n      'Webhook (Ingest)'\n    ];\n\n    for (const name of candidates) {\n      try {\n        const node = $node[name];\n        const url = node && node.json && node.json.webhookUrl;\n        if (url) return String(url);\n      } catch (error) {\n        // ignore\n      }\n    }\n\n    return '';\n  })();\n\n  const derivedBase = webhookUrl ? webhookUrl.replace(/\\/webhook\\/.*/, '/webhook') : '';\n  const baseRaw = $env.N8N_ORCHESTRATOR_BASE_URL\n    || $env.N8N_WEBHOOK_BASE_URL\n    || $env.N8N_ORCHESTRATOR_BASE_URL\n    || $env.N8N_WEBHOOK_BASE_URL\n    || $env.N8N_ADAPTER_BASE_URL\n    || $env.N8N_APPROVAL_BASE_URL\n    || derivedBase\n    || '';\n\n  const base = (() => {\n    let base = String(baseRaw ?? '').trim().replace(/\\/+$/, '');\n    if (!base) return '';\n\n    const webhookIndex = base.indexOf('/webhook');\n    if (webhookIndex >= 0) {\n      base = base.slice(0, webhookIndex) + '/webhook';\n    } else {\n      base = base + '/webhook';\n    }\n\n    return base.replace(/\\/+$/, '');\n  })();\n\n  if (!base) return '';\n  return base + '/jobs/preview';\n})()}}",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { context_id: $json.context_id, actor: $json.actor, normalized_event: $json.normalized_event, iam_context: $json.iam_context, policy_context: $json.policy_context, rag_route: $json.rag_route, tool_calls: $json.tool_calls } }}",
        "options": {
          "timeout": 20000
        }
      },
      "id": "21",
      "name": "Call Orchestrator Preview",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1880,
        340
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{(() => {\n  let base = {};\n  try { base = $node[\"Build IAM & Policy Context\"].json; } catch (e) {}\n  if (!base || typeof base !== 'object' || Array.isArray(base)) base = {};\n  if (!base.normalized_event) {\n    try { base = $node[\"Normalize Duplicate Flag\"].json; } catch (e) {}\n  }\n  if (!base || typeof base !== 'object' || Array.isArray(base)) base = ($json || {});\n\n  const replyTarget = (base.reply_target && typeof base.reply_target === 'object') ? base.reply_target : {};\n  const normalized = (base.normalized_event && typeof base.normalized_event === 'object') ? base.normalized_event : {};\n  const source = normalized.source || base.source || replyTarget.source || 'unknown';\n  if (source !== 'zulip') return false;\n\n  let raw = '';\n  if (normalized.raw_body && typeof normalized.raw_body === 'object') {\n    raw = normalized.raw_body.data || (normalized.raw_body.message && normalized.raw_body.message.content) || '';\n  }\n  if (!raw) raw = normalized.text || '';\n\n  const stripHtml = (t) => String(t || '')\n    .replace(/<style[\\s\\S]*?>[\\s\\S]*?<\\/style>/gi, ' ')\n    .replace(/<script[\\s\\S]*?>[\\s\\S]*?<\\/script>/gi, ' ')\n    .replace(/<[^>]+>/g, ' ')\n    .replace(/&nbsp;/gi, ' ')\n    .replace(/&amp;/gi, '&')\n    .replace(/&lt;/gi, '<')\n    .replace(/&gt;/gi, '>')\n    .replace(/\\s+/g, ' ')\n    .trim();\n\n  const stripMention = (t) => String(t || '')\n    .replace(/^@\\*\\*[^*]+\\*\\*\\s*/, '')\n    .replace(/^@\\S+\\s*/, '');\n  const stripOqSuffix = (t) => String(t || '').replace(/\\s*\\(OQ-HELLO-[^)]+\\)\\s*$/i, '').trim();\n\n  const rawText = stripHtml(raw);\n  const text = stripOqSuffix(stripMention(String(rawText))).split(/\\r?\\n/)[0].trim();\n\n  const stream = replyTarget.stream || normalized.raw_body?.message?.display_recipient || normalized.raw_body?.display_recipient || '';\n  const topic = replyTarget.topic || normalized.raw_body?.message?.subject || normalized.raw_body?.subject || '';\n  const isOq = /^oq-/i.test(String(topic || '')) || String(stream || '') === '0perational Qualification' || /\\(OQ-HELLO-/i.test(rawText);\n\n  const isGreeting = (t) => /^\\s*(こんにちは|こんばんは|おはよう|hello|hi|やあ|はじめまして)(\\s|$)/i.test(t);\n  const isSmalltalk = (t) => /(雑談|世間話|元気|調子どう|眠い|寒い|暑い|ランチ|おすすめ)/.test(t);\n  const isRun = (t) => /^\\s*(run|request|execute)\\s+([A-Za-z0-9_.-]+)/i.test(t);\n\n  return (isOq || isGreeting(text) || isSmalltalk(text) || isRun(text));\n})()}}",
              "value2": true
            }
          ]
        }
      },
      "id": "if-zulip-response-mode",
      "name": "IF Zulip Response Mode (Fast)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1880,
        80
      ]
    },
    {
      "parameters": {
        "url": "={{(() => {\n  const webhookUrl = (() => {\n    const candidates = [\n      'Webhook (CloudWatch Ingest)',\n      'Webhook (Zulip Ingest)',\n      'Webhook (Ingest)'\n    ];\n\n    for (const name of candidates) {\n      try {\n        const node = $node[name];\n        const url = node && node.json && node.json.webhookUrl;\n        if (url) return String(url);\n      } catch (error) {\n        // ignore\n      }\n    }\n\n    return '';\n  })();\n\n  const derivedBase = webhookUrl ? webhookUrl.replace(/\\/webhook\\/.*/, '/webhook') : '';\n  const baseRaw = $env.N8N_ORCHESTRATOR_BASE_URL\n    || $env.N8N_WEBHOOK_BASE_URL\n    || $env.N8N_ORCHESTRATOR_BASE_URL\n    || $env.N8N_WEBHOOK_BASE_URL\n    || $env.N8N_ADAPTER_BASE_URL\n    || $env.N8N_APPROVAL_BASE_URL\n    || derivedBase\n    || '';\n\n  const base = (() => {\n    let base = String(baseRaw ?? '').trim().replace(/\\/+$/, '');\n    if (!base) return '';\n\n    const webhookIndex = base.indexOf('/webhook');\n    if (webhookIndex >= 0) {\n      base = base.slice(0, webhookIndex) + '/webhook';\n    } else {\n      base = base + '/webhook';\n    }\n\n    return base.replace(/\\/+$/, '');\n  })();\n\n  if (!base) return '';\n  return base + '/jobs/preview';\n})()}}",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { context_id: $json.context_id, actor: $json.actor, normalized_event: $json.normalized_event, iam_context: $json.iam_context, policy_context: $json.policy_context, rag_route: $json.rag_route, tool_calls: $json.tool_calls } }}",
        "options": {
          "timeout": 8000
        }
      },
      "id": "call-orchestrator-preview-zulip-fast",
      "name": "Call Orchestrator Preview (Zulip Fast)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2120,
        80
      ]
    },
    {
      "parameters": {
        "jsCode": "const base = $node['Build IAM & Policy Context']?.json ?? $node['Normalize Duplicate Flag']?.json ?? {};\nconst preview = $json ?? {};\n\nconst normalized = base.normalized_event ?? {};\nconst text = String(normalized.text ?? '').trim();\n\nconst nextAction = String(preview.next_action ?? base.next_action ?? '').trim();\nconst approvalToken = String(preview.approval_token ?? '').trim();\nconst expiresAt = String(preview.expires_at ?? '').trim();\nconst jobPlan = preview.job_plan ?? {};\nconst candidates = Array.isArray(preview.candidates) ? preview.candidates : [];\nconst questions = Array.isArray(preview.clarifying_questions) ? preview.clarifying_questions.map((v) => String(v ?? '').trim()).filter(Boolean) : [];\n\nconst isDuplicate = Boolean(base.is_duplicate);\nif (isDuplicate) {\n  return [{ json: { ...base, ...preview, content: '' } }];\n}\n\nlet interactionGrammar = null;\ntry {\n  interactionGrammar = JSON.parse(\"__POLICY__INTERACTION_GRAMMAR__\");\n} catch (error) {\n  interactionGrammar = null;\n}\n\nconst templates = interactionGrammar?.approval?.templates ?? {};\nconst approveCmd = approvalToken ? `approve ${approvalToken}` : (templates.approve ?? 'approve <token>');\nconst denyCmd = approvalToken ? `deny ${approvalToken}` : (templates.deny ?? 'deny <token>');\n\nconst greeting = () => {\n  if (/こんばんは/.test(text)) return 'こんばんは！';\n  if (/おはよう/.test(text)) return 'おはようございます！';\n  return 'こんにちは！';\n};\n\nlet content = '';\nif (nextAction === 'reply_only') {\n  content = `${greeting()} 何かお手伝いできることがあれば教えてください。`;\n} else if (nextAction === 'require_approval') {\n  const workflowId = String(jobPlan.workflow_id ?? candidates?.[0]?.workflow_id ?? '').trim();\n  const summary = String(jobPlan.summary ?? candidates?.[0]?.summary ?? '').trim();\n  const header = workflowId ? `実行候補: ${workflowId}` : '実行候補を確認しました';\n  const summaryLine = summary ? `\\n概要: ${summary}` : '';\n  const expLine = expiresAt ? `\\n有効期限: ${expiresAt}` : '';\n  content = `${header}${summaryLine}\\n\\n承認が必要です。次のいずれかを実行してください:\\n${approveCmd}\\n${denyCmd}${expLine}`;\n} else if (nextAction === 'ask_clarification') {\n  const qs = questions.length ? questions.slice(0, 2) : ['実行したい内容（ワークフローIDとパラメータ）を教えてください。'];\n  const firstLine = text.split(/\\r?\\n/)[0].trim();\n  const known = firstLine ? `- 依頼: ${firstLine}` : '- （情報が不足しています）';\n  content = `今わかっていること\\n${known}\\n\\n不明点\\n- ${qs.join('\\n- ')}`;\n} else if (nextAction === 'reject') {\n  content = 'この依頼は受理できませんでした（ポリシーにより拒否）。';\n} else {\n  content = `受け付けました（next_action=${nextAction || 'unknown'}）。`;\n}\n\nreturn [{ json: { ...base, ...preview, content } }];\n"
      },
      "id": "build-zulip-response-content-fast",
      "name": "Build Zulip Response Content (Fast)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2360,
        80
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst base = $node['Build IAM & Policy Context']?.json ?? $node['Normalize Duplicate Flag']?.json ?? $json ?? {};\nconst normalized = base.normalized_event ?? {};\nconst policy = base.policy_context ?? {};\n\nconst textRaw = String(normalized.raw_body?.data ?? normalized.raw_body?.message?.content ?? normalized.text ?? '').trim();\n\nconst stripHtml = (t) => String(t ?? '')\n  .replace(/<style[\\s\\S]*?>[\\s\\S]*?<\\/style>/gi, ' ')\n  .replace(/<script[\\s\\S]*?>[\\s\\S]*?<\\/script>/gi, ' ')\n  .replace(/<[^>]+>/g, ' ')\n  .replace(/&nbsp;/gi, ' ')\n  .replace(/&amp;/gi, '&')\n  .replace(/&lt;/gi, '<')\n  .replace(/&gt;/gi, '>')\n  .replace(/\\s+/g, ' ')\n  .trim();\n\nconst textPlain = stripHtml(textRaw);\nconst contextId = String(base.context_id ?? '').trim();\nconst actor = base.actor ?? {};\n\nconst stripMention = (t) => String(t ?? '')\n  .replace(/^@\\*\\*[^*]+\\*\\*\\s*/, '')\n  .replace(/^@\\S+\\s*/, '');\n\nconst stripOqSuffix = (t) => String(t ?? '').replace(/\\s*\\(OQ-HELLO-[^)]+\\)\\s*$/i, '').trim();\n\nconst textWithContext = stripOqSuffix(stripMention(textPlain));\nconst text = String(textWithContext).split(/\\r?\\n/)[0].trim();\n\nconst isDuplicate = Boolean(base.is_duplicate);\nif (isDuplicate) {\n  return [{ json: { ...base, candidates: [], job_plan: {}, next_action: 'reply_only', required_confirm: false, approval_id: null, approval_token: null, token_nonce: null, expires_at: null, preview_facts: {}, content: '' } }];\n}\n\nconst defaults = policy?.defaults?.jobs_preview ?? {};\nconst approvalDoc = policy?.approval_policy_doc ?? {};\n\nconst ttlSecondsRaw = approvalDoc?.token?.ttl_seconds ?? $env.N8N_APPROVAL_TOKEN_TTL_SECONDS ?? 900;\nconst ttlSeconds = (typeof ttlSecondsRaw === 'number' && Number.isFinite(ttlSecondsRaw))\n  ? Math.max(1, Math.floor(ttlSecondsRaw))\n  : Math.max(1, Math.floor(Number(ttlSecondsRaw) || 900));\n\nconst isGreeting = (t) => /^\\s*(こんにちは|こんばんは|おはよう|hello|hi|やあ|はじめまして)(\\s|$)/i.test(t);\nconst isSmalltalk = (t) => /(雑談|世間話|元気|調子どう|眠い|寒い|暑い|ランチ|おすすめ)/.test(t);\n\nconst parseRun = (t) => {\n  const trimmed = String(t ?? '').trim();\n  const m = trimmed.match(/^\\s*(run|request|execute)\\s+([A-Za-z0-9_.-]+)(?:\\s+(.*))?$/i);\n  if (!m) return null;\n  const workflowId = m[2];\n  const rest = String(m[3] ?? '').trim();\n  let params = {};\n  if (rest) {\n    const idx = rest.indexOf('{');\n    if (idx >= 0) {\n      try {\n        const parsed = JSON.parse(rest.slice(idx));\n        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n          params = parsed;\n        }\n      } catch (error) {\n        // ignore\n      }\n    }\n  }\n  return { workflow_id: workflowId, params };\n};\n\nlet interactionGrammar = null;\ntry {\n  interactionGrammar = JSON.parse(\"__POLICY__INTERACTION_GRAMMAR__\");\n} catch (error) {\n  interactionGrammar = null;\n}\n\nconst templates = interactionGrammar?.approval?.templates ?? {};\n\nconst greeting = () => {\n  if (/こんばんは/.test(text)) return 'こんばんは！';\n  if (/おはよう/.test(text)) return 'おはようございます！';\n  return 'こんにちは！';\n};\n\nif (!text || isGreeting(text) || isSmalltalk(text)) {\n  const content = `${greeting()} 何かお手伝いできることがあれば教えてください。`;\n  return [{ json: { ...base, candidates: [], job_plan: {}, next_action: 'reply_only', required_confirm: false, approval_id: null, approval_token: null, token_nonce: null, expires_at: null, preview_facts: {}, content } }];\n}\n\nconst run = parseRun(text);\nif (!run || !run.workflow_id) {\n  const content = 'API の件ですね。まず状況整理から始めます。\\n- 発生し始めた時刻/直前の変更（デプロイ/設定/DB 等）\\n- 影響範囲（全ユーザー/一部）\\n- 502 の発生箇所（ALB/アプリ/上流）\\n- 関連ログ/メトリクス（5xx, latency, upstream health）\\n分かる範囲で教えてください。';\n  return [{ json: { ...base, candidates: [], job_plan: {}, next_action: 'reply_only', required_confirm: false, approval_id: null, approval_token: null, token_nonce: null, expires_at: null, preview_facts: {}, content } }];\n}\n\nconst secret = $env.N8N_APPROVAL_HMAC_SECRET_NAME;\nif (!secret) {\n  const content = '承認トークンを発行できませんでした（N8N_APPROVAL_HMAC_SECRET_NAME 未設定）。';\n  return [{ json: { ...base, candidates: [], job_plan: {}, next_action: 'ask_clarification', required_confirm: true, approval_id: null, approval_token: null, token_nonce: null, expires_at: null, preview_facts: {}, clarifying_questions: ['実行環境の設定を確認してください'], content } }];\n}\n\nconst approvalId = crypto.randomUUID();\nconst tokenNonce = crypto.randomBytes(16).toString('hex');\nconst expiresAt = new Date(Date.now() + ttlSeconds * 1000).toISOString();\n\nconst jobPlan = {\n  workflow_id: run.workflow_id,\n  params: run.params ?? {},\n  trace_id: normalized.trace_id ?? null,\n  summary: `workflow=${run.workflow_id}`,\n  required_roles: [],\n  required_groups: [],\n  risk_level: defaults.risk_level ?? 'medium',\n  impact_scope: defaults.impact_scope ?? 'service',\n  missing_params: []\n};\n\nconst tokenPayload = {\n  approval_id: approvalId,\n  context_id: contextId,\n  workflow_id: jobPlan.workflow_id,\n  params: jobPlan.params ?? {},\n  actor,\n  token_nonce: tokenNonce,\n  expires_at: expiresAt\n};\n\nconst signature = crypto.createHmac('sha256', secret)\n  .update(JSON.stringify(tokenPayload))\n  .digest('hex');\n\nconst approvalToken = Buffer.from(JSON.stringify({ ...tokenPayload, signature })).toString('base64url');\n\nconst approveCmd = `approve ${approvalToken}`;\nconst denyCmd = `deny ${approvalToken}`;\nconst content = `実行候補: ${jobPlan.workflow_id}\\n\\n承認が必要です。次のいずれかを実行してください:\\n${approveCmd}\\n${denyCmd}\\n有効期限: ${expiresAt}`;\n\nreturn [{\n  json: {\n    ...base,\n    candidates: [{\n      workflow_id: jobPlan.workflow_id,\n      params: jobPlan.params,\n      summary: jobPlan.summary,\n      required_roles: [],\n      required_groups: [],\n      risk_level: jobPlan.risk_level,\n      impact_scope: jobPlan.impact_scope,\n      ambiguity_score: 0\n    }],\n    preview_facts: {},\n    job_plan: jobPlan,\n    next_action: 'require_approval',\n    required_confirm: true,\n    approval_id: approvalId,\n    approval_token: approvalToken,\n    token_nonce: tokenNonce,\n    expires_at: expiresAt,\n    approval: { approval_id: approvalId, expires_at: expiresAt, token: approvalToken },\n    content\n  }\n}];\n"
      },
      "id": "fast-zulip-response-build",
      "name": "Fast Zulip Response (Build)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2120,
        -40
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ !!$json.approval_id }}",
              "value2": true
            }
          ]
        }
      },
      "id": "if-save-pending-approval-zulip",
      "name": "IF Save Pending Approval (Zulip)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2360,
        -40
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH v AS (\n  SELECT\n    NULLIF(NULLIF('{{$json.approval_id}}', ''), 'null')::uuid AS approval_id,\n    NULLIF(NULLIF('{{$json.context_id}}',''), 'undefined')::uuid AS context_id,\n    COALESCE(NULLIF('{{ JSON.stringify($json.job_plan || {}) }}','undefined')::jsonb, '{}'::jsonb) AS job_plan,\n    COALESCE(NULLIF(NULLIF(NULLIF('{{$json.required_confirm}}',''), 'undefined'), 'null')::boolean, false) AS required_confirm,\n    NULLIF(NULLIF('{{$json.token_nonce}}', ''), 'null') AS token_nonce,\n    NULLIF(NULLIF('{{$json.expires_at}}', ''), 'null')::timestamptz AS expires_at,\n    COALESCE(NULLIF('{{ JSON.stringify($json.candidates || []) }}','undefined')::jsonb, '[]'::jsonb) AS candidates,\n    COALESCE(NULLIF('{{ JSON.stringify($json.preview_facts || {}) }}','undefined')::jsonb, '{}'::jsonb) AS preview_facts,\n    NULLIF(NULLIF('{{$json.approval_token}}', ''), 'null') AS approval_token\n), ctx AS (\n  SELECT 1 AS ok\n  FROM aiops_context c\n  WHERE c.context_id = (SELECT context_id FROM v)\n  LIMIT 1\n), ins AS (\n  INSERT INTO aiops_pending_approvals (approval_id, context_id, job_plan, required_confirm, token_nonce, expires_at)\n  SELECT v.approval_id, v.context_id, v.job_plan, v.required_confirm, v.token_nonce, v.expires_at\n  FROM v\n  WHERE v.approval_id IS NOT NULL AND v.context_id IS NOT NULL\n    AND EXISTS (SELECT 1 FROM ctx)\n  ON CONFLICT (approval_id) DO NOTHING\n  RETURNING approval_id\n)\nSELECT\n  v.approval_id,\n  v.context_id,\n  v.job_plan,\n  v.required_confirm,\n  v.token_nonce,\n  v.expires_at,\n  v.candidates,\n  v.preview_facts,\n  v.approval_token,\n  EXISTS (SELECT 1 FROM ctx) AS context_exists,\n  EXISTS (SELECT 1 FROM ins) AS inserted\nFROM v;"
      },
      "id": "save-pending-approval-zulip",
      "name": "Save Pending Approval (Zulip)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        2600,
        -40
      ]
    },
    {
      "parameters": {
        "jsCode": "return $items('Fast Zulip Response (Build)');\n"
      },
      "id": "restore-items-after-save-pending-zulip",
      "name": "Restore Items After Save Pending (Zulip)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2840,
        -40
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.next_action}}",
              "value2": "auto_enqueue",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "22",
      "name": "IF Required Confirm",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2120,
        340
      ]
    },
    {
      "parameters": {
        "url": "={{(() => {\n  const webhookUrl = (() => {\n    const candidates = [\n      'Webhook (CloudWatch Ingest)',\n      'Webhook (Zulip Ingest)',\n      'Webhook (Ingest)'\n    ];\n\n    for (const name of candidates) {\n      try {\n        const node = $node[name];\n        const url = node && node.json && node.json.webhookUrl;\n        if (url) return String(url);\n      } catch (error) {\n        // ignore\n      }\n    }\n\n    return '';\n  })();\n\n  const derivedBase = webhookUrl ? webhookUrl.replace(/\\/webhook\\/.*/, '/webhook') : '';\n  const baseRaw = derivedBase\n    || $env.N8N_ORCHESTRATOR_BASE_URL\n    || $env.N8N_WEBHOOK_BASE_URL\n    || $env.N8N_ADAPTER_BASE_URL\n    || $env.N8N_APPROVAL_BASE_URL\n    || '';\n\n  const base = (() => {\n    let base = String(baseRaw ?? '').trim().replace(/\\/+$/, '');\n    if (!base) return '';\n\n    const webhookIndex = base.indexOf('/webhook');\n    if (webhookIndex >= 0) {\n      base = base.slice(0, webhookIndex) + '/webhook';\n    } else {\n      base = base + '/webhook';\n    }\n\n    const m = base.match(/^https?:\\/\\/([^/]+):5678(\\/|$)/);\n    if (m) {\n      const host = m[1];\n      const isLocal = host === 'localhost'\n        || host === '127.0.0.1'\n        || /^10\\./.test(host)\n        || /^192\\.168\\./.test(host)\n        || /^172\\.(1[6-9]|2\\d|3[0-1])\\./.test(host);\n      if (isLocal) {\n        base = base.replace(/^https:\\/\\//, 'http://');\n      } else {\n        base = base.replace(/^https?:\\/\\/([^/]+):5678(\\/|$)/, 'https://$1$2');\n      }\n    }\n\n    return base.replace(/\\/+$/, '');\n  })();\n\n  if (!base) return '';\n  return base + '/jobs/job-engine/enqueue';\n})()}}",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { context_id: $json.context_id, job_plan: $json.job_plan, approval_token: $json.approval_token, source: $json.source, reply_target: $json.reply_target, actor: $json.actor, normalized_event: $json.normalized_event } }}",
        "options": {
          "timeout": 20000
        }
      },
      "id": "23",
      "name": "Enqueue Job",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2360,
        460
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE aiops_context\nSET normalized_event = normalized_event || jsonb_build_object('job_id', '{{ $json.job_id }}')\nWHERE context_id = NULLIF(NULLIF('{{ $json.context_id }}',''), 'undefined')::uuid;"
      },
      "id": "24",
      "name": "Context Store (job_id)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        2600,
        460
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const normalized = $json.normalized_event ?? {};\nconst policyContext = $json.policy_context\n  ?? $node['Build IAM & Policy Context']?.json?.policy_context\n  ?? {};\nconst defaults = policyContext?.defaults?.adapter_classify ?? {};\nconst fallbacks = policyContext?.fallbacks?.adapter_classify ?? {};\nconst fallbackClassification = fallbacks.classification ?? {};\n\n// LLM 分類が失敗した場合のフォールバックは policy_context を正とする。\nnormalized.classification = {\n  category: fallbackClassification.category ?? defaults.category ?? 'incident',\n  form: fallbackClassification.form ?? defaults.form ?? 'non_standard',\n  subtype: fallbackClassification.subtype ?? defaults.subtype ?? 'triage'\n};\n\nnormalized.impacted_resources = Array.isArray(normalized.impacted_resources)\n  ? normalized.impacted_resources\n  : [];\n\nnormalized.impact = normalized.impact ?? fallbacks.impact ?? defaults.impact ?? 'medium';\nnormalized.urgency = normalized.urgency ?? fallbacks.urgency ?? defaults.urgency ?? 'medium';\nnormalized.priority = normalized.priority ?? fallbacks.priority ?? defaults.priority ?? 'p3';\n\nif (typeof fallbacks.needs_clarification === 'boolean') {\n  normalized.needs_clarification = fallbacks.needs_clarification;\n} else if (typeof defaults.needs_clarification === 'boolean') {\n  normalized.needs_clarification = defaults.needs_clarification;\n}\n\nnormalized.llm_classification = {\n  confidence: typeof fallbacks.confidence === 'number' ? fallbacks.confidence : 0,\n  rationale: fallbacks.rationale ?? 'LLM分類に失敗したため、暫定フォールバックを適用'\n};\n\nreturn [{ json: { ...$json, normalized_event: normalized } }];\n"
      },
      "id": "26",
      "name": "Classify Event (Basic)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1880,
        200
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE aiops_context\nSET normalized_event = normalized_event || COALESCE(NULLIF('{{ JSON.stringify($json.normalized_event || {}) }}','undefined')::jsonb, '{}'::jsonb)\nWHERE context_id = NULLIF(NULLIF('{{ $json.context_id }}',''), 'undefined')::uuid;"
      },
      "id": "27",
      "name": "Update Normalized Event",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        2100,
        200
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const base = $json ?? {};\nconst preview = base ?? {};\n\nreturn [{\n  json: {\n    ...base,\n    ...preview,\n    job_plan: preview.job_plan ?? {},\n    required_confirm: base.required_confirm ?? null,\n    approval_id: preview.approval_id ?? null,\n    approval_token: preview.approval_token ?? null,\n    expires_at: preview.expires_at ?? null,\n    job_id: null\n  }\n}];\n"
      },
      "id": "28",
      "name": "Build Approval Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2340,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const merged = $node['Merge Preview with Chat Core']?.json ?? {};\nconst base = { ...merged, ...($json ?? {}) };\nconst enqueue = $node['Enqueue Job'].json ?? {};\n\nreturn [{\n  json: {\n    ...base,\n    job_plan: merged.job_plan ?? base.job_plan ?? {},\n    required_confirm: merged.required_confirm ?? base.required_confirm ?? null,\n    approval_id: merged.approval_id ?? base.approval_id ?? null,\n    approval_token: merged.approval_token ?? base.approval_token ?? null,\n    expires_at: merged.expires_at ?? base.expires_at ?? null,\n    job_id: enqueue.job_id ?? base.job_id ?? null,\n    context_id: enqueue.context_id ?? base.context_id\n  }\n}];\n"
      },
      "id": "29",
      "name": "Build Auto-Enqueue Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2840,
        460
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.reply_target?.source ?? $json.source ?? 'unknown' }}",
              "value2": "zulip",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "30",
      "name": "IF Zulip Source (Ingest)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2520,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const target = $json.reply_target ?? {};\nconst type = target.type === 'private' ? 'private' : 'stream';\nconst tenant = (target.tenant ?? target.realm ?? '').trim();\n\nconst parseYaml = (text) => {\n  const map = {};\n  String(text).split(/\\r?\\n/).forEach((line) => {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed.startsWith('#')) return;\n    const idx = trimmed.indexOf(':');\n    if (idx <= 0) return;\n    const key = trimmed.slice(0, idx).trim();\n    let value = trimmed.slice(idx + 1).trim();\n    if (!key) return;\n    value = value.replace(/^['\"]|['\"]$/g, '');\n    map[key] = value;\n  });\n  return map;\n};\n\nconst parseMap = (jsonRaw, yamlRaw) => {\n  let map = {};\n  if (jsonRaw) {\n    try {\n      const parsed = JSON.parse(jsonRaw);\n      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n        map = parsed;\n      }\n    } catch (error) {}\n  }\n  if (!Object.keys(map).length && yamlRaw) {\n    map = parseYaml(yamlRaw);\n  }\n  return map;\n};\n\nconst apiBaseUrlMap = parseMap(\n  $env.ZULIP_API_MESS_BASE_URL || $env.N8N_ZULIP_API_BASE_URL || '',\n  $env.ZULIP_API_MESS_BASE_URL || $env.N8N_ZULIP_API_BASE_URL || ''\n);\nconst emailMap = parseMap(\n  $env.ZULIP_MESS_BOT_EMAIL || $env.N8N_ZULIP_BOT_EMAIL || '',\n  $env.ZULIP_MESS_BOT_EMAIL || $env.N8N_ZULIP_BOT_EMAIL || ''\n);\nconst tokenMap = parseMap(\n  $env.ZULIP_MESS_BOT_TOKEN || $env.N8N_ZULIP_BOT_TOKEN || '',\n  ($env.ZULIP_MESS_BOT_TOKEN || $env.ZULIP_BOT_TOKEN || $env.N8N_ZULIP_BOT_TOKEN || '')\n);\n\nconst fallbackBase = ($env.ZULIP_BASE_URL || $env.ZULIP_API_MESS_BASE_URL || $env.N8N_ZULIP_API_BASE_URL || $env.ZULIP_API_BASE_URL || '').trim();\nconst fallbackEmail = ($env.ZULIP_MESS_BOT_EMAIL || $env.N8N_ZULIP_BOT_EMAIL || $env.ZULIP_BOT_EMAIL || '').trim();\nconst fallbackToken = ($env.ZULIP_MESS_BOT_TOKEN || $env.ZULIP_BOT_API_KEY || $env.N8N_ZULIP_BOT_TOKEN || $env.ZULIP_BOT_TOKEN || '').trim();\n\nconst baseUrl = (tenant && apiBaseUrlMap[tenant]) ? apiBaseUrlMap[tenant] : (apiBaseUrlMap.default || fallbackBase);\nconst email = (tenant && emailMap[tenant]) ? emailMap[tenant] : (emailMap.default || fallbackEmail);\nconst token = (tenant && tokenMap[tenant]) ? tokenMap[tenant] : (tokenMap.default || fallbackToken);\n\nconst trimmedBase = baseUrl ? String(baseUrl).replace(/\\/+$/, '') : '';\nif (!trimmedBase || !email || !token) {\n  return [{\n    json: {\n      ...$json,\n      zulip_post: {\n        ok: false,\n        skipped: true,\n        reason: !trimmedBase ? 'missing_base_url' : 'missing_credentials'\n      }\n    }\n  }];\n}\n\nconst apiBase = trimmedBase.endsWith('/api/v1') ? trimmedBase : (trimmedBase + '/api/v1');\nconst url = apiBase + '/messages';\n\nconst content = String($json.content ?? '').trim();\nif (!content) {\n  return [{\n    json: {\n      ...$json,\n      zulip_post: {\n        ok: false,\n        skipped: true,\n        reason: 'empty_content'\n      }\n    }\n  }];\n}\n\nconst encode = (value) => encodeURIComponent(String(value ?? ''));\nconst parts = [];\nparts.push('type=' + encode(type));\nparts.push('content=' + encode(content));\nif (type === 'private') {\n  const recipients = (Array.isArray(target.recipients) && target.recipients.length > 0)\n    ? target.recipients\n    : ($json.actor?.email ? [$json.actor.email] : []);\n  parts.push('to=' + encode(JSON.stringify(recipients)));\n} else {\n  if (!target.stream) {\n    return [{\n      json: {\n        ...$json,\n        zulip_post: {\n          ok: false,\n          skipped: true,\n          reason: 'missing_stream'\n        }\n      }\n    }];\n  }\n  parts.push('to=' + encode(String(target.stream)));\n  parts.push('topic=' + encode(String(target.topic ?? '')));\n}\nconst body = parts.join('&');\n\nconst authHeader = 'Basic ' + Buffer.from(email + ':' + token).toString('base64');\n\ntry {\n  await this.helpers.httpRequest({\n    method: 'POST',\n    url,\n    headers: { Authorization: authHeader, 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: body,\n    json: true\n  });\n} catch (error) {\n  return [{\n    json: {\n      ...$json,\n      zulip_post: {\n        ok: false,\n        error: String(error?.message ?? error)\n      }\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    ...$json,\n    zulip_post: { ok: true }\n  }\n}];\n"
      },
      "id": "31",
      "name": "Post to Zulip (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2740,
        120
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.reply_target?.source ?? '' }}",
              "value2": "slack",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "32",
      "name": "IF Slack Source (Ingest)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2740,
        240
      ]
    },
    {
      "parameters": {
        "url": "https://slack.com/api/chat.postMessage",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ (() => { const payload = { channel: $json.reply_target?.channel ?? $json.reply_target?.channel_id, text: $json.content }; if ($json.reply_target?.thread_ts) payload.thread_ts = $json.reply_target.thread_ts; return payload; })() }}",
        "options": {
          "headers": {
            "Authorization": "Bearer {{$env.SLACK_BOT_TOKEN}}",
            "Content-Type": "application/json"
          }
        }
      },
      "id": "33",
      "name": "Post to Slack (Ingest)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        2960,
        240
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.reply_target?.source ?? '' }}",
              "value2": "mattermost",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "34",
      "name": "IF Mattermost Source (Ingest)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2960,
        360
      ]
    },
    {
      "parameters": {
        "url": "={{ ($env.MATTERMOST_API_BASE_URL ?? 'https://mattermost.example.com') + '/api/v4/posts' }}",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { channel_id: $json.reply_target?.channel_id ?? $json.reply_target?.channel, message: $json.content } }}",
        "options": {
          "headers": {
            "Authorization": "Bearer {{$env.MATTERMOST_BOT_TOKEN}}",
            "Content-Type": "application/json"
          }
        }
      },
      "id": "35",
      "name": "Post to Mattermost (Ingest)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        3160,
        360
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.reply_target?.source ?? '' }}",
              "value2": "teams",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "36",
      "name": "IF Teams Source (Ingest)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        3160,
        480
      ]
    },
    {
      "parameters": {
        "url": "={{ ($json.reply_target?.service_url ?? 'https://smba.trafficmanager.net/teams/') + 'v3/conversations/' + ($json.reply_target?.conversation_id ?? '') + '/activities' }}",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { type: 'message', text: $json.content } }}",
        "options": {
          "headers": {
            "Authorization": "Bearer {{$env.N8N_TEAMS_BOT_TOKEN}}",
            "Content-Type": "application/json"
          }
        }
      },
      "id": "37",
      "name": "Post to Teams (Ingest)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        3360,
        480
      ]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "message",
              "value": "={{ `Unknown reply target source ${$json.reply_target?.source ?? \"unknown\"}` }}"
            },
            {
              "name": "reply_target",
              "value": "={{ $json.reply_target }}"
            }
          ]
        },
        "options": {}
      },
      "id": "38",
      "name": "Log Unknown Source (Ingest)",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [
        3360,
        600
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst normalizedEvent = { ...($json.normalized_event ?? {}) };\ndelete normalizedEvent.raw_headers;\ndelete normalizedEvent.raw_body;\n\nconst input = {\n  normalized_event: normalizedEvent,\n  actor: $json.actor ?? {},\n  reply_target: $json.reply_target ?? {},\n  iam_context: $json.iam_context ?? {},\n  policy_context: $json.policy_context ?? {}\n};\n\nconst promptText = \"__PROMPT__ADAPTER_CLASSIFY__\";\nconst promptHash = crypto.createHash('sha256').update(promptText).digest('hex');\n\nreturn [{\n  json: {\n    ...$json,\n    prompt_key: 'adapter.classify.v1',\n    prompt_version: 'ja-1',\n    prompt_text: promptText,\n    prompt_hash: promptHash,\n    prompt_input: JSON.stringify(input)\n  }\n}];\n"
      },
      "id": "39",
      "name": "Build Classification Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        660
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO aiops_prompt_history (prompt_key, prompt_version, prompt_text, prompt_hash, source_workflow, source_node)\nVALUES (\n  '{{ String($json.prompt_key ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_version ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_text ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_hash ?? \"\").replace(/'/g, \"''\") }}',\n  'aiops-adapter-ingest',\n  'OpenAI Classify Event'\n)\nON CONFLICT (prompt_key, prompt_hash) DO NOTHING;"
      },
      "id": "40",
      "name": "Record Prompt History (Classify)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        1120,
        660
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "operation": "complete",
        "model": "={{$env.OPENAI_MODEL || 'gpt-4o-mini'}}",
        "prompt": {
          "messages": [
            {
              "role": "system",
              "content": "={{ $node['Build Classification Prompt (JP)'].json.prompt_text }}"
            },
            {
              "role": "user",
              "content": "={{ '入力:\\n' + $node['Build Classification Prompt (JP)'].json.prompt_input }}"
            }
          ]
        },
        "options": {
          "temperature": 0.2,
          "baseURL": "={{$env.OPENAI_BASE_URL}}",
          "maxTokens": "={{$json.policy_context?.limits?.llm_output_tokens || 1200}}"
        }
      },
      "id": "41",
      "name": "OpenAI Classify Event",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        1340,
        660
      ],
      "credentials": {
        "openAiApi": {
          "name": "aiops-openai"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "const base = $node['Build Classification Prompt (JP)'].json ?? {};\nconst response = $json ?? {};\n\nconst extractContent = (payload) => {\n  return payload?.message?.content\n    ?? payload?.choices?.[0]?.message?.content\n    ?? payload?.choices?.[0]?.text\n    ?? payload?.data?.choices?.[0]?.message?.content\n    ?? payload?.data?.choices?.[0]?.text\n    ?? payload?.content\n    ?? '';\n};\n\nconst rawContent = extractContent(response);\nlet parsed = null;\nif (typeof rawContent === 'string') {\n  try {\n    parsed = JSON.parse(rawContent);\n  } catch (error) {\n    const match = rawContent.match(/\\{[\\s\\S]*\\}/);\n    if (match) {\n      try {\n        parsed = JSON.parse(match[0]);\n      } catch (inner) {\n        parsed = null;\n      }\n    }\n  }\n}\n\nif (!parsed || typeof parsed !== 'object') {\n  return [{ json: { ...base, llm_ok: false, llm_error: 'invalid_llm_response' } }];\n}\n\nconst policyContext = base.policy_context ?? {};\nconst limits = policyContext?.limits?.adapter_classify ?? {};\nconst maxImpacted = Number.isFinite(Number(limits.max_impacted_resources))\n  ? Math.max(0, Math.floor(Number(limits.max_impacted_resources)))\n  : null;\n\nconst normalized = { ...(base.normalized_event ?? {}) };\nconst classification = { ...(normalized.classification ?? {}) };\n\nif (parsed.form) classification.form = String(parsed.form).toLowerCase();\nif (parsed.category) classification.category = String(parsed.category).toLowerCase();\nif (parsed.subtype) classification.subtype = String(parsed.subtype);\n\nnormalized.classification = classification;\nif (Array.isArray(parsed.impacted_resources)) {\n  const resources = parsed.impacted_resources.filter((v) => v !== null && v !== undefined);\n  normalized.impacted_resources = maxImpacted === null ? resources : resources.slice(0, maxImpacted);\n}\nif (parsed.impact) normalized.impact = String(parsed.impact).toLowerCase();\nif (parsed.urgency) normalized.urgency = String(parsed.urgency).toLowerCase();\nif (parsed.priority) normalized.priority = String(parsed.priority).toLowerCase();\nif (parsed.extracted_params) normalized.extracted_params = parsed.extracted_params;\nif (typeof parsed.needs_clarification === 'boolean') normalized.needs_clarification = parsed.needs_clarification;\nif (Array.isArray(parsed.clarifying_questions)) {\n  normalized.clarifying_questions = parsed.clarifying_questions;\n}\n\nnormalized.llm_classification = {\n  confidence: parsed.confidence ?? null,\n  rationale: parsed.rationale ?? null\n};\n\nreturn [{\n  json: {\n    ...base,\n    normalized_event: normalized,\n    llm_ok: true,\n    llm_output: parsed\n  }\n}];\n"
      },
      "id": "42",
      "name": "Parse Classification Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1560,
        660
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.llm_ok}}",
              "value2": true,
              "operation": "equal"
            }
          ]
        }
      },
      "id": "43",
      "name": "IF LLM Classified",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1780,
        660
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$env.N8N_DISABLE_PROMPT_OVERRIDE === 'true' || $env.N8N_DISABLE_PROMPT_OVERRIDE === '1'}}",
              "value2": true,
              "operation": "equal"
            }
          ]
        }
      },
      "id": "44",
      "name": "IF Prompt Override (Classify)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        900,
        560
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT prompt_text, prompt_version, prompt_hash\nFROM aiops_prompt_history\nWHERE prompt_key = {{$json.prompt_key}}\nORDER BY created_at DESC\nLIMIT 1;"
      },
      "id": "45",
      "name": "Load Prompt History (Classify)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        1120,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const base = $node['Build Classification Prompt (JP)'].json ?? {};\nconst row = ($json && $json.prompt_text) ? $json : ($json?.[0] ?? {});\nconst promptText = row.prompt_text ?? base.prompt_text;\nconst promptVersion = row.prompt_version ?? base.prompt_version;\nconst promptHash = row.prompt_hash ?? base.prompt_hash;\n\nreturn [{\n  json: {\n    ...base,\n    prompt_text: promptText,\n    prompt_version: promptVersion,\n    prompt_hash: promptHash,\n    prompt_from_history: Boolean(row.prompt_text)\n  }\n}];\n"
      },
      "id": "46",
      "name": "Apply Stored Prompt (Classify)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1340,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst base = $json ?? {};\nconst normalizedEvent = { ...(base.normalized_event ?? {}) };\ndelete normalizedEvent.raw_headers;\ndelete normalizedEvent.raw_body;\n\nconst input = {\n  normalized_event: normalizedEvent,\n  actor: base.actor ?? {},\n  reply_target: base.reply_target ?? {},\n  iam_context: base.iam_context ?? {},\n  policy_context: base.policy_context ?? {}\n};\n\nconst promptText = \"__PROMPT__CONTEXT_SUMMARY__\";\nconst promptHash = crypto.createHash('sha256').update(promptText).digest('hex');\n\nreturn [{\n  json: {\n    ...base,\n    prompt_key: 'adapter.enrichment_summary.v1',\n    prompt_version: 'ja-1',\n    prompt_text: promptText,\n    prompt_hash: promptHash,\n    prompt_input: JSON.stringify(input)\n  }\n}];\n"
      },
      "id": "47",
      "name": "Build Summary Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        940,
        820
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO aiops_prompt_history (prompt_key, prompt_version, prompt_text, prompt_hash, source_workflow, source_node)\nVALUES (\n  '{{ String($json.prompt_key ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_version ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_text ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_hash ?? \"\").replace(/'/g, \"''\") }}',\n  'aiops-adapter-ingest',\n  'OpenAI Context Summary'\n)\nON CONFLICT (prompt_key, prompt_hash) DO NOTHING;"
      },
      "id": "48",
      "name": "Record Prompt History (Summary)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        1160,
        820
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "operation": "complete",
        "model": "={{$env.OPENAI_MODEL || 'gpt-4o-mini'}}",
        "prompt": {
          "messages": [
            {
              "role": "system",
              "content": "={{ $node['Build Summary Prompt (JP)'].json.prompt_text }}"
            },
            {
              "role": "user",
              "content": "={{ '入力:\\n' + $node['Build Summary Prompt (JP)'].json.prompt_input }}"
            }
          ]
        },
        "options": {
          "temperature": 0.2,
          "baseURL": "={{$env.OPENAI_BASE_URL}}",
          "maxTokens": "={{$json.policy_context?.limits?.llm_output_tokens || 1200}}"
        }
      },
      "id": "49",
      "name": "OpenAI Context Summary",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        1380,
        820
      ],
      "credentials": {
        "openAiApi": {
          "name": "aiops-openai"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "const base = $node['Build Summary Prompt (JP)'].json ?? {};\nconst response = $json ?? {};\n\nconst extractContent = (payload) => {\n  return payload?.message?.content\n    ?? payload?.choices?.[0]?.message?.content\n    ?? payload?.choices?.[0]?.text\n    ?? payload?.data?.choices?.[0]?.message?.content\n    ?? payload?.data?.choices?.[0]?.text\n    ?? payload?.content\n    ?? '';\n};\n\nconst rawContent = extractContent(response);\nlet parsed = null;\nif (typeof rawContent === 'string') {\n  try {\n    parsed = JSON.parse(rawContent);\n  } catch (error) {\n    const match = rawContent.match(/\\{[\\s\\S]*\\}/);\n    if (match) {\n      try {\n        parsed = JSON.parse(match[0]);\n      } catch (inner) {\n        parsed = null;\n      }\n    }\n  }\n}\n\nif (!parsed || typeof parsed !== 'object' || !parsed.summary) {\n  return [{ json: { ...base, llm_ok: false, llm_error: 'invalid_summary_response' } }];\n}\n\nreturn [{\n  json: {\n    ...base,\n    enrichment_summary: String(parsed.summary),\n    llm_ok: true,\n    llm_output: parsed\n  }\n}];\n"
      },
      "id": "50",
      "name": "Parse Summary Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        820
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.llm_ok}}",
              "value2": true,
              "operation": "equal"
            }
          ]
        }
      },
      "id": "51",
      "name": "IF Summary OK",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1820,
        820
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE aiops_context\nSET normalized_event = normalized_event || jsonb_build_object('enrichment', jsonb_build_object('summary', COALESCE(NULLIF('{{ JSON.stringify($json.enrichment_summary || {}) }}','undefined')::jsonb, '{}'::jsonb)))\nWHERE context_id = NULLIF(NULLIF('{{ $json.context_id }}',''), 'undefined')::uuid;"
      },
      "id": "52",
      "name": "Update Enrichment Summary",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        2040,
        800
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.intent}}",
              "value2": "approval",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "54",
      "name": "IF Intent Approval",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1980,
        320
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst body = $json ?? {};\nconst approvalToken = body.approval_token ?? body.approvalToken ?? body.token ?? null;\n\nif (!approvalToken) {\n  return [{ json: { ...body, valid: false, status_code: 400, error: 'approval_token is required' } }];\n}\n\nlet interactionGrammar = null;\ntry {\n  interactionGrammar = JSON.parse(\"__POLICY__INTERACTION_GRAMMAR__\");\n} catch (error) {\n  interactionGrammar = null;\n}\n\nconst decisions = Array.isArray(interactionGrammar?.approval?.decisions)\n  ? interactionGrammar.approval.decisions.map((v) => String(v).trim().toLowerCase()).filter(Boolean)\n  : ['approve', 'deny'];\n\nconst decisionRaw = body.decision ?? body.action ?? body.intent ?? body.command ?? null;\nconst decisionText = decisionRaw ? String(decisionRaw).trim().toLowerCase() : null;\n\nif (!decisionText) {\n  return [{ json: { ...body, valid: false, status_code: 400, error: 'decision is required' } }];\n}\n\nif (!decisions.includes(decisionText)) {\n  return [{ json: { ...body, valid: false, status_code: 400, error: 'invalid decision' } }];\n}\n\nconst secret = $env.N8N_APPROVAL_HMAC_SECRET_NAME;\nif (!secret) {\n  return [{ json: { ...body, valid: false, status_code: 500, error: 'N8N_APPROVAL_HMAC_SECRET_NAME is not set' } }];\n}\n\nlet decoded = null;\ntry {\n  decoded = JSON.parse(Buffer.from(String(approvalToken), 'base64url').toString('utf8'));\n} catch (error) {\n  return [{ json: { ...body, valid: false, status_code: 400, error: 'invalid approval_token' } }];\n}\n\nconst { signature, ...payload } = decoded;\nconst expected = crypto.createHmac('sha256', secret).update(JSON.stringify(payload)).digest('hex');\nif (signature !== expected) {\n  return [{ json: { ...body, valid: false, status_code: 401, error: 'invalid approval_token signature' } }];\n}\n\nif (payload.expires_at && new Date(payload.expires_at).getTime() < Date.now()) {\n  return [{ json: { ...body, valid: false, status_code: 410, error: 'approval_token expired' } }];\n}\n\nreturn [{\n  json: {\n    ...body,\n    valid: true,\n    approval_token: approvalToken,\n    approval_id: payload.approval_id,\n    context_id: payload.context_id,\n    decision: decisionText,\n    actor: body.approver_actor ?? body.actor ?? payload.actor ?? {}\n  }\n}];\n"
      },
      "id": "55",
      "name": "Parse Approval Token (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        200
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.valid === true && $json.approval_id && $json.context_id ? 'true' : ''}}",
              "value2": "true",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "106",
      "name": "IF Approval Token Valid (Ingest)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2420,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const base = $node['Parse Approval Token (Ingest)'].json ?? $json ?? {};\nconst replyTarget = base.reply_target;\n\nif (!replyTarget) {\n  return [{\n    json: {\n      ...base,\n      reply_target: { source: 'unknown' },\n      content: '承認入力を処理できませんでした（reply_target が見つかりません）。'\n    }\n  }];\n}\n\nconst detail = base.error ? `（${String(base.error)}）` : '';\nreturn [{\n  json: {\n    ...base,\n    reply_target: replyTarget,\n    content: `承認入力を処理できませんでした${detail}`\n  }\n}];\n"
      },
      "id": "118",
      "name": "Build Approval Error Message (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2640,
        80
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT approval_id, context_id, job_plan, required_confirm, expires_at, approved_at, used_at\nFROM aiops_pending_approvals\nWHERE approval_id = NULLIF(NULLIF('{{ $json.approval_id }}',''), 'undefined')::uuid\n  AND context_id = NULLIF(NULLIF('{{ $json.context_id }}',''), 'undefined')::uuid;"
      },
      "id": "107",
      "name": "Load Pending Approval (Ingest)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        2640,
        200
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const tokenInfo = $node['Parse Approval Token (Ingest)'].json ?? {};\nconst row = $json?.[0] ?? $json ?? {};\n\nif (!row.approval_id) {\n  return [{ json: { ...tokenInfo, valid: false, error: 'approval not found' } }];\n}\nif (row.used_at) {\n  return [{ json: { ...tokenInfo, valid: false, error: 'approval already used' } }];\n}\nif (row.expires_at && new Date(row.expires_at).getTime() < Date.now()) {\n  return [{ json: { ...tokenInfo, valid: false, error: 'approval expired' } }];\n}\n\nreturn [{\n  json: {\n    ...tokenInfo,\n    valid: true,\n    job_plan: row.job_plan,\n    context_id: row.context_id\n  }\n}];\n"
      },
      "id": "108",
      "name": "Validate Pending Approval (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2860,
        200
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.valid}}",
              "value2": true,
              "operation": "equal"
            }
          ]
        }
      },
      "id": "109",
      "name": "IF Pending Approval Valid (Ingest)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        3080,
        200
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.decision}}",
              "value2": "deny",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "110",
      "name": "IF Decision Deny (Ingest)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        3300,
        200
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE aiops_pending_approvals\nSET used_at = NOW()\nWHERE approval_id = NULLIF(NULLIF('{{ $json.approval_id }}',''), 'undefined')::uuid\n  AND context_id = NULLIF(NULLIF('{{ $json.context_id }}',''), 'undefined')::uuid\n  AND used_at IS NULL\nRETURNING approval_id;"
      },
      "id": "111",
      "name": "Mark Approval Denied (Ingest)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        3520,
        120
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO aiops_approval_history (approval_history_id, context_id, approval_id, actor, decision, job_plan)\nVALUES (\n  NULLIF(NULLIF('{{ $node['Parse Approval Token (Ingest)'].json.approval_id }}',''), 'undefined')::uuid,\n  NULLIF(NULLIF('{{ $node['Validate Pending Approval (Ingest)'].json.context_id }}',''), 'undefined')::uuid,\n  NULLIF(NULLIF('{{ $node['Parse Approval Token (Ingest)'].json.approval_id }}',''), 'undefined')::uuid,\n  COALESCE(NULLIF('{{ JSON.stringify($node['Parse Approval Token (Ingest)'].json.actor || {}) }}', 'undefined')::jsonb, '{}'::jsonb),\n  'denied',\n  COALESCE(NULLIF('{{ JSON.stringify($node['Validate Pending Approval (Ingest)'].json.job_plan || {}) }}', 'undefined')::jsonb, '{}'::jsonb)\n)\nON CONFLICT (approval_history_id) DO NOTHING;"
      },
      "id": "112",
      "name": "Record Approval Denied (Ingest)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        3740,
        120
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "url": "={{(() => {\n  const webhookUrl = (() => {\n    const candidates = [\n      'Webhook (CloudWatch Ingest)',\n      'Webhook (Zulip Ingest)',\n      'Webhook (Ingest)'\n    ];\n\n    for (const name of candidates) {\n      try {\n        const node = $node[name];\n        const url = node && node.json && node.json.webhookUrl;\n        if (url) return String(url);\n      } catch (error) {\n        // ignore\n      }\n    }\n\n    return '';\n  })();\n\n  const derivedBase = webhookUrl ? webhookUrl.replace(/\\/webhook\\/.*/, '/webhook') : '';\n  const baseRaw = derivedBase\n    || $env.N8N_ORCHESTRATOR_BASE_URL\n    || $env.N8N_WEBHOOK_BASE_URL\n    || $env.N8N_ADAPTER_BASE_URL\n    || $env.N8N_APPROVAL_BASE_URL\n    || '';\n\n  const base = (() => {\n    let base = String(baseRaw ?? '').trim().replace(/\\/+$/, '');\n    if (!base) return '';\n\n    const webhookIndex = base.indexOf('/webhook');\n    if (webhookIndex >= 0) {\n      base = base.slice(0, webhookIndex) + '/webhook';\n    } else {\n      base = base + '/webhook';\n    }\n\n    const m = base.match(/^https?:\\/\\/([^/]+):5678(\\/|$)/);\n    if (m) {\n      const host = m[1];\n      const isLocal = host === 'localhost'\n        || host === '127.0.0.1'\n        || /^10\\./.test(host)\n        || /^192\\.168\\./.test(host)\n        || /^172\\.(1[6-9]|2\\d|3[0-1])\\./.test(host);\n      if (isLocal) {\n        base = base.replace(/^https:\\/\\//, 'http://');\n      } else {\n        base = base.replace(/^https?:\\/\\/([^/]+):5678(\\/|$)/, 'https://$1$2');\n      }\n    }\n\n    return base.replace(/\\/+$/, '');\n  })();\n\n  if (!base) return '';\n  return base + '/jobs/job-engine/enqueue';\n})()}}",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { context_id: $json.context_id, job_plan: $json.job_plan, approval_token: $json.approval_token } }}",
        "options": {
          "timeout": 20000
        }
      },
      "id": "113",
      "name": "Enqueue Job (Approval Confirm Ingest)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        3520,
        280
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE aiops_context\nSET normalized_event = normalized_event || jsonb_build_object('job_id', NULLIF(NULLIF('{{ $json.job_id }}',''), 'undefined'))\nWHERE context_id = NULLIF(NULLIF('{{ $node['Validate Pending Approval (Ingest)'].json.context_id }}',''), 'undefined')::uuid;"
      },
      "id": "114",
      "name": "Context Store (job_id) (Approval Confirm Ingest)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        3740,
        280
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO aiops_approval_history (approval_history_id, context_id, approval_id, actor, decision, job_plan)\nVALUES (\n  NULLIF(NULLIF('{{ $node['Parse Approval Token (Ingest)'].json.approval_id }}',''), 'undefined')::uuid,\n  NULLIF(NULLIF('{{ $node['Validate Pending Approval (Ingest)'].json.context_id }}',''), 'undefined')::uuid,\n  NULLIF(NULLIF('{{ $node['Parse Approval Token (Ingest)'].json.approval_id }}',''), 'undefined')::uuid,\n  COALESCE(NULLIF('{{ JSON.stringify($node['Parse Approval Token (Ingest)'].json.actor || {}) }}', 'undefined')::jsonb, '{}'::jsonb),\n  'approved',\n  COALESCE(NULLIF('{{ JSON.stringify($node['Validate Pending Approval (Ingest)'].json.job_plan || {}) }}', 'undefined')::jsonb, '{}'::jsonb)\n)\nON CONFLICT (approval_history_id) DO NOTHING;"
      },
      "id": "115",
      "name": "Record Approval Approved (Ingest)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        3960,
        280
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT reply_target\nFROM aiops_context\nWHERE context_id = {{$node['Validate Pending Approval (Ingest)'].json.context_id}}::uuid;"
      },
      "id": "116",
      "name": "Load Context (Approval Ack Ingest)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        4180,
        200
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const row = $json?.[0] ?? $json ?? {};\nconst replyTarget = row.reply_target;\nif (!replyTarget) return [];\n\nlet interactionGrammar = null;\ntry {\n  interactionGrammar = JSON.parse(\"__POLICY__INTERACTION_GRAMMAR__\");\n} catch (error) {\n  interactionGrammar = null;\n}\n\nlet decisionPolicyDoc = null;\ntry {\n  decisionPolicyDoc = JSON.parse(\"__POLICY__DECISION__\");\n} catch (error) {\n  decisionPolicyDoc = null;\n}\n\nconst decision = $node['Validate Pending Approval (Ingest)'].json?.decision;\nconst enqueue = $node['Enqueue Job (Approval Confirm Ingest)']?.json ?? {};\nconst jobId = enqueue.job_id ?? null;\n\nconst ackFallbacks = decisionPolicyDoc?.fallbacks?.approval_ack_messages ?? {};\nconst ackTemplate = interactionGrammar?.approval?.ack_messages?.[decision]\n  ?? ackFallbacks?.[decision]\n  ?? '';\nconst jobLine = jobId && decision !== 'deny' ? `\\nJob ID: ${jobId}` : '';\nconst content = String(ackTemplate).split('{job_line}').join(jobLine);\n\nreturn [{\n  json: {\n    reply_target: replyTarget,\n    content,\n    context_id: $node['Validate Pending Approval (Ingest)'].json?.context_id,\n    job_id: jobId\n  }\n}];\n"
      },
      "id": "117",
      "name": "Build Approval Ack (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4400,
        200
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.intent}}",
              "value2": "feedback",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "56",
      "name": "IF Intent Feedback",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2200,
        360
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.feedback_payload?.feedback_type}}",
              "value2": "preview",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "57",
      "name": "IF Feedback Type Preview (Ingest)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2420,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst body = $json?.feedback_payload ?? {};\nconst headers = (typeof $headers !== 'undefined' && $headers) || {};\n\nlet interactionGrammar = null;\ntry {\n  interactionGrammar = JSON.parse(\"__POLICY__INTERACTION_GRAMMAR__\");\n} catch (error) {\n  interactionGrammar = null;\n}\n\nlet decisionPolicyDoc = null;\ntry {\n  decisionPolicyDoc = JSON.parse(\"__POLICY__DECISION__\");\n} catch (error) {\n  decisionPolicyDoc = null;\n}\n\nconst fallbackScoreRange = decisionPolicyDoc?.defaults?.interaction_parse?.smile_score_range ?? { min: 1, max: 4 };\nconst scoreRange = interactionGrammar?.preview_feedback?.score_range ?? fallbackScoreRange;\nconst minScore = Number.parseInt(String(scoreRange.min ?? 1), 10);\nconst maxScore = Number.parseInt(String(scoreRange.max ?? 4), 10);\n\nconst approvalId = body.approval_id ?? body.approvalId ?? null;\nif (!approvalId) throw new Error('approval_id は必須です');\n\nconst scoreRaw = body.score ?? body.smile_score ?? body.smileScore ?? null;\nconst score = Number.parseInt(String(scoreRaw ?? ''), 10);\nif (!Number.isInteger(score) || score < minScore || score > maxScore) {\n  throw new Error(`score は ${minScore}..${maxScore} の整数で指定してください`);\n}\n\nconst commentRaw = body.comment ?? body.message ?? '';\nconst comment = String(commentRaw).trim();\n\nconst actor = (() => {\n  if (body.actor && typeof body.actor === 'object') return body.actor;\n  return {\n    source: 'preview_feedback',\n    remote_ip: headers['x-forwarded-for'] ?? null,\n    user_agent: headers['user-agent'] ?? null\n  };\n})();\n\nconst selectedWorkflowId = body.selected_workflow_id ?? body.selectedWorkflowId ?? null;\nconst selectedPolicyId = body.selected_policy_id ?? body.selectedPolicyId ?? null;\n\nreturn [\n  {\n    json: {\n      preview_feedback_id: crypto.randomUUID(),\n      approval_id: String(approvalId),\n      score,\n      comment,\n      actor,\n      selected_workflow_id: selectedWorkflowId ? String(selectedWorkflowId) : null,\n      selected_policy_id: selectedPolicyId ? String(selectedPolicyId) : null\n    }\n  }\n];\n"
      },
      "id": "119",
      "name": "Parse Preview Feedback (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2640,
        160
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH ctx AS (\n  SELECT context_id\n  FROM aiops_pending_approvals\n  WHERE approval_id = NULLIF(NULLIF('{{ $json.approval_id }}',''), 'undefined')::uuid\n\n  UNION ALL\n\n  SELECT context_id\n  FROM aiops_approval_history\n  WHERE approval_id = NULLIF(NULLIF('{{ $json.approval_id }}',''), 'undefined')::uuid\n), picked AS (\n  SELECT context_id\n  FROM ctx\n  WHERE context_id IS NOT NULL\n  LIMIT 1\n), ins AS (\n  INSERT INTO aiops_preview_feedback (\n    preview_feedback_id,\n    approval_id,\n    context_id,\n    actor,\n    score,\n    comment,\n    selected_workflow_id,\n    selected_policy_id\n  )\n  SELECT\n    NULLIF(NULLIF('{{ $json.preview_feedback_id }}',''), 'undefined')::uuid,\n    NULLIF(NULLIF('{{ $json.approval_id }}',''), 'undefined')::uuid,\n    (SELECT context_id FROM picked),\n    COALESCE(NULLIF('{{ JSON.stringify($json.actor || {}) }}','undefined')::jsonb, '{}'::jsonb),\n    {{$json.score}},\n    NULLIF('{{ $json.comment }}', ''),\n    NULLIF('{{ $json.selected_workflow_id }}', ''),\n    NULLIF('{{ $json.selected_policy_id }}', '')\n  WHERE (SELECT context_id FROM picked) IS NOT NULL\n  RETURNING context_id\n), upd AS (\n  UPDATE aiops_context\n  SET normalized_event = normalized_event || jsonb_build_object(\n    'preview_feedback', jsonb_build_object(\n      'approval_id', NULLIF(NULLIF('{{ $json.approval_id }}',''), 'undefined')::text,\n      'score', {{$json.score}},\n      'comment', NULLIF('{{ $json.comment }}', ''),\n      'selected_workflow_id', NULLIF('{{ $json.selected_workflow_id }}', ''),\n      'selected_policy_id', NULLIF('{{ $json.selected_policy_id }}', '')\n    )\n  )\n  WHERE context_id = (SELECT context_id FROM picked)\n  RETURNING context_id\n)\nSELECT\n  (SELECT context_id FROM picked) AS context_id,\n  (SELECT COUNT(*) FROM ins) AS inserted;"
      },
      "id": "120",
      "name": "Store Preview Feedback (Ingest)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        2860,
        160
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst body = $json?.feedback_payload ?? {};\nconst headers = $headers ?? {};\n\nlet interactionGrammar = null;\ntry {\n  interactionGrammar = JSON.parse(\"__POLICY__INTERACTION_GRAMMAR__\");\n} catch (error) {\n  interactionGrammar = null;\n}\n\nlet decisionPolicyDoc = null;\ntry {\n  decisionPolicyDoc = JSON.parse(\"__POLICY__DECISION__\");\n} catch (error) {\n  decisionPolicyDoc = null;\n}\n\nconst fallbackScoreRange = decisionPolicyDoc?.defaults?.feedback?.smile_score_range ?? { min: 1, max: 4 };\nconst scoreRange = interactionGrammar?.feedback?.smile_score_range ?? fallbackScoreRange;\nconst minScore = Number.parseInt(String(scoreRange.min ?? 1), 10);\nconst maxScore = Number.parseInt(String(scoreRange.max ?? 4), 10);\n\nconst fallbackResolvedValues = decisionPolicyDoc?.defaults?.feedback?.resolved_values ?? ['true', 'false'];\nconst resolvedValues = Array.isArray(interactionGrammar?.feedback?.resolved_values)\n  ? interactionGrammar.feedback.resolved_values.map((v) => String(v).trim().toLowerCase()).filter(Boolean)\n  : fallbackResolvedValues;\n\nconst jobId = body.job_id ?? body.jobId ?? null;\nif (!jobId) throw new Error('job_id は必須です');\n\nconst resolvedRaw = body.resolved;\nif (resolvedRaw === undefined || resolvedRaw === null) {\n  throw new Error('resolved は必須です');\n}\n\nconst resolved = (() => {\n  if (typeof resolvedRaw === 'boolean') return resolvedRaw;\n  const v = String(resolvedRaw).trim().toLowerCase();\n  if (v === 'true' && resolvedValues.includes('true')) return true;\n  if (v === 'false' && resolvedValues.includes('false')) return false;\n  throw new Error(`resolved は ${resolvedValues.join('|')} のいずれかで指定してください`);\n})();\n\nconst scoreRaw = body.smile_score ?? body.smileScore ?? body.score ?? null;\nconst score = Number.parseInt(String(scoreRaw ?? ''), 10);\nif (!Number.isInteger(score) || score < minScore || score > maxScore) {\n  throw new Error(`smile_score は ${minScore}..${maxScore} の整数で指定してください`);\n}\n\nconst commentRaw = body.comment ?? body.message ?? '';\nconst comment = String(commentRaw).trim();\n\nconst actor = (() => {\n  if (body.actor && typeof body.actor === 'object') return body.actor;\n  return {\n    source: 'feedback',\n    remote_ip: headers['x-forwarded-for'] ?? null,\n    user_agent: headers['user-agent'] ?? null\n  };\n})();\n\nreturn [\n  {\n    json: {\n      feedback_id: crypto.randomUUID(),\n      job_id: String(jobId),\n      resolved,\n      smile_score: score,\n      comment,\n      actor\n    }\n  }\n];\n"
      },
      "id": "121",
      "name": "Parse Feedback (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2640,
        440
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH ctx AS (\n  SELECT q.context_id, c.status AS current_status, c.reply_target, c.normalized_event\n  FROM aiops_job_queue q\n  JOIN aiops_context c ON c.context_id = q.context_id\n  WHERE q.job_id = {{$json.job_id}}::uuid\n  LIMIT 1\n), jr AS (\n  SELECT status, result_payload, error_payload\n  FROM aiops_job_results\n  WHERE job_id = {{$json.job_id}}::uuid\n  LIMIT 1\n)\nSELECT\n  {{$json.feedback_id}}::uuid AS feedback_id,\n  {{$json.job_id}}::uuid AS job_id,\n  {{$json.resolved}} AS resolved,\n  {{$json.smile_score}} AS smile_score,\n  NULLIF({{$json.comment}}, '') AS comment,\n  {{$json.actor}}::jsonb AS actor,\n  (SELECT context_id FROM ctx) AS context_id,\n  (SELECT current_status FROM ctx) AS current_status,\n  (SELECT reply_target FROM ctx) AS reply_target,\n  (SELECT normalized_event FROM ctx) AS normalized_event,\n  (SELECT status FROM jr) AS job_status,\n  (SELECT result_payload FROM jr) AS result_payload,\n  (SELECT error_payload FROM jr) AS error_payload;"
      },
      "id": "122",
      "name": "Load Feedback Context (Ingest)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        2860,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst base = $json ?? {};\n\nconst normalizedEvent = { ...(base.normalized_event ?? {}) };\ndelete normalizedEvent.raw_headers;\ndelete normalizedEvent.raw_body;\n\nlet decisionPolicyDoc = null;\ntry {\n  decisionPolicyDoc = JSON.parse(\"__POLICY__DECISION__\");\n} catch (error) {\n  decisionPolicyDoc = null;\n}\n\nconst policyContext = {\n  limits: decisionPolicyDoc?.limits ?? {},\n  taxonomy: decisionPolicyDoc?.taxonomy ?? {},\n  thresholds: decisionPolicyDoc?.thresholds ?? {},\n  defaults: decisionPolicyDoc?.defaults ?? {},\n  rules: decisionPolicyDoc?.rules ?? {},\n  fallbacks: decisionPolicyDoc?.fallbacks ?? {}\n};\n\nconst input = {\n  policy_context: policyContext,\n  feedback: {\n    resolved: base.resolved,\n    smile_score: base.smile_score,\n    comment: base.comment ?? ''\n  },\n  job_result: {\n    status: base.job_status ?? null,\n    result_payload: base.result_payload ?? null,\n    error_payload: base.error_payload ?? null\n  },\n  context: {\n    context_id: base.context_id ?? null,\n    status: base.current_status ?? null,\n    normalized_event: normalizedEvent\n  }\n};\n\nconst promptText = \"__PROMPT__FEEDBACK_DECIDE__\";\nconst promptHash = crypto.createHash('sha256').update(promptText).digest('hex');\n\nreturn [{\n  json: {\n    ...base,\n    policy_context: policyContext,\n    prompt_key: 'adapter.feedback_decide.v1',\n    prompt_version: 'ja-1',\n    prompt_text: promptText,\n    prompt_hash: promptHash,\n    prompt_input: JSON.stringify(input)\n  }\n}];\n"
      },
      "id": "123",
      "name": "Build Feedback Decision Prompt (JP) (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3080,
        440
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO aiops_prompt_history (prompt_key, prompt_version, prompt_text, prompt_hash, source_workflow, source_node)\nVALUES (\n  '{{ String($json.prompt_key ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_version ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_text ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_hash ?? \"\").replace(/'/g, \"''\") }}',\n  'aiops-adapter-ingest',\n  'OpenAI Feedback Decide (Ingest)'\n)\nON CONFLICT (prompt_key, prompt_hash) DO NOTHING;"
      },
      "id": "124",
      "name": "Record Prompt History (Feedback Ingest)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        3300,
        440
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "operation": "complete",
        "model": "={{$env.OPENAI_MODEL || 'gpt-4o-mini'}}",
        "prompt": {
          "messages": [
            {
              "role": "system",
              "content": "={{ $node['Build Feedback Decision Prompt (JP) (Ingest)'].json.prompt_text }}"
            },
            {
              "role": "user",
              "content": "={{ '入力:\\n' + $node['Build Feedback Decision Prompt (JP) (Ingest)'].json.prompt_input }}"
            }
          ]
        },
        "options": {
          "temperature": 0.2,
          "baseURL": "={{$env.OPENAI_BASE_URL}}",
          "maxTokens": "={{$json.policy_context?.limits?.llm_output_tokens || 1200}}"
        }
      },
      "id": "125",
      "name": "OpenAI Feedback Decide (Ingest)",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        3520,
        440
      ],
      "credentials": {
        "openAiApi": {
          "name": "aiops-openai"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "const base = $node['Build Feedback Decision Prompt (JP) (Ingest)'].json ?? {};\nconst response = $json ?? {};\n\nconst extractContent = (payload) => {\n  return payload?.message?.content\n    ?? payload?.choices?.[0]?.message?.content\n    ?? payload?.choices?.[0]?.text\n    ?? payload?.data?.choices?.[0]?.message?.content\n    ?? payload?.data?.choices?.[0]?.text\n    ?? payload?.content\n    ?? '';\n};\n\nconst rawContent = extractContent(response);\nlet parsed = null;\nif (typeof rawContent === 'string') {\n  try {\n    parsed = JSON.parse(rawContent);\n  } catch (error) {\n    const match = rawContent.match(/\\{[\\s\\S]*\\}/);\n    if (match) {\n      try {\n        parsed = JSON.parse(match[0]);\n      } catch (inner) {\n        parsed = null;\n      }\n    }\n  }\n} else if (rawContent && typeof rawContent === 'object') {\n  parsed = rawContent;\n}\n\nconst isObject = (v) => Boolean(v) && typeof v === 'object' && !Array.isArray(v);\n\nlet ok = isObject(parsed);\nif (ok) {\n  ok = (parsed.case_status === 'closed' || parsed.case_status === 'open')\n    && Array.isArray(parsed.followups)\n    && typeof parsed.confidence === 'number'\n    && typeof parsed.rationale === 'string';\n}\n\nconst policyContext = base.policy_context ?? {};\nconst fallbacks = policyContext?.fallbacks?.feedback_decide ?? {};\n\nconst safeDecision = ok ? parsed : {\n  case_status: fallbacks.case_status ?? 'open',\n  followups: Array.isArray(fallbacks.followups) ? fallbacks.followups : [],\n  confidence: typeof fallbacks.confidence === 'number' ? fallbacks.confidence : 0,\n  rationale: fallbacks.rationale ?? 'モデル出力が無効なため安全側（open）にフォールバック'\n};\n\nreturn [{\n  json: {\n    ...base,\n    llm_feedback_ok: ok,\n    feedback_decision: safeDecision,\n    feedback_decision_raw: typeof rawContent === 'string' ? rawContent : JSON.stringify(rawContent ?? ''),\n    case_status: safeDecision.case_status,\n    followups: safeDecision.followups\n  }\n}];\n"
      },
      "id": "126",
      "name": "Parse Feedback Decision Response (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3740,
        440
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH ctx AS (\n  SELECT q.context_id\n  FROM aiops_job_queue q\n  WHERE q.job_id = NULLIF(NULLIF('{{ $json.job_id }}',''), 'undefined')::uuid\n  LIMIT 1\n), ins AS (\n  INSERT INTO aiops_job_feedback (feedback_id, job_id, context_id, actor, resolved, smile_score, comment)\n  SELECT\n    NULLIF(NULLIF('{{ $json.feedback_id }}',''), 'undefined')::uuid,\n    NULLIF(NULLIF('{{ $json.job_id }}',''), 'undefined')::uuid,\n    ctx.context_id,\n    COALESCE(NULLIF('{{ JSON.stringify($json.actor || {}) }}','undefined')::jsonb, '{}'::jsonb),\n    {{$json.resolved}},\n    {{$json.smile_score}},\n    NULLIF('{{ $json.comment }}', '')\n  FROM ctx\n  RETURNING context_id\n), upd AS (\n  UPDATE aiops_context\n  SET\n    normalized_event = normalized_event || jsonb_build_object(\n      'feedback', jsonb_build_object(\n        'job_id', NULLIF(NULLIF('{{ $json.job_id }}',''), 'undefined')::text,\n        'resolved', {{$json.resolved}},\n        'smile_score', {{$json.smile_score}},\n        'comment', NULLIF('{{ $json.comment }}', '')\n      ),\n      'feedback_decision', COALESCE(NULLIF('{{ JSON.stringify($json.feedback_decision || {}) }}','undefined')::jsonb, '{}'::jsonb)\n    ),\n    status = CASE WHEN '{{ $json.case_status }}' = 'closed' THEN 'closed' ELSE COALESCE(status, 'open') END,\n    closed_at = CASE WHEN '{{ $json.case_status }}' = 'closed' THEN NOW() ELSE closed_at END\n  WHERE context_id = (SELECT context_id FROM ctx)\n  RETURNING context_id\n)\nSELECT\n  (SELECT context_id FROM ctx) AS context_id,\n  (SELECT COUNT(*) FROM ins) AS inserted,\n  '{{ $json.case_status }}' AS case_status;"
      },
      "id": "127",
      "name": "Store Feedback (Ingest)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        3960,
        440
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const base = $json ?? {};\n\nconst replyTarget = $node['Parse Event Kind Decide Response'].json?.reply_target\n  ?? $node['Build Event Kind Prompt (JP)'].json?.reply_target\n  ?? base.reply_target\n  ?? {};\n\nconst source = replyTarget.source ?? 'unknown';\nconst feedbackType = $node['Parse Event Kind Decide Response'].json?.feedback_payload?.feedback_type\n  ?? $node['Parse Event Kind Decide Response'].json?.feedback_type\n  ?? null;\n\nconst content = feedbackType === 'preview'\n  ? 'プレビュー評価を受け付けました。ありがとうございます。'\n  : '評価を受け付けました。ありがとうございます。';\n\nreturn [{\n  json: {\n    reply_target: replyTarget,\n    content,\n    source\n  }\n}];\n"
      },
      "id": "128",
      "name": "Build Feedback Ack (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4180,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst base = $json ?? {};\n\nconst normalizedEvent = { ...(base.normalized_event ?? {}) };\ndelete normalizedEvent.raw_headers;\ndelete normalizedEvent.raw_body;\n\nconst input = {\n  normalized_event: normalizedEvent,\n  actor: base.actor ?? {},\n  reply_target: base.reply_target ?? {},\n  policy_context: base.policy_context ?? {}\n};\n\nconst promptText = \"__PROMPT__CHAT_CORE__\";\nconst promptHash = crypto.createHash('sha256').update(promptText).digest('hex');\n\nreturn [{\n  json: {\n    ...base,\n    prompt_key: 'adapter.interaction_parse.v1',\n    prompt_version: 'ja-1',\n    prompt_text: promptText,\n    prompt_hash: promptHash,\n    prompt_input: JSON.stringify(input)\n  }\n}];\n"
      },
      "id": "67",
      "name": "Build Chat Core Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2420,
        420
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO aiops_prompt_history (prompt_key, prompt_version, prompt_text, prompt_hash, source_workflow, source_node)\nVALUES (\n  '{{ String($json.prompt_key ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_version ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_text ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_hash ?? \"\").replace(/'/g, \"''\") }}',\n  'aiops-adapter-ingest',\n  'OpenAI Chat Core'\n)\nON CONFLICT (prompt_key, prompt_hash) DO NOTHING;"
      },
      "id": "68",
      "name": "Record Prompt History (Chat Core)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        2640,
        420
      ],
      "alwaysOutputData": true,
      "continueOnFail": true
    },
    {
      "parameters": {
        "resource": "chat",
        "operation": "complete",
        "model": "={{$env.OPENAI_MODEL || 'gpt-4o-mini'}}",
        "prompt": {
          "messages": [
            {
              "role": "system",
              "content": "={{ $node['Build Chat Core Prompt (JP)'].json.prompt_text }}"
            },
            {
              "role": "user",
              "content": "={{ '入力:\\n' + $node['Build Chat Core Prompt (JP)'].json.prompt_input }}"
            }
          ]
        },
        "options": {
          "temperature": 0.2,
          "baseURL": "={{$env.OPENAI_BASE_URL}}",
          "maxTokens": "={{$json.policy_context?.limits?.llm_output_tokens || 1200}}"
        }
      },
      "id": "69",
      "name": "OpenAI Chat Core",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        2860,
        420
      ],
      "credentials": {
        "openAiApi": {
          "name": "aiops-openai"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "const url = $env.N8N_OBSERVER_URL;\nconst token = $env.N8N_OBSERVER_TOKEN;\n\nif (!url || !token) {\n  return items;\n}\n\nconst maxCharsRaw = $env.N8N_OBSERVER_MAX_CHARS;\nconst maxChars = Number.isFinite(Number(maxCharsRaw)) ? Math.max(0, Math.floor(Number(maxCharsRaw))) : 4000;\n\nconst truncate = (value) => {\n  if (typeof value !== 'string') return value;\n  if (maxChars <= 0) return '';\n  return value.length > maxChars ? `${value.slice(0, maxChars)}…` : value;\n};\n\nconst base = $node['Build Chat Core Prompt (JP)']?.json ?? {};\n\nconst payload = {\n  kind: 'n8n.chat_node',\n  realm: $env.N8N_OBSERVER_REALM ?? null,\n  workflow: $workflow.name,\n  execution_id: $execution.id,\n  node: 'OpenAI Chat Core',\n  sent_at: new Date().toISOString(),\n  input: {\n    prompt_text: truncate(base.prompt_text ?? null),\n    prompt_input: truncate(base.prompt_input ?? null)\n  },\n  output: $json\n};\n\ntry {\n  await this.helpers.httpRequest({\n    method: 'POST',\n    url,\n    json: true,\n    headers: {\n      'X-Observer-Token': token\n    },\n    body: payload,\n    timeout: 5000\n  });\n} catch (error) {\n  // Observability must never break production workflows.\n}\n\nreturn items;\n"
      },
      "id": "9001",
      "name": "AIOPS Observer (Chat Core)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3080,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const base = $node['Build Chat Core Prompt (JP)'].json ?? {};\nconst response = $json ?? {};\n\nconst extractContent = (payload) => {\n  return payload?.message?.content\n    ?? payload?.choices?.[0]?.message?.content\n    ?? payload?.choices?.[0]?.text\n    ?? payload?.data?.choices?.[0]?.message?.content\n    ?? payload?.data?.choices?.[0]?.text\n    ?? payload?.content\n    ?? '';\n};\n\nconst rawContent = extractContent(response);\nlet parsed = null;\nif (typeof rawContent === 'string') {\n  try {\n    parsed = JSON.parse(rawContent);\n  } catch (error) {\n    const match = rawContent.match(/\\{[\\s\\S]*\\}/);\n    if (match) {\n      try {\n        parsed = JSON.parse(match[0]);\n      } catch (inner) {\n        parsed = null;\n      }\n    }\n  }\n} else if (rawContent && typeof rawContent === 'object') {\n  parsed = rawContent;\n}\n\nconst policyContext = base.policy_context ?? {};\nconst limits = policyContext?.limits ?? {};\nconst defaults = policyContext?.defaults ?? {};\nconst fallbacks = policyContext?.fallbacks ?? {};\nconst grammar = policyContext?.interaction_grammar ?? {};\n\nconst isObject = (v) => Boolean(v) && typeof v === 'object' && !Array.isArray(v);\nconst isNonEmptyString = (v) => typeof v === 'string' && v.trim().length > 0;\n\nconst allowedEventKinds = Array.isArray(policyContext?.taxonomy?.event_kind_vocab)\n  ? new Set(policyContext.taxonomy.event_kind_vocab.map((v) => String(v).trim()).filter(Boolean))\n  : new Set();\nconst allowedNextActions = Array.isArray(policyContext?.taxonomy?.next_action_vocab)\n  ? new Set(policyContext.taxonomy.next_action_vocab.map((v) => String(v).trim()).filter(Boolean))\n  : new Set();\n\nconst maxClarifying = Number.isFinite(Number(limits?.adapter_classify?.max_clarifying_questions))\n  ? Math.max(0, Math.floor(Number(limits.adapter_classify.max_clarifying_questions)))\n  : 3;\n\nconst maxMissingParams = Number.isFinite(Number(limits?.jobs_preview?.max_missing_params))\n  ? Math.max(0, Math.floor(Number(limits.jobs_preview.max_missing_params)))\n  : 10;\n\nconst fallbackEventKind = fallbacks?.interaction_parse?.default_event_kind\n  ?? defaults?.interaction_parse?.default_event_kind\n  ?? 'other';\n\nconst eventKind = parsed && isNonEmptyString(parsed.event_kind)\n  ? String(parsed.event_kind).trim()\n  : fallbackEventKind;\n\nconst eventKindOk = allowedEventKinds.size == 0 || allowedEventKinds.has(eventKind);\nconst intent = eventKindOk ? eventKind : fallbackEventKind;\n\nconst normalized = { ...(base.normalized_event ?? {}) };\nconst classification = { ...(normalized.classification ?? {}) };\nconst parsedClassification = isObject(parsed?.classification) ? parsed.classification : {};\n\nconst fallbackClass = fallbacks?.adapter_classify?.classification ?? {};\nconst defaultClass = defaults?.adapter_classify ?? {};\n\nclassification.form = isNonEmptyString(parsedClassification.form)\n  ? String(parsedClassification.form).toLowerCase()\n  : (fallbackClass.form ?? defaultClass.form ?? classification.form ?? 'non_standard');\nclassification.category = isNonEmptyString(parsedClassification.category)\n  ? String(parsedClassification.category).toLowerCase()\n  : (fallbackClass.category ?? defaultClass.category ?? classification.category ?? 'incident');\nclassification.subtype = isNonEmptyString(parsedClassification.subtype)\n  ? String(parsedClassification.subtype)\n  : (fallbackClass.subtype ?? defaultClass.subtype ?? classification.subtype ?? 'triage');\n\nnormalized.classification = classification;\n\nconst impacted = Array.isArray(parsedClassification.impacted_resources)\n  ? parsedClassification.impacted_resources.filter((v) => v !== null && v !== undefined)\n  : [];\nnormalized.impacted_resources = impacted;\n\nconst parsedPriority = isObject(parsed?.priority) ? parsed.priority : {};\nnormalized.impact = isNonEmptyString(parsedPriority.impact)\n  ? String(parsedPriority.impact).toLowerCase()\n  : (fallbacks?.adapter_classify?.impact ?? defaults?.adapter_classify?.impact ?? normalized.impact ?? 'medium');\nnormalized.urgency = isNonEmptyString(parsedPriority.urgency)\n  ? String(parsedPriority.urgency).toLowerCase()\n  : (fallbacks?.adapter_classify?.urgency ?? defaults?.adapter_classify?.urgency ?? normalized.urgency ?? 'medium');\nnormalized.priority = isNonEmptyString(parsedPriority.priority)\n  ? String(parsedPriority.priority).toLowerCase()\n  : (fallbacks?.adapter_classify?.priority ?? defaults?.adapter_classify?.priority ?? normalized.priority ?? 'p3');\n\nif (isObject(parsed?.extracted_params)) {\n  normalized.extracted_params = parsed.extracted_params;\n}\n\nif (typeof parsed?.needs_clarification === 'boolean') {\n  normalized.needs_clarification = parsed.needs_clarification;\n}\n\nconst clarifyingQuestions = Array.isArray(parsed?.clarifying_questions)\n  ? parsed.clarifying_questions.filter((q) => isNonEmptyString(q)).slice(0, maxClarifying)\n  : [];\n\nnormalized.clarifying_questions = clarifyingQuestions;\n\nconst nextAction = parsed && isNonEmptyString(parsed.next_action) ? String(parsed.next_action).trim() : null;\nconst nextActionOk = nextAction && (allowedNextActions.size === 0 || allowedNextActions.has(nextAction));\nconst fallbackNextAction = fallbacks?.jobs_preview?.invalid_output_next_action\n  ?? defaults?.jobs_preview?.next_action\n  ?? 'ask_clarification';\n\nconst resolvedNextAction = nextActionOk ? nextAction : fallbackNextAction;\n\nconst missingParams = Array.isArray(parsed?.missing_params)\n  ? parsed.missing_params.filter((p) => isNonEmptyString(p)).slice(0, maxMissingParams)\n  : [];\n\nconst initialReply = isObject(parsed?.initial_reply) ? parsed.initial_reply : null;\n\nlet decision = null;\nlet approvalToken = null;\nlet feedbackPayload = null;\n\nif (intent === 'approval') {\n  const approval = isObject(parsed?.approval) ? parsed.approval : null;\n  const dec = approval?.decision;\n  const tok = approval?.approval_token;\n  const decNorm = isNonEmptyString(dec) ? String(dec).trim().toLowerCase() : null;\n  const tokNorm = isNonEmptyString(tok) ? String(tok).trim() : null;\n\n  const allowedDecision = Array.isArray(grammar?.approval?.decisions)\n    ? new Set(grammar.approval.decisions.map((v) => String(v).trim().toLowerCase()).filter(Boolean))\n    : new Set();\n\n  const decisionOk = decNorm && (allowedDecision.size === 0 || allowedDecision.has(decNorm));\n  if (decisionOk) {\n    decision = decNorm;\n    approvalToken = tokNorm;\n  }\n}\n\nif (intent === 'feedback') {\n  const feedback = isObject(parsed?.feedback) ? parsed.feedback : null;\n  const jobId = feedback?.job_id;\n  const resolved = feedback?.resolved;\n  const score = feedback?.smile_score;\n  const comment = feedback?.comment;\n\n  const scoreRange = grammar?.feedback?.smile_score_range ?? defaults?.smile_score_range ?? null;\n  const minScore = Number.isFinite(Number(scoreRange?.min)) ? Number(scoreRange.min) : null;\n  const maxScore = Number.isFinite(Number(scoreRange?.max)) ? Number(scoreRange.max) : null;\n  const scoreNum = Number.parseInt(String(score ?? ''), 10);\n  const scoreOk = Number.isInteger(scoreNum)\n    && minScore !== null\n    && maxScore !== null\n    && scoreNum >= minScore\n    && scoreNum <= maxScore;\n\n  if (isNonEmptyString(jobId) && typeof resolved === 'boolean' && scoreOk) {\n    feedbackPayload = {\n      job_id: String(jobId).trim(),\n      resolved,\n      smile_score: scoreNum,\n      comment: isNonEmptyString(comment) ? String(comment).trim() : '',\n      actor: base.actor ?? {}\n    };\n  }\n}\n\nconst toolCalls = Array.isArray(parsed?.tool_calls) ? parsed.tool_calls : [];\nconst ragRoute = isObject(parsed?.rag_route) ? parsed.rag_route : null;\n\nreturn [{\n  json: {\n    ...base,\n    intent,\n    event_kind: intent,\n    normalized_event: normalized,\n    next_action: resolvedNextAction,\n    required_confirm: parsed?.required_confirm ?? null,\n    missing_params: missingParams,\n    clarifying_questions: clarifyingQuestions,\n    initial_reply: initialReply,\n    llm_ok: Boolean(parsed && eventKindOk),\n    llm_output: parsed,\n    tool_calls: toolCalls,\n    rag_route: ragRoute,\n    decision,\n    approval_token: approvalToken,\n    approver_actor: base.actor ?? {},\n    feedback_payload: feedbackPayload\n  }\n}];\n"
      },
      "id": "70",
      "name": "Parse Chat Core Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3080,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const base = $json ?? {};\nconst source = String(base.source ?? base.reply_target?.source ?? base.normalized_event?.source ?? '').trim().toLowerCase();\n\nif (source === 'cloudwatch' && (base.intent === 'other' || base.event_kind === 'other')) {\n  base.intent = 'request';\n  base.event_kind = 'request';\n}\n\nreturn [{ json: base }];\n"
      },
      "id": "200",
      "name": "Force CloudWatch Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3180,
        420
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.source}}",
              "value2": "cloudwatch",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "201",
      "name": "IF CloudWatch Source (After Parse)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        3260,
        420
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.intent}}",
              "value2": "other",
              "operation": "equal"
            }
          ]
        }
      },
      "id": "71",
      "name": "IF Event Kind Other",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        3300,
        420
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ (() => {\n  const raw = $json.normalized_event?.text ?? $json.text ?? '';\n  let text = String(raw ?? '').trim();\n  // Strip Zulip mention like @**Bot Name**\n  text = text.replace(/^(@\\*\\*[^*]+\\*\\*\\s*)+/, '').trim();\n  // Strip OQ runner suffix like (OQ-HELLO-...)\n  text = text.replace(/\\(OQ-HELLO-[^)]+\\)\\s*$/i, '').trim();\n\n  const isMatch = (re) => re.test(text);\n  const isGreeting = text.length > 0 && (\n    isMatch(/^(おはよう|お早う|こんにちは|こんばんは|はじめまして|やあ|もしもし|お疲れ様|おつかれ)(\\b|\\s|$)/i)\n    || isMatch(/^(hi|hello|hey|good\\s*(morning|afternoon|evening))(\\b|\\s|$)/i)\n  );\n  const isThanks = text.length > 0 && (\n    isMatch(/(ありがとう|ありがと|助かる|感謝)/i)\n    || isMatch(/\\b(thanks|thank\\s+you)\\b/i)\n  );\n  const isBye = text.length > 0 && (\n    isMatch(/(さようなら|またね|失礼します|おやすみ|bye|good\\s*night)/i)\n  );\n\n  const isSmalltalk = isGreeting || isThanks || isBye;\n  return ($json.needs_clarification === true) && !isSmalltalk;\n})() }}",
              "value2": true,
              "operation": "equal"
            }
          ]
        }
      },
      "id": "72",
      "name": "IF Needs Clarification (Other)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        3520,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const replyTarget = $json.reply_target ?? {};\nconst source = replyTarget.source ?? $json.source ?? 'unknown';\nconst questions = Array.isArray($json.clarifying_questions) ? $json.clarifying_questions : [];\n\nlet content = '入力の意図を判別できませんでした。';\nif (questions.length) {\n  content += `\\n\\n確認:\\n- ${questions.join('\\n- ')}`;\n}\ncontent += '\\n\\n依頼（request）・承認（approval）・評価（feedback）のいずれかとして、もう一度入力してください。';\n\nreturn [{\n  json: {\n    ...$json,\n    reply_target: replyTarget,\n    content,\n    source\n  }\n}];\n"
      },
      "id": "73",
      "name": "Build Clarification Message (Other)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3740,
        420
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE aiops_context\nSET normalized_event = normalized_event || COALESCE(NULLIF('{{ JSON.stringify($json.normalized_event || {}) }}','undefined')::jsonb, '{}'::jsonb)\nWHERE context_id = NULLIF(NULLIF('{{ $json.context_id }}',''), 'undefined')::uuid;"
      },
      "id": "203",
      "name": "Update Normalized Event (Other)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        3520,
        560
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "return $items('Debug Log Before: Update Normalized Event (Other) <- IF Event Kind Other');\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9270",
      "name": "Restore Context (Other)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3600,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const replyTarget = $json.reply_target ?? {};\nconst source = replyTarget.source ?? $json.source ?? 'unknown';\nconst normalizedEvent = $json.normalized_event ?? {};\nconst rawText = normalizedEvent.text ?? $json.text ?? '';\nlet text = String(rawText ?? '').trim();\ntext = text.replace(/^(?:@\\*\\*[^*]+\\*\\*\\s*)+/, '').trim();\ntext = text.replace(/\\(OQ-HELLO-[^)]+\\)\\s*$/i, '').trim();\n\nconst isMatch = (re) => re.test(text);\nconst isGreeting = text.length > 0 && (\n  isMatch(/^(おはよう|お早う|こんにちは|こんばんは|はじめまして|やあ|もしもし|お疲れ様|おつかれ)(\\b|\\s|$)/i)\n  || isMatch(/^(hi|hello|hey|good\\s*(morning|afternoon|evening))(\\b|\\s|$)/i)\n);\nconst isThanks = text.length > 0 && (\n  isMatch(/(ありがとう|ありがと|助かる|感謝)/i)\n  || isMatch(/\\b(thanks|thank\\s+you)\\b/i)\n);\nconst isBye = text.length > 0 && (\n  isMatch(/(さようなら|またね|失礼します|おやすみ|bye|good\\s*night)/i)\n);\n\nlet content = '';\nif (isGreeting) {\n  content = 'こんにちは！';\n} else if (isThanks) {\n  content = 'どういたしまして！';\n} else if (isBye) {\n  content = '了解です。またいつでも声をかけてください。';\n} else if (!text) {\n  content = '了解です。ご用件があれば気軽に教えてください。';\n} else {\n  content = '承知しました。ご用件があれば気軽に続けてください。';\n}\n\ncontent += '\\n\\n例:「○○のアラート原因を調べて」「この変更を承認して」「プレビュー結果を評価して」';\n\nreturn [{\n  json: {\n    ...$json,\n    reply_target: replyTarget,\n    content,\n    source\n  }\n}];\n"
      },
      "id": "204",
      "name": "Build Friendly Reply (Other)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3960,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const workflowContext = this;\nconst input = $json ?? {};\nconst iam = input.iam_context ?? {};\nconst policyContext = input.policy_context ?? {};\n\nconst realm = iam.realm\n  ?? input.reply_target?.realm\n  ?? input.reply_target?.tenant\n  ?? 'default';\n\nconst ttlSecondsRaw = $env.N8N_GITLAB_CACHE_TTL_SECONDS ?? '300';\nconst ttlSeconds = Number.parseInt(String(ttlSecondsRaw), 10);\nconst ttlMs = Number.isFinite(ttlSeconds) ? Math.max(30, ttlSeconds) * 1000 : 300000;\n\nconst cache = workflowContext.getWorkflowStaticData('global');\nconst cacheKey = `gitlab:escalation:${realm}`;\n\nconst baseUrl = String($env.GITLAB_API_BASE_URL || $env.GITLAB_API_BASE_URL || '').replace(/\\/$/, '');\nconst token = $env.N8N_GITLAB_TOKEN || $env.GITLAB_TOKEN || '';\nconst ref = $env.N8N_GITLAB_REF || 'main';\n\nconst realmKey = String(realm || '').toUpperCase().replace(/[^A-Z0-9]+/g, '_');\nconst projectPath = $env[`N8N_GITLAB_PROJECT_PATH_${realmKey}`] || $env.N8N_GITLAB_PROJECT_PATH || '';\nconst filePath = $env[`N8N_GITLAB_ESCALATION_MD_PATH_${realmKey}`] || $env.N8N_GITLAB_ESCALATION_MD_PATH || '';\n\nfunction errorPayload(message, meta) {\n  return [{ json: { ...input, routing_candidates: [], context_age_minutes: null, escalation_source: 'gitlab', escalation_error: message, escalation_meta: meta || {} } }];\n}\n\nfunction splitRow(line) {\n  return line.trim().replace(/^\\|/, '').replace(/\\|$/, '').split('|').map((v) => v.trim());\n}\n\nfunction parseTable(text) {\n  const lines = String(text || '').split(/\\r?\\n/);\n  let headerIdx = -1;\n  for (let i = 0; i < lines.length; i += 1) {\n    const line = lines[i].trim();\n    if (line.startsWith('|') && line.includes('|')) {\n      headerIdx = i;\n      break;\n    }\n  }\n  if (headerIdx < 0 || headerIdx + 1 >= lines.length) return { headers: [], rows: [] };\n  const headers = splitRow(lines[headerIdx]).map((h) => h.toLowerCase());\n  const rows = [];\n  for (let i = headerIdx + 2; i < lines.length; i += 1) {\n    const line = lines[i].trim();\n    if (!line.startsWith('|')) break;\n    if (line.replace(/\\s/g, '').startsWith('|---')) continue;\n    const cols = splitRow(line);\n    if (cols.length === 1 && cols[0] === '') continue;\n    rows.push(cols);\n  }\n  return { headers, rows };\n}\n\nfunction cleanText(value) {\n  if (value === null || value === undefined) return null;\n  const trimmed = String(value).trim();\n  if (!trimmed || trimmed.toLowerCase() === 'null') return null;\n  return trimmed;\n}\n\nfunction parseBool(value, fallback) {\n  const cleaned = cleanText(value);\n  if (cleaned === null) return fallback;\n  const v = cleaned.toLowerCase();\n  if (['true', '1', 'yes', 'y'].includes(v)) return true;\n  if (['false', '0', 'no', 'n'].includes(v)) return false;\n  return fallback;\n}\n\nfunction parseIntOrNull(value) {\n  const cleaned = cleanText(value);\n  if (cleaned === null) return null;\n  const parsed = Number.parseInt(cleaned, 10);\n  return Number.isFinite(parsed) ? parsed : null;\n}\n\nfunction parseJsonValue(value, fallback) {\n  const cleaned = cleanText(value);\n  if (cleaned === null) return fallback;\n  if (cleaned.startsWith('{') || cleaned.startsWith('[')) {\n    try {\n      return JSON.parse(cleaned);\n    } catch (error) {\n      return fallback;\n    }\n  }\n  return fallback;\n}\n\nfunction parseList(value) {\n  const cleaned = cleanText(value);\n  if (cleaned === null) return [];\n  if (cleaned.startsWith('[')) {\n    const parsed = parseJsonValue(cleaned, []);\n    return Array.isArray(parsed) ? parsed : [];\n  }\n  return cleaned.split(',').map((v) => v.trim()).filter(Boolean);\n}\n\nfunction normalizeRow(entry) {\n  const normalized = { ...entry };\n  const lowerFields = ['category', 'impact', 'urgency', 'priority', 'escalation_type'];\n  for (const key of lowerFields) {\n    if (normalized[key]) normalized[key] = String(normalized[key]).trim().toLowerCase();\n  }\n  return normalized;\n}\n\nasync function fetchMarkdown() {\n  if (!baseUrl || !projectPath || !filePath) return null;\n  const projectEncoded = encodeURIComponent(projectPath);\n  const fileEncoded = encodeURIComponent(filePath);\n  const url = `${baseUrl}/projects/${projectEncoded}/repository/files/${fileEncoded}/raw?ref=${encodeURIComponent(ref)}`;\n  const headers = token ? { 'PRIVATE-TOKEN': token } : {};\n  return await workflowContext.helpers.httpRequest({ method: 'GET', url, headers, json: false });\n}\n\nconst cached = cache?.[cacheKey] || null;\nconst cacheFresh = cached && cached.fetched_at && (Date.now() - cached.fetched_at) < ttlMs;\nlet rows = cacheFresh ? cached.rows : null;\nlet usedCache = cacheFresh;\nlet fetchError = null;\n\nif (!rows) {\n  try {\n    const markdown = await fetchMarkdown();\n    const table = parseTable(markdown);\n    if (!table.headers.length) throw new Error('table_not_found');\n    rows = table.rows.map((cols) => {\n      const entry = {};\n      table.headers.forEach((header, idx) => {\n        entry[header] = cols[idx] ?? null;\n      });\n      const parsed = {\n        policy_id: cleanText(entry.policy_id),\n        policy_name: cleanText(entry.policy_name),\n        category: cleanText(entry.category),\n        subcategory: cleanText(entry.subcategory),\n        service_name: cleanText(entry.service_name),\n        ci_name: cleanText(entry.ci_name),\n        impact: cleanText(entry.impact),\n        urgency: cleanText(entry.urgency),\n        priority: cleanText(entry.priority),\n        escalation_level: parseIntOrNull(entry.escalation_level),\n        escalation_type: cleanText(entry.escalation_type),\n        assignment_group: cleanText(entry.assignment_group),\n        assignment_role: cleanText(entry.assignment_role),\n        reply_target: parseJsonValue(entry.reply_target, {}),\n        escalation_target: parseJsonValue(entry.escalation_target, null),\n        notify_targets: parseJsonValue(entry.notify_targets, null) || parseList(entry.notify_targets),\n        response_sla_minutes: parseIntOrNull(entry.response_sla_minutes),\n        resolution_sla_minutes: parseIntOrNull(entry.resolution_sla_minutes),\n        escalate_after_minutes: parseIntOrNull(entry.escalate_after_minutes),\n        active: parseBool(entry.active, true),\n        effective_from: cleanText(entry.effective_from),\n        effective_to: cleanText(entry.effective_to)\n      };\n      return normalizeRow(parsed);\n    });\n    cache[cacheKey] = { fetched_at: Date.now(), rows };\n  } catch (error) {\n    fetchError = error?.message ? String(error.message) : String(error);\n    rows = cached?.rows || [];\n    usedCache = Boolean(cached?.rows);\n  }\n}\n\nconst normalizedEvent = input.normalized_event ?? {};\nconst defaults = policyContext?.defaults?.routing_candidate_query ?? {};\nconst limits = policyContext?.limits?.routing_candidates ?? {};\nconst maxCandidates = Number.isFinite(Number(limits.max_candidates))\n  ? Math.max(1, Math.floor(Number(limits.max_candidates)))\n  : 20;\n\nconst category = String(normalizedEvent?.classification?.category ?? defaults.category ?? 'service_request').toLowerCase();\nconst impact = String(normalizedEvent?.impact ?? defaults.impact ?? 'medium').toLowerCase();\nconst urgency = String(normalizedEvent?.urgency ?? defaults.urgency ?? 'medium').toLowerCase();\nconst priority = String(normalizedEvent?.priority ?? defaults.priority ?? 'p3').toLowerCase();\n\nconst serviceName = normalizedEvent?.service_name ?? normalizedEvent?.metadata?.service_name ?? null;\nconst ciName = normalizedEvent?.ci_name ?? normalizedEvent?.ci_ref ?? normalizedEvent?.metadata?.ci_ref ?? null;\n\nconst candidates = (rows || []).filter((row) => {\n  if (!row || row.active === false) return false;\n  if (row.category && row.category !== category) return false;\n  if (row.impact && row.impact !== impact) return false;\n  if (row.urgency && row.urgency !== urgency) return false;\n  if (row.priority && row.priority !== priority) return false;\n  if (row.service_name && serviceName && row.service_name !== serviceName) return false;\n  if (row.ci_name && ciName && row.ci_name !== ciName) return false;\n  if (row.service_name && !serviceName) return false;\n  if (row.ci_name && !ciName) return false;\n  return true;\n}).sort((a, b) => {\n  const aTime = a.effective_from ? Date.parse(a.effective_from) : 0;\n  const bTime = b.effective_from ? Date.parse(b.effective_from) : 0;\n  if (aTime !== bTime) return bTime - aTime;\n  const aLevel = Number.isFinite(Number(a.escalation_level)) ? Number(a.escalation_level) : 0;\n  const bLevel = Number.isFinite(Number(b.escalation_level)) ? Number(b.escalation_level) : 0;\n  return aLevel - bLevel;\n}).slice(0, maxCandidates);\n\nconst meta = {\n  realm,\n  project_path: projectPath || null,\n  file_path: filePath || null,\n  ref,\n  cached: usedCache,\n  cache_ttl_seconds: Math.floor(ttlMs / 1000)\n};\nif (fetchError) meta.error = fetchError;\n\nreturn [{\n  json: {\n    ...input,\n    routing_candidates: candidates,\n    context_age_minutes: input.context_age_minutes ?? null,\n    escalation_source: 'gitlab',\n    escalation_meta: meta\n  }\n}];\n"
      },
      "id": "58",
      "name": "Load Escalation Matrix (GitLab)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2320,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst base = $json ?? {};\n\nconst normalizedEvent = { ...(base.normalized_event ?? {}) };\ndelete normalizedEvent.raw_headers;\ndelete normalizedEvent.raw_body;\n\nconst input = {\n  normalized_event: normalizedEvent,\n  routing_candidates: base.routing_candidates ?? [],\n  context_age_minutes: base.context_age_minutes ?? null,\n  reply_target: base.reply_target ?? null,\n  policy_context: base.policy_context ?? {}\n};\n\nconst promptText = \"__PROMPT__ROUTING_DECIDE__\";\nconst promptHash = crypto.createHash('sha256').update(promptText).digest('hex');\n\nreturn [{\n  json: {\n    ...base,\n    prompt_key: 'adapter.routing_decide.v1',\n    prompt_version: 'ja-1',\n    prompt_text: promptText,\n    prompt_hash: promptHash,\n    prompt_input: JSON.stringify(input)\n  }\n}];\n"
      },
      "id": "61",
      "name": "Build Routing Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2540,
        520
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO aiops_prompt_history (prompt_key, prompt_version, prompt_text, prompt_hash, source_workflow, source_node)\nVALUES (\n  '{{ String($json.prompt_key ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_version ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_text ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_hash ?? \"\").replace(/'/g, \"''\") }}',\n  'aiops-adapter-ingest',\n  'OpenAI Routing Decide'\n)\nON CONFLICT (prompt_key, prompt_hash) DO NOTHING;"
      },
      "id": "62",
      "name": "Record Prompt History (Routing)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        2760,
        520
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "operation": "complete",
        "model": "={{$env.OPENAI_MODEL || 'gpt-4o-mini'}}",
        "prompt": {
          "messages": [
            {
              "role": "system",
              "content": "={{ $node['Build Routing Prompt (JP)'].json.prompt_text }}"
            },
            {
              "role": "user",
              "content": "={{ '入力:\\n' + $node['Build Routing Prompt (JP)'].json.prompt_input }}"
            }
          ]
        },
        "options": {
          "temperature": 0.2,
          "baseURL": "={{$env.OPENAI_BASE_URL}}",
          "maxTokens": "={{$json.policy_context?.limits?.llm_output_tokens || 1200}}"
        }
      },
      "id": "63",
      "name": "OpenAI Routing Decide",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        2980,
        520
      ],
      "credentials": {
        "openAiApi": {
          "name": "aiops-openai"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "const base = $node['Build Routing Prompt (JP)'].json ?? {};\nconst response = $json ?? {};\n\nconst extractContent = (payload) => {\n  return payload?.message?.content\n    ?? payload?.choices?.[0]?.message?.content\n    ?? payload?.choices?.[0]?.text\n    ?? payload?.data?.choices?.[0]?.message?.content\n    ?? payload?.data?.choices?.[0]?.text\n    ?? payload?.content\n    ?? '';\n};\n\nconst rawContent = extractContent(response);\nlet parsed = null;\nif (typeof rawContent === 'string') {\n  try {\n    parsed = JSON.parse(rawContent);\n  } catch (error) {\n    const match = rawContent.match(/\\{[\\s\\S]*\\}/);\n    if (match) {\n      try {\n        parsed = JSON.parse(match[0]);\n      } catch (inner) {\n        parsed = null;\n      }\n    }\n  }\n} else if (rawContent && typeof rawContent === 'object') {\n  parsed = rawContent;\n}\n\nconst policyContext = base.policy_context ?? {};\nconst maxClarifying = Number.isFinite(Number(policyContext?.limits?.routing_decide?.max_clarifying_questions))\n  ? Math.max(0, Math.floor(Number(policyContext.limits.routing_decide.max_clarifying_questions)))\n  : null;\n\nconst isObject = (v) => Boolean(v) && typeof v === 'object' && !Array.isArray(v);\n\nlet ok = isObject(parsed);\nif (ok) {\n  ok = typeof parsed.confidence === 'number'\n    && typeof parsed.rationale === 'string'\n    && 'routing' in parsed\n    && isObject(parsed.routing)\n    && isObject(parsed.routing.reply_target)\n    && Array.isArray(parsed.routing.notify_targets)\n    && Array.isArray(parsed.clarifying_questions);\n}\n\nif (ok && maxClarifying !== null) {\n  parsed.clarifying_questions = parsed.clarifying_questions.slice(0, maxClarifying);\n}\n\nreturn [{\n  json: {\n    ...base,\n    llm_routing_ok: ok,\n    routing_decision: parsed,\n    routing_decision_raw: typeof rawContent === 'string' ? rawContent : JSON.stringify(rawContent ?? '')\n  }\n}];\n"
      },
      "id": "64",
      "name": "Parse Routing Decide Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3200,
        520
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ (() => { let text = String($json.normalized_event?.text ?? $json.text ?? '').trim(); while (text.startsWith('@**')) { const end = text.indexOf('**', 3); if (end < 0) break; text = text.slice(end + 2).trimStart(); } const oq = text.lastIndexOf('(OQ-HELLO-'); if (oq >= 0 && text.endsWith(')')) { text = text.slice(0, oq).trim(); } const lower = text.toLowerCase(); const isGreeting = lower.startsWith('おはよう') || lower.startsWith('お早う') || lower.startsWith('こんにちは') || lower.startsWith('こんばんは') || lower.startsWith('はじめまして') || lower.startsWith('やあ') || lower.startsWith('もしもし') || lower.startsWith('お疲れ様') || lower.startsWith('おつかれ') || lower.startsWith('hi') || lower.startsWith('hello') || lower.startsWith('hey') || lower.startsWith('good morning') || lower.startsWith('good afternoon') || lower.startsWith('good evening'); const isThanks = lower.includes('ありがとう') || lower.includes('ありがと') || lower.includes('助かる') || lower.includes('感謝') || lower.includes('thanks') || lower.includes('thank you'); const isBye = lower.includes('さようなら') || lower.includes('またね') || lower.includes('失礼します') || lower.includes('おやすみ') || lower.includes('bye') || lower.includes('good night'); const isSmalltalk = isGreeting || isThanks || isBye; return ($json.needs_clarification === true) && !isSmalltalk; })() }}",
              "value2": true,
              "operation": "equal"
            }
          ]
        }
      },
      "id": "65",
      "name": "IF Routing Decide OK",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        3420,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "const base = $json ?? {};\nconst decision = base.routing_decision ?? null;\nconst candidates = Array.isArray(base.routing_candidates) ? base.routing_candidates : [];\n\nconst policyContext = base.policy_context ?? {};\nconst fallbacks = policyContext?.fallbacks?.routing_decide ?? {};\nconst reasonMap = fallbacks.reason_map ?? {};\nconst fallbackConfidence = typeof fallbacks.confidence === 'number' ? fallbacks.confidence : 0;\nconst fallbackNeedsManual = typeof fallbacks.needs_manual_triage === 'boolean' ? fallbacks.needs_manual_triage : true;\n\nconst isObject = (v) => Boolean(v) && typeof v === 'object' && !Array.isArray(v);\nconst asIntOrNull = (value) => {\n  if (value === null || value === undefined || value === '') return null;\n  const parsed = Number.parseInt(String(value), 10);\n  return Number.isFinite(parsed) ? parsed : null;\n};\n\nconst originalReplyTarget = base.reply_target ?? null;\n\nfunction fallback(reasonKey) {\n  const reason = reasonMap?.[reasonKey] ?? reasonKey;\n  const normalized = { ...(base.normalized_event ?? {}) };\n  normalized.routing = {\n    policy_id: null,\n    escalation_level: null,\n    reply_target: originalReplyTarget,\n    escalation_target: null,\n    notify_targets: [],\n    needs_manual_triage: fallbackNeedsManual,\n    rationale: reason,\n    confidence: fallbackConfidence,\n    original_reply_target: originalReplyTarget\n  };\n  normalized.routing_decision = {\n    selected_policy_id: null,\n    selected_escalation_level: null,\n    escalate_now: false,\n    needs_manual_triage: fallbackNeedsManual,\n    confidence: fallbackConfidence,\n    rationale: reason,\n    clarifying_questions: []\n  };\n\n  return [{\n    json: {\n      ...base,\n      normalized_event: normalized,\n      reply_target: originalReplyTarget\n    }\n  }];\n}\n\nif (!isObject(decision)) {\n  return fallback('output_missing');\n}\n\nconst selectedPolicyId = decision.selected_policy_id ?? null;\nconst selectedLevel = asIntOrNull(decision.selected_escalation_level);\nif (!selectedPolicyId || typeof selectedPolicyId !== 'string') {\n  return fallback('selected_policy_id_missing');\n}\n\nconst selectedRow = candidates.find((row) => {\n  if (!row || row.policy_id !== selectedPolicyId) return false;\n  if (selectedLevel === null) return true;\n  return asIntOrNull(row.escalation_level) === selectedLevel;\n}) ?? null;\n\nif (!selectedRow) {\n  return fallback('selected_policy_not_found');\n}\n\nconst replyTarget = selectedRow.reply_target ?? originalReplyTarget;\nif (!isObject(replyTarget)) {\n  return fallback('reply_target_missing');\n}\n\nconst routing = {\n  policy_id: selectedRow.policy_id,\n  policy_name: selectedRow.policy_name ?? null,\n  escalation_level: asIntOrNull(selectedRow.escalation_level) ?? selectedLevel,\n  escalation_type: selectedRow.escalation_type ?? null,\n  assignment_group: selectedRow.assignment_group ?? null,\n  assignment_role: selectedRow.assignment_role ?? null,\n  reply_target: replyTarget,\n  escalation_target: isObject(selectedRow.escalation_target) ? selectedRow.escalation_target : null,\n  notify_targets: Array.isArray(selectedRow.notify_targets) ? selectedRow.notify_targets : [],\n  response_sla_minutes: selectedRow.response_sla_minutes ?? null,\n  resolution_sla_minutes: selectedRow.resolution_sla_minutes ?? null,\n  escalate_after_minutes: selectedRow.escalate_after_minutes ?? null,\n  escalate_now: Boolean(decision.escalate_now),\n  needs_manual_triage: Boolean(decision.needs_manual_triage),\n  confidence: typeof decision.confidence === 'number' ? decision.confidence : null,\n  rationale: typeof decision.rationale === 'string' ? decision.rationale : null,\n  clarifying_questions: Array.isArray(decision.clarifying_questions) ? decision.clarifying_questions : []\n};\n\nrouting.original_reply_target = originalReplyTarget;\n\nconst normalized = { ...(base.normalized_event ?? {}) };\nnormalized.routing = routing;\nnormalized.routing_decision = {\n  selected_policy_id: selectedPolicyId,\n  selected_escalation_level: selectedLevel,\n  escalate_now: Boolean(decision.escalate_now),\n  needs_manual_triage: Boolean(decision.needs_manual_triage),\n  confidence: typeof decision.confidence === 'number' ? decision.confidence : null,\n  rationale: typeof decision.rationale === 'string' ? decision.rationale : null,\n  clarifying_questions: Array.isArray(decision.clarifying_questions) ? decision.clarifying_questions : []\n};\n\nreturn [{\n  json: {\n    ...base,\n    normalized_event: normalized,\n    reply_target: replyTarget\n  }\n}];\n"
      },
      "id": "66",
      "name": "Apply Selected Routing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3640,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const base = $json ?? {};\nconst originalReplyTarget = base.reply_target ?? null;\n\nconst policyContext = base.policy_context ?? {};\nconst fallbacks = policyContext?.fallbacks?.routing_decide ?? {};\nconst reasonMap = fallbacks.reason_map ?? {};\nconst fallbackConfidence = typeof fallbacks.confidence === 'number' ? fallbacks.confidence : 0;\nconst fallbackNeedsManual = typeof fallbacks.needs_manual_triage === 'boolean' ? fallbacks.needs_manual_triage : true;\n\nconst reason = reasonMap?.output_missing ?? 'routing_decide_failed_manual_triage';\n\nconst normalized = { ...(base.normalized_event ?? {}) };\nnormalized.routing = {\n  policy_id: null,\n  escalation_level: null,\n  reply_target: originalReplyTarget,\n  escalation_target: null,\n  notify_targets: [],\n  needs_manual_triage: fallbackNeedsManual,\n  rationale: reason,\n  confidence: fallbackConfidence,\n  original_reply_target: originalReplyTarget\n};\n\nnormalized.routing_decision = {\n  selected_policy_id: null,\n  selected_escalation_level: null,\n  escalate_now: false,\n  needs_manual_triage: fallbackNeedsManual,\n  confidence: fallbackConfidence,\n  rationale: reason,\n  clarifying_questions: []\n};\n\nreturn [{\n  json: {\n    ...base,\n    normalized_event: normalized,\n    reply_target: originalReplyTarget\n  }\n}];\n"
      },
      "id": "59",
      "name": "Apply Escalation Routing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2540,
        660
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE aiops_context\nSET\n  normalized_event = normalized_event || COALESCE(NULLIF('{{ JSON.stringify($json.normalized_event || {}) }}','undefined')::jsonb, '{}'::jsonb),\n  reply_target = COALESCE(NULLIF('{{ JSON.stringify($json.reply_target || {}) }}','undefined')::jsonb, reply_target)\nWHERE context_id = NULLIF(NULLIF('{{ $json.context_id }}',''), 'undefined')::uuid;\n\nSELECT\n  NULLIF(NULLIF('{{ $json.context_id }}',''), 'undefined')::uuid AS context_id,\n  '{{ $json.source }}' AS source,\n  COALESCE(NULLIF('{{ JSON.stringify($json.reply_target || {}) }}','undefined')::jsonb, '{}'::jsonb) AS reply_target,\n  COALESCE(NULLIF('{{ JSON.stringify($json.actor || {}) }}','undefined')::jsonb, '{}'::jsonb) AS actor,\n  COALESCE(NULLIF('{{ JSON.stringify($json.normalized_event || {}) }}','undefined')::jsonb, '{}'::jsonb) AS normalized_event,\n  '{{ $json.dedupe_key }}' AS dedupe_key,\n  COALESCE(NULLIF('{{ JSON.stringify($json.iam_context || {}) }}','undefined')::jsonb, '{}'::jsonb) AS iam_context,\n  COALESCE(NULLIF('{{ JSON.stringify($json.policy_context || {}) }}','undefined')::jsonb, '{}'::jsonb) AS policy_context;"
      },
      "id": "60",
      "name": "Update Routing Context",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        2760,
        660
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst base = $json ?? {};\n\nconst source = base.source ?? base.reply_target?.source ?? 'unknown';\n\nlet sourceCapabilities = null;\ntry {\n  const policy = JSON.parse(\"__POLICY__SOURCE_CAPABILITIES__\");\n  sourceCapabilities = policy?.sources?.[source] ?? null;\n} catch (error) {\n  sourceCapabilities = null;\n}\n\nconst jobPlan = base.job_plan ?? base.jobPlan ?? base.preview?.job_plan ?? {};\nconst nextAction = jobPlan.next_action ?? base.next_action ?? null;\n\nconst input = {\n  policy_context: base.policy_context ?? {},\n  context: {\n    source,\n    source_capabilities: sourceCapabilities,\n    reply_target: base.reply_target ?? null,\n    classification: base.normalized_event?.classification ?? null,\n    reply_plan: base.normalized_event?.routing ?? base.reply_plan ?? null,\n    user_text: base.normalized_event?.text ?? null,\n    pii_redaction: base.normalized_event?.pii_redaction ?? null\n  },\n  preview: {\n    job_plan: jobPlan,\n    required_confirm: base.required_confirm ?? null,\n    approval_id: base.approval_id ?? null,\n    expires_at: base.expires_at ?? null\n  },\n  approval: {\n    approval_token: base.approval_token ?? null,\n    approval_base_url: ($env.N8N_APPROVAL_BASE_URL || $env.N8N_ADAPTER_BASE_URL || '').replace(/\\/$/, '') || null\n  },\n  enqueue: {\n    job_id: base.job_id ?? null\n  }\n};\n\nconst promptText = \"__PROMPT__INITIAL_REPLY__\";\nconst promptHash = crypto.createHash('sha256').update(promptText).digest('hex');\n\nreturn [{\n  json: {\n    ...base,\n    source,\n    next_action: nextAction,\n    prompt_key: 'adapter.initial_reply.v1',\n    prompt_version: 'ja-1',\n    prompt_text: promptText,\n    prompt_hash: promptHash,\n    prompt_input: JSON.stringify(input)\n  }\n}];\n"
      },
      "id": "74",
      "name": "Build Initial Reply Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2580,
        140
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO aiops_prompt_history (prompt_key, prompt_version, prompt_text, prompt_hash, source_workflow, source_node)\nVALUES (\n  '{{ String($json.prompt_key ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_version ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_text ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_hash ?? \"\").replace(/'/g, \"''\") }}',\n  'aiops-adapter-ingest',\n  'OpenAI Initial Reply'\n)\nON CONFLICT (prompt_key, prompt_hash) DO NOTHING;"
      },
      "id": "75",
      "name": "Record Prompt History (Initial Reply)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        2800,
        140
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "operation": "complete",
        "model": "={{$env.OPENAI_MODEL || 'gpt-4o-mini'}}",
        "prompt": {
          "messages": [
            {
              "role": "system",
              "content": "={{ $node['Build Initial Reply Prompt (JP)'].json.prompt_text }}"
            },
            {
              "role": "user",
              "content": "={{ '入力:\\n' + $node['Build Initial Reply Prompt (JP)'].json.prompt_input }}"
            }
          ]
        },
        "options": {
          "temperature": 0.2,
          "baseURL": "={{$env.OPENAI_BASE_URL}}",
          "maxTokens": "={{$json.policy_context?.limits?.llm_output_tokens || 1200}}"
        }
      },
      "id": "76",
      "name": "OpenAI Initial Reply",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        3020,
        140
      ],
      "credentials": {
        "openAiApi": {
          "name": "aiops-openai"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "const base = $json ?? {};\n\nfunction normalizeNewlines(raw) {\n  let text = String(raw ?? '');\n  if (!text) return text;\n  // Normalize actual CRLF/CR\n  text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  // Normalize double-escaped sequences (e.g., \"\\\\n\")\n  text = text.replace(/\\\\r\\\\n/g, '\\n').replace(/\\\\n/g, '\\n').replace(/\\\\r/g, '\\n');\n  return text;\n}\n\nconst extractContent = (payload) => {\n  return payload?.message?.content\n    ?? payload?.choices?.[0]?.message?.content\n    ?? payload?.choices?.[0]?.text\n    ?? payload?.data?.choices?.[0]?.message?.content\n    ?? payload?.data?.choices?.[0]?.text\n    ?? payload?.content\n    ?? '';\n};\n\nconst rawContent = extractContent(base);\nlet parsed = null;\nif (typeof rawContent === 'string') {\n  try {\n    parsed = JSON.parse(rawContent);\n  } catch (error) {\n    const match = rawContent.match(/\\{[\\s\\S]*\\}/);\n    if (match) {\n      try {\n        parsed = JSON.parse(match[0]);\n      } catch (inner) {\n        parsed = null;\n      }\n    }\n  }\n} else if (rawContent && typeof rawContent === 'object') {\n  parsed = rawContent;\n}\n\nconst isObject = (v) => Boolean(v) && typeof v === 'object' && !Array.isArray(v);\n\nconst limits = base.policy_context?.limits?.initial_reply ?? {};\nconst maxClarifying = Number.isFinite(Number(limits.max_clarifying_questions))\n  ? Math.max(0, Math.floor(Number(limits.max_clarifying_questions)))\n  : 2;\n\nconst ok = isObject(parsed) && typeof parsed.content === 'string';\n\nconst initialReply = ok ? {\n  content: normalizeNewlines(parsed.content),\n  needs_clarification: typeof parsed.needs_clarification === 'boolean' ? parsed.needs_clarification : false,\n  clarifying_questions: Array.isArray(parsed.clarifying_questions)\n    ? parsed.clarifying_questions.map((v) => String(v ?? '').trim()).filter(Boolean).slice(0, maxClarifying)\n    : [],\n  confidence: typeof parsed.confidence === 'number' ? parsed.confidence : 0,\n  rationale: typeof parsed.rationale === 'string' ? parsed.rationale : ''\n} : null;\n\nreturn [{\n  json: {\n    ...base,\n    initial_reply: initialReply\n  }\n}];\n"
      },
      "id": "parse-initial-reply-ja",
      "name": "Parse Initial Reply Response (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3120,
        140
      ]
    },
    {
      "parameters": {
        "jsCode": "const base = $json ?? {};\n\nconst replyTarget = base.reply_target ?? {};\nconst source = base.source ?? replyTarget.source ?? 'unknown';\n\nconst isObject = (v) => Boolean(v) && typeof v === 'object' && !Array.isArray(v);\nconst initialReply = isObject(base.initial_reply) ? base.initial_reply : null;\n\nconst policyContext = base.policy_context ?? {};\nconst fallbacks = policyContext?.fallbacks?.initial_reply ?? {};\nconst templates = fallbacks.templates ?? {};\nconst defaultTemplate = fallbacks.default_template ?? '依頼内容を確認中です。\\n\\n概要: {summary}';\n\nconst nextAction = base.next_action ?? base.job_plan?.next_action ?? null;\n\nconst normalized = base.normalized_event ?? {};\nlet summary = base.job_plan?.summary || base.summary || normalized.text || 'AI Ops ジョブ';\n\n// Use topic context (DB/API) as a hint for fallback replies.\nconst topicContext = (() => {\n  const fromBase = normalized.zulip_topic_context;\n  if (fromBase && typeof fromBase === 'object') return fromBase;\n\n  const candidates = [\n    'Sanitize Zulip Topic Context Text (DB Fallback)',\n    'Attach Zulip Topic Context (DB Fallback)',\n    'Maybe Fetch Zulip Topic Context'\n  ];\n\n  for (const name of candidates) {\n    try {\n      const ztc = $node[name]?.json?.normalized_event?.zulip_topic_context;\n      if (ztc && typeof ztc === 'object') return ztc;\n    } catch (error) {}\n  }\n  return null;\n})();\n\nconst topicMessagesText = Array.isArray(topicContext?.messages)\n  ? topicContext.messages.map((m) => String(m?.content ?? '')).join(' ')\n  : '';\n\nif (topicMessagesText) {\n  const hints = [];\n  if (topicMessagesText.includes('502')) hints.push('502');\n  if (topicMessagesText.toLowerCase().includes('api')) hints.push('API');\n\n  const summaryText = String(summary ?? '');\n  if (hints.length && !hints.every((h) => summaryText.includes(h))) {\n    summary = `${summaryText}（前提: ${hints.join(' / ')}）`;\n  }\n}\n\nconst jobLine = base.job_id ? `\nジョブID: ${base.job_id}` : '';\nconst expiresAt = base.expires_at ?? '';\n\nconst renderTemplate = (template) => String(template)\n  .split('{summary}').join(summary)\n  .split('{job_line}').join(jobLine)\n  .split('{expires_at}').join(expiresAt || '');\n\nconst fallback = (() => {\n  if (nextAction === 'auto_enqueue' && templates.auto_enqueue) {\n    return renderTemplate(templates.auto_enqueue);\n  }\n  if (nextAction === 'ask_clarification' && templates.ask_clarification) {\n    return renderTemplate(templates.ask_clarification);\n  }\n  if (nextAction === 'reject' && templates.reject) {\n    return renderTemplate(templates.reject);\n  }\n  if (nextAction === 'require_approval' && templates.require_approval) {\n    return renderTemplate(templates.require_approval);\n  }\n  return renderTemplate(defaultTemplate);\n})();\n\nlet content = typeof initialReply?.content === 'string' ? initialReply.content : fallback;\n\nlet clarifyingQuestions = Array.isArray(initialReply?.clarifying_questions) ? initialReply.clarifying_questions : [];\nclarifyingQuestions = clarifyingQuestions.map((q) => String(q ?? '').trim()).filter(Boolean);\n\nif (nextAction === 'ask_clarification' && clarifyingQuestions.length === 0) {\n  const policyDefaults = policyContext?.defaults?.initial_reply ?? {};\n  const defaults = Array.isArray(policyDefaults.fallback_questions)\n    ? policyDefaults.fallback_questions\n    : (Array.isArray(fallbacks.fallback_questions) ? fallbacks.fallback_questions : []);\n\n  const baseDefaults = defaults.length\n    ? defaults\n    : ['依頼内容（何をしたいか）', '対象（サービス名/CI/環境）'];\n\n  clarifyingQuestions = baseDefaults.map((q) => String(q ?? '').trim()).filter(Boolean).slice(0, 2);\n}\n\nif (nextAction === 'ask_clarification') {\n  const contentText = String(content ?? '').trim();\n  const hasKnownSection = /今わかっていること|わかっていること/.test(contentText);\n  const hasUnknownSection = /不明点/.test(contentText);\n  if (!hasKnownSection || !hasUnknownSection) {\n    const known = summary || normalized.text || '（入力を受け取りました）';\n    const unknown = clarifyingQuestions[0] || '追加情報が必要です';\n    const header = [`今わかっていること: ${known}`, `不明点: ${unknown}`].join('\\n');\n    content = `${header}\\n\\n${contentText}`.trim();\n  }\n}\n\nreturn [{\n  json: {\n    ...base,\n    source,\n    reply_target: replyTarget,\n    content,\n    initial_reply_ok: typeof initialReply?.content === 'string',\n    initial_reply_raw: initialReply ? JSON.stringify(initialReply) : '',\n    initial_reply_confidence: typeof initialReply?.confidence === 'number' ? initialReply.confidence : 0,\n    initial_reply_needs_clarification: typeof initialReply?.needs_clarification === 'boolean' ? initialReply.needs_clarification : false,\n    initial_reply_clarifying_questions: clarifyingQuestions\n  }\n}];\n"
      },
      "id": "77",
      "name": "Use Chat Core Reply",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3240,
        140
      ]
    },
    {
      "parameters": {
        "jsCode": "const base = $json ?? {};\nconst nextAction = base.next_action ?? base.job_plan?.next_action ?? null;\nif (nextAction !== 'ask_clarification') {\n  return [{ json: base }];\n}\n\nlet content = typeof base.content === 'string' ? base.content : '';\ncontent = content.trim();\n\nconst hasKnownSection = /今わかっていること/.test(content);\nconst hasUnknownSection = /不明点/.test(content);\n\nconst summary = String(base.job_plan?.summary ?? '').trim();\nconst userText = String(base.normalized_event?.text ?? base.normalized_event?.original_text ?? '').trim();\nconst known = summary || userText || '（入力を受け取りました）';\n\nconst questions = Array.isArray(base.clarifying_questions)\n  ? base.clarifying_questions.map((v) => String(v ?? '').trim()).filter(Boolean)\n  : (Array.isArray(base.initial_reply_clarifying_questions)\n    ? base.initial_reply_clarifying_questions.map((v) => String(v ?? '').trim()).filter(Boolean)\n    : []);\nconst unknown = questions[0] || '追加情報が必要です';\n\nif (!hasKnownSection || !hasUnknownSection) {\n  const header = [\n    `今わかっていること: ${known}`,\n    `不明点: ${unknown}`\n  ].join('\\n');\n  content = `${header}\\n\\n${content}`.trim();\n}\n\nconst hasUncertaintyMarker = /可能性|仮説|不確実|断定/.test(content);\nconst hasEvidenceHint = /ログ|メトリクス|設定/.test(content);\n\nconst lines = [content].filter(Boolean);\nif (!hasUncertaintyMarker) {\n  lines.push('補足: 現時点では情報が不足しており、断定はできません（仮説ベースです）。');\n}\nif (!hasEvidenceHint) {\n  lines.push('次に確認したい観測: ログ / メトリクス / 設定（直近変更）');\n}\n\nreturn [{\n  json: {\n    ...base,\n    content: lines.join('\\n\\n')\n  }\n}];\n"
      },
      "id": "augment-ask-clarification-ja",
      "name": "Augment Ask Clarification (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3440,
        140
      ]
    },
    {
      "parameters": {
        "jsCode": "const base = $json ?? {};\nconst normalized = base.normalized_event ?? {};\n\nconst pii = normalized.pii_redaction ?? base.pii_redaction ?? {};\nconst piiDetected = Boolean(pii && typeof pii === 'object' && pii.detected === true);\n\nconst textCandidates = [\n  normalized.original_text,\n  normalized.text,\n  normalized.raw_body?.message?.content,\n  base.raw_body?.message?.content,\n  base.message?.content,\n];\n\nconst joinedText = textCandidates\n  .map((v) => String(v ?? '').trim())\n  .filter(Boolean)\n  .join('\\n');\n\n// なるべく誤検知を避けつつ、代表的な漏洩パターンは拾う\nconst looksLikeAwsAccessKeyId = /\\b(AKIA|ASIA)[0-9A-Z]{16}\\b/.test(joinedText);\nconst looksLikeSlackToken = /\\bxox[baprs]-\\d{6,}-\\d{6,}-[A-Za-z0-9-]{10,}\\b/.test(joinedText);\nconst looksLikeGitLabToken = /\\bglpat-[A-Za-z0-9_\\-]{10,}\\b/.test(joinedText);\n\nconst shouldGuard = piiDetected || looksLikeAwsAccessKeyId || looksLikeSlackToken || looksLikeGitLabToken;\nif (!shouldGuard) {\n  return [{ json: base }];\n}\n\nconst existing = typeof base.content === 'string' ? base.content : '';\n// すでに誘導が入っている場合は二重付与しない\nif (/伏字|マスク|SSM|Secrets\\s*Manager|貼らない/.test(existing)) {\n  return [{ json: base }];\n}\n\nconst safeContent = [\n  '機密情報（キー/パスワード/トークン等）が含まれている可能性があるため、そのまま扱えません。',\n  '',\n  'お願い：',\n  '1) その投稿を削除/編集できる場合は削除してください（必要なら管理者にも連絡）。',\n  '2) 送ってしまったキー/トークンは失効・ローテーションしてください。',\n  '3) 以後は値（秘密そのもの）は貼らないでください。共有が必要なら、先頭/末尾だけ残して伏字（マスク）にしてください。もしくは SSM/Secrets Manager 等に登録し、参照名だけ送ってください。',\n  '',\n  '差し支えない範囲で、どの種類の秘密（AWS/Slack/GitLab/tfvars など）か教えてください。対応手順を案内します。'\n].join('\\n');\n\nreturn [{\n  json: {\n    ...base,\n    next_action: 'ask_clarification',\n    required_confirm: true,\n    content: safeContent\n  }\n}];\n"
      },
      "id": "secret-handling-guidance-ja",
      "name": "Secret Handling Guidance (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3540,
        140
      ]
    },
    {
      "parameters": {
        "jsCode": "const base = $json ?? {};\nconst normalized = base.normalized_event ?? {};\n\nconst rawText = String(\n  normalized.original_text\n    ?? normalized.raw_body?.message?.content\n    ?? base.raw_body?.message?.content\n    ?? ''\n).trim();\n\n// OQ-19: 用語（SLO）の説明は誤文脈でも最低限返す\nconst isSloQuestion = /\\bSLO\\b/i.test(rawText) && /意味|どういう|何\\s*の/.test(rawText);\nif (!isSloQuestion) {\n  return [{ json: base }];\n}\n\nconst content = [\n  'SLO は **Service Level Objective（サービスレベル目標）** の略で、サービスが満たすべき目標値（例: 30日間の可用性 99.9%、p95 レイテンシ 300ms など）を指します。',\n  '「SLO が落ちている」は、その目標値を下回っている（＝SLO 違反、エラーバジェット消費が進んでいる）可能性があります。',\n  'まずは、どの **SLI（測定指標）** の SLO なのか／対象期間としきい値は何か、を確認すると原因切り分けが進みます。'\n].join('\\n\\n');\n\nreturn [{\n  json: {\n    ...base,\n    content\n  }\n}];\n"
      },
      "id": "explain-slo-ja",
      "name": "Explain SLO Term (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3590,
        140
      ]
    },
    {
      "parameters": {
        "jsCode": "const base = $json ?? {};\nconst normalized = base.normalized_event ?? {};\nconst currentText = String(normalized.original_text ?? '').trim();\n\nif (!currentText) {\n  return [{ json: base }];\n}\n\nconst looksLikeDeploy = /デプロイ|手順/.test(currentText);\nconst mentions502 = currentText.includes('502');\n\nif (looksLikeDeploy && !mentions502) {\n  const content = typeof base.content === 'string' ? base.content : '';\n  const cleaned = content\n    .split('\\n')\n    .filter((line) => !line.includes('502'))\n    .join('\\n')\n    .trim();\n\n  let nextContent = cleaned || content;\n  if (!/デプロイ|手順/.test(nextContent)) {\n    nextContent = `前提: デプロイ手順についての質問です\\n\\n${nextContent}`;\n  }\n\n  return [{\n    json: {\n      ...base,\n      content: nextContent\n    }\n  }];\n}\n\nreturn [{ json: base }];\n"
      },
      "id": "prevent-topic-token-leak-ja",
      "name": "Prevent Topic Token Leak (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3640,
        140
      ]
    },
    {
      "parameters": {
        "jsCode": "const preview = $json ?? {};\n\nconst tryGetNodeJson = (name) => {\n  try {\n    const v = $node[name]?.json;\n    return (v && typeof v === 'object') ? v : null;\n  } catch (error) {\n    return null;\n  }\n};\n\nconst base =\n  tryGetNodeJson('Build IAM & Policy Context')\n  || tryGetNodeJson('Normalize Duplicate Flag')\n  || tryGetNodeJson('Context Store (Insert)')\n  || tryGetNodeJson('Guard Valid (Ingest)')\n  || {};\n\nlet chatCore = {};\ntry {\n  chatCore = $node['Parse Chat Core Response'].json ?? {};\n} catch (error) {\n  chatCore = {};\n}\n\nconst merged = {\n  ...base,\n  ...preview,\n  ...chatCore\n};\n\nmerged.job_plan = preview.job_plan ?? chatCore.job_plan ?? merged.job_plan ?? {};\nmerged.required_confirm = preview.required_confirm ?? chatCore.required_confirm ?? merged.required_confirm ?? null;\nmerged.next_action = preview.next_action ?? chatCore.next_action ?? merged.next_action ?? null;\n\nreturn [{ json: merged }];\n"
      },
      "id": "200",
      "name": "Merge Preview with Chat Core",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2060,
        340
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT COALESCE((\n  SELECT FLOOR(EXTRACT(EPOCH FROM (NOW() - created_at)) / 60)::int\n  FROM aiops_context\n  WHERE context_id = {{$json.context_id}}::uuid\n  LIMIT 1\n), 0) AS context_age_minutes;"
      },
      "id": "201",
      "name": "Load Escalation Context Age",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        2520,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const base = $node['Load Escalation Matrix (GitLab)'].json ?? {};\nconst row = $json ?? {};\nconst raw = row.context_age_minutes ?? null;\nconst parsed = Number.parseInt(String(raw ?? ''), 10);\nconst contextAge = Number.isFinite(parsed) ? parsed : (base.context_age_minutes ?? 0);\n\nreturn [{ json: { ...base, context_age_minutes: contextAge } }];\n"
      },
      "id": "202",
      "name": "Attach Escalation Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2720,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const source = $json.source || $json.reply_target?.source || '';\nif (source !== 'zulip') {\n  return [{ json: { ...$json, keycloak_member_ok: true, keycloak_check_skipped: true } }];\n}\n\nconst enforceRaw = $env.N8N_ZULIP_ENFORCE_KEYCLOAK_MEMBERSHIP;\nconst enforce = enforceRaw === undefined || enforceRaw === null || enforceRaw === ''\n  ? true\n  : /^(1|true|yes|y|on)$/i.test(String(enforceRaw));\n\nif (!enforce) {\n  return [{ json: { ...$json, keycloak_member_ok: true, keycloak_check_skipped: true } }];\n}\n\nconst email = ($json.actor?.email || '').trim();\nif (!email) {\n  return [{ json: { ...$json, keycloak_member_ok: false, keycloak_error: 'actor.email is missing' } }];\n}\n\nconst tenant = ($json.actor?.tenant || $json.actor?.realm || $json.reply_target?.tenant || $json.reply_target?.realm || '').trim();\n\nlet realmMap = null;\ntry {\n  if ($env.N8N_KEYCLOAK_REALM_MAP_JSON) {\n    const parsed = JSON.parse($env.N8N_KEYCLOAK_REALM_MAP_JSON);\n    if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) realmMap = parsed;\n  }\n} catch (error) {\n  realmMap = null;\n}\n\nlet targetRealm = tenant;\nif (realmMap) {\n  targetRealm = (tenant && realmMap[tenant]) ? String(realmMap[tenant]).trim()\n    : (realmMap.default ? String(realmMap.default).trim() : targetRealm);\n}\n\nconst baseUrl = String($env.N8N_KEYCLOAK_BASE_URL || '').replace(/\\/+$/, '');\nconst adminRealm = String($env.N8N_KEYCLOAK_ADMIN_REALM || 'master').trim();\nconst adminUsername = String($env.N8N_KEYCLOAK_ADMIN_USERNAME || '').trim();\nconst adminPassword = String($env.N8N_KEYCLOAK_ADMIN_PASSWORD || '').trim();\n\nif (!baseUrl || !targetRealm || !adminUsername || !adminPassword) {\n  return [{\n    json: {\n      ...$json,\n      keycloak_member_ok: false,\n      keycloak_error: 'keycloak config is missing',\n      keycloak_debug: {\n        baseUrl: !!baseUrl,\n        targetRealm,\n        hasUsername: !!adminUsername,\n        hasPassword: !!adminPassword,\n      }\n    }\n  }];\n}\n\nconst workflowContext = this;\n\nfunction loadCachedToken() {\n  try {\n    const staticData = workflowContext.getWorkflowStaticData('global');\n    const token = staticData.keycloak_admin_token;\n    const expiresAt = staticData.keycloak_admin_token_expires_at;\n    if (token && expiresAt && Date.now() < (Number(expiresAt) - 30_000)) {\n      return token;\n    }\n  } catch (error) {}\n  return null;\n}\n\nfunction saveCachedToken(token, expiresInSeconds) {\n  try {\n    const staticData = workflowContext.getWorkflowStaticData('global');\n    staticData.keycloak_admin_token = token;\n    staticData.keycloak_admin_token_expires_at = Date.now() + (Number(expiresInSeconds || 60) * 1000);\n  } catch (error) {}\n}\n\nasync function fetchAdminToken() {\n  const tokenUrl = `${baseUrl}/realms/${encodeURIComponent(adminRealm)}/protocol/openid-connect/token`;\n  const body = `grant_type=password&client_id=admin-cli&username=${encodeURIComponent(adminUsername)}&password=${encodeURIComponent(adminPassword)}`;\n\n  const resp = await workflowContext.helpers.httpRequest({\n    method: 'POST',\n    url: tokenUrl,\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body,\n    json: true,\n  });\n\n  const token = resp?.access_token;\n  const expiresIn = resp?.expires_in;\n  if (!token) throw new Error('keycloak token response missing access_token');\n  saveCachedToken(token, expiresIn || 60);\n  return token;\n}\n\nasync function searchUsers(token) {\n  const headers = { Authorization: `Bearer ${token}` };\n  const url1 = `${baseUrl}/admin/realms/${encodeURIComponent(targetRealm)}/users?email=${encodeURIComponent(email)}&exact=true&max=2`;\n  try {\n    const resp1 = await workflowContext.helpers.httpRequest({ method: 'GET', url: url1, headers, json: true });\n    if (Array.isArray(resp1)) return resp1;\n  } catch (error) {\n    // ignore and fallback\n  }\n\n  const url2 = `${baseUrl}/admin/realms/${encodeURIComponent(targetRealm)}/users?search=${encodeURIComponent(email)}&max=2`;\n  const resp2 = await workflowContext.helpers.httpRequest({ method: 'GET', url: url2, headers, json: true });\n  return Array.isArray(resp2) ? resp2 : [];\n}\n\nreturn await (async () => {\n  try {\n    const cached = loadCachedToken();\n    const token = cached || await fetchAdminToken();\n    const users = await searchUsers(token);\n    const ok = users.length > 0;\n    return [{\n      json: {\n        ...$json,\n        keycloak_member_ok: ok,\n        keycloak_user_count: users.length,\n        keycloak_checked_realm: targetRealm,\n      }\n    }];\n  } catch (error) {\n    return [{\n      json: {\n        ...$json,\n        keycloak_member_ok: false,\n        keycloak_error: String(error && error.message ? error.message : error),\n      }\n    }];\n  }\n})();\n"
      },
      "id": "9004",
      "name": "Verify Keycloak Membership (Zulip)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        200
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.keycloak_member_ok}}",
              "value2": true,
              "operation": "equal"
            }
          ]
        }
      },
      "id": "9005",
      "name": "IF Keycloak Membership OK",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1240,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const email = ($json.actor?.email || '').trim();\nconst realm = ($json.actor?.tenant || $json.actor?.realm || $json.reply_target?.tenant || $json.reply_target?.realm || '').trim();\n\nconst reason = $json.keycloak_error ? `（理由: ${$json.keycloak_error}）` : '';\nconst content = `申し訳ありません。この問い合わせには回答できません。\\n（Keycloak レルム ${realm || 'unknown'} にユーザー ${email || 'unknown'} が存在しないため）${reason}`;\n\nreturn [{\n  json: {\n    ...$json,\n    content,\n    keycloak_rejected: true,\n  }\n}];\n"
      },
      "id": "9006",
      "name": "Build Keycloak Reject Message (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1460,
        80
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javaScript",
        "jsCode": "const items = $input.all();\nreturn items.filter((item) => item.json?.valid === true);\n",
        "notice": ""
      },
      "id": "guard-valid-ingest",
      "name": "Guard Valid (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        880,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Webhook (Slack Ingest)',\n  target: 'Validate Slack',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9007",
      "name": "Debug Log After: Webhook (Slack Ingest) -> Validate Slack",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        380,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Webhook (Slack Ingest)',\n  target: 'Validate Slack',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9008",
      "name": "Debug Log Before: Validate Slack <- Webhook (Slack Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Validate Slack',\n  target: 'IF Slack Valid',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9009",
      "name": "Debug Log After: Validate Slack -> IF Slack Valid",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Validate Slack',\n  target: 'IF Slack Valid',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9010",
      "name": "Debug Log Before: IF Slack Valid <- Validate Slack",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        540,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Slack Valid',\n  target: 'Respond 200',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9011",
      "name": "Debug Log After: IF Slack Valid -> Respond 200",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        820,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Slack Valid',\n  target: 'Respond 200',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9012",
      "name": "Debug Log Before: Respond 200 <- IF Slack Valid",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        780,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Slack Valid',\n  target: 'Respond Error',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9013",
      "name": "Debug Log After: IF Slack Valid -> Respond Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        820,
        60
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Slack Valid',\n  target: 'Respond Error',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9014",
      "name": "Debug Log Before: Respond Error <- IF Slack Valid",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        780,
        40
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Webhook (Zulip Ingest)',\n  target: 'Debug Log (Zulip Payload)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9015",
      "name": "Debug Log After: Webhook (Zulip Ingest) -> Debug Log (Zulip Payload)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        380,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Webhook (Zulip Ingest)',\n  target: 'Debug Log (Zulip Payload)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9016",
      "name": "Debug Log Before: Debug Log (Zulip Payload) <- Webhook (Zulip Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Debug Log (Zulip Payload)',\n  target: 'Validate Zulip',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9017",
      "name": "Debug Log After: Debug Log (Zulip Payload) -> Validate Zulip",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Debug Log (Zulip Payload)',\n  target: 'Validate Zulip',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9018",
      "name": "Debug Log Before: Validate Zulip <- Debug Log (Zulip Payload)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Debug Log (Zulip Payload)',\n  target: 'IF Sulu Monitoring Enabled',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9019",
      "name": "Debug Log After: Debug Log (Zulip Payload) -> IF Sulu Monitoring Enabled",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        340
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Debug Log (Zulip Payload)',\n  target: 'IF Sulu Monitoring Enabled',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9020",
      "name": "Debug Log Before: IF Sulu Monitoring Enabled <- Debug Log (Zulip Payload)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        540,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Sulu Monitoring Enabled',\n  target: 'Build Sulu Monitoring Payload (Zulip)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9021",
      "name": "Debug Log After: IF Sulu Monitoring Enabled -> Build Sulu Monitoring Payload (Zulip)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        820,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Sulu Monitoring Enabled',\n  target: 'Build Sulu Monitoring Payload (Zulip)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9022",
      "name": "Debug Log Before: Build Sulu Monitoring Payload (Zulip) <- IF Sulu Monitoring Enabled",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        760,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Sulu Monitoring Payload (Zulip)',\n  target: 'Post to Sulu Monitoring',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9023",
      "name": "Debug Log After: Build Sulu Monitoring Payload (Zulip) -> Post to Sulu Monitoring",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Sulu Monitoring Payload (Zulip)',\n  target: 'Post to Sulu Monitoring',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9024",
      "name": "Debug Log Before: Post to Sulu Monitoring <- Build Sulu Monitoring Payload (Zulip)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        980,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Validate Zulip',\n  target: 'IF Zulip Valid',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9025",
      "name": "Debug Log After: Validate Zulip -> IF Zulip Valid",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Validate Zulip',\n  target: 'IF Zulip Valid',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9026",
      "name": "Debug Log Before: IF Zulip Valid <- Validate Zulip",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        540,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Zulip Valid',\n  target: 'Respond 200',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9027",
      "name": "Debug Log After: IF Zulip Valid -> Respond 200",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        820,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Zulip Valid',\n  target: 'Respond 200',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9028",
      "name": "Debug Log Before: Respond 200 <- IF Zulip Valid",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        780,
        260
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Zulip Valid',\n  target: 'Respond Error',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9029",
      "name": "Debug Log After: IF Zulip Valid -> Respond Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        820,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Zulip Valid',\n  target: 'Respond Error',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9030",
      "name": "Debug Log Before: Respond Error <- IF Zulip Valid",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        780,
        100
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Webhook (Mattermost Ingest)',\n  target: 'Validate Mattermost',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9031",
      "name": "Debug Log After: Webhook (Mattermost Ingest) -> Validate Mattermost",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        380,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Webhook (Mattermost Ingest)',\n  target: 'Validate Mattermost',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9032",
      "name": "Debug Log Before: Validate Mattermost <- Webhook (Mattermost Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Validate Mattermost',\n  target: 'IF Mattermost Valid',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9033",
      "name": "Debug Log After: Validate Mattermost -> IF Mattermost Valid",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Validate Mattermost',\n  target: 'IF Mattermost Valid',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9034",
      "name": "Debug Log Before: IF Mattermost Valid <- Validate Mattermost",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        540,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Mattermost Valid',\n  target: 'Respond 200',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9035",
      "name": "Debug Log After: IF Mattermost Valid -> Respond 200",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        820,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Mattermost Valid',\n  target: 'Respond 200',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9036",
      "name": "Debug Log Before: Respond 200 <- IF Mattermost Valid",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        780,
        320
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Mattermost Valid',\n  target: 'Respond Error',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9037",
      "name": "Debug Log After: IF Mattermost Valid -> Respond Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        820,
        500
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Mattermost Valid',\n  target: 'Respond Error',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9038",
      "name": "Debug Log Before: Respond Error <- IF Mattermost Valid",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        780,
        160
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Webhook (Teams Ingest)',\n  target: 'Validate Teams',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9039",
      "name": "Debug Log After: Webhook (Teams Ingest) -> Validate Teams",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        380,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Webhook (Teams Ingest)',\n  target: 'Validate Teams',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9040",
      "name": "Debug Log Before: Validate Teams <- Webhook (Teams Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Validate Teams',\n  target: 'IF Teams Valid',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9041",
      "name": "Debug Log After: Validate Teams -> IF Teams Valid",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Validate Teams',\n  target: 'IF Teams Valid',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9042",
      "name": "Debug Log Before: IF Teams Valid <- Validate Teams",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        540,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Teams Valid',\n  target: 'Respond 200',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9043",
      "name": "Debug Log After: IF Teams Valid -> Respond 200",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        820,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Teams Valid',\n  target: 'Respond 200',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9044",
      "name": "Debug Log Before: Respond 200 <- IF Teams Valid",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        780,
        380
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Teams Valid',\n  target: 'Respond Error',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9045",
      "name": "Debug Log After: IF Teams Valid -> Respond Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        820,
        720
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Teams Valid',\n  target: 'Respond Error',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9046",
      "name": "Debug Log Before: Respond Error <- IF Teams Valid",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        780,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Webhook (CloudWatch Ingest)',\n  target: 'Validate CloudWatch',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9047",
      "name": "Debug Log After: Webhook (CloudWatch Ingest) -> Validate CloudWatch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        380,
        880
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Webhook (CloudWatch Ingest)',\n  target: 'Validate CloudWatch',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9048",
      "name": "Debug Log Before: Validate CloudWatch <- Webhook (CloudWatch Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        880
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Validate CloudWatch',\n  target: 'IF CloudWatch Valid',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9049",
      "name": "Debug Log After: Validate CloudWatch -> IF CloudWatch Valid",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        880
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Validate CloudWatch',\n  target: 'IF CloudWatch Valid',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9050",
      "name": "Debug Log Before: IF CloudWatch Valid <- Validate CloudWatch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        540,
        880
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF CloudWatch Valid',\n  target: 'Respond 200',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9051",
      "name": "Debug Log After: IF CloudWatch Valid -> Respond 200",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        820,
        880
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF CloudWatch Valid',\n  target: 'Respond 200',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9052",
      "name": "Debug Log Before: Respond 200 <- IF CloudWatch Valid",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        780,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF CloudWatch Valid',\n  target: 'Respond Error',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9053",
      "name": "Debug Log After: IF CloudWatch Valid -> Respond Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        820,
        940
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF CloudWatch Valid',\n  target: 'Respond Error',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9054",
      "name": "Debug Log Before: Respond Error <- IF CloudWatch Valid",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        780,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Respond 200',\n  target: 'Guard Valid (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9055",
      "name": "Debug Log After: Respond 200 -> Guard Valid (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1060,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Respond 200',\n  target: 'Guard Valid (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9056",
      "name": "Debug Log Before: Guard Valid (Ingest) <- Respond 200",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        740,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Context Store (Insert)',\n  target: 'Normalize Duplicate Flag',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9057",
      "name": "Debug Log After: Context Store (Insert) -> Normalize Duplicate Flag",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1300,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Context Store (Insert)',\n  target: 'Normalize Duplicate Flag',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9058",
      "name": "Debug Log Before: Normalize Duplicate Flag <- Context Store (Insert)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1260,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Normalize Duplicate Flag',\n  target: 'Build IAM & Policy Context',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9059",
      "name": "Debug Log After: Normalize Duplicate Flag -> Build IAM & Policy Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1540,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Normalize Duplicate Flag',\n  target: 'Build IAM & Policy Context',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9060",
      "name": "Debug Log Before: Build IAM & Policy Context <- Normalize Duplicate Flag",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1380,
        320
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build IAM & Policy Context',\n  target: 'IF Duplicate',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9061",
      "name": "Debug Log After: Build IAM & Policy Context -> IF Duplicate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1660,
        320
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build IAM & Policy Context',\n  target: 'IF Duplicate',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9062",
      "name": "Debug Log Before: IF Duplicate <- Build IAM & Policy Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1500,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Duplicate',\n  target: 'Build Chat Core Prompt (JP)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9063",
      "name": "Debug Log After: IF Duplicate -> Build Chat Core Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1780,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Duplicate',\n  target: 'Build Chat Core Prompt (JP)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9064",
      "name": "Debug Log Before: Build Chat Core Prompt (JP) <- IF Duplicate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2280,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Call Orchestrator Preview',\n  target: 'Merge Preview with Chat Core',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9065",
      "name": "Debug Log After: Call Orchestrator Preview -> Merge Preview with Chat Core",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2020,
        340
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Call Orchestrator Preview',\n  target: 'Merge Preview with Chat Core',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9066",
      "name": "Debug Log Before: Merge Preview with Chat Core <- Call Orchestrator Preview",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1920,
        340
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Required Confirm',\n  target: 'Enqueue Job',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9067",
      "name": "Debug Log After: IF Required Confirm -> Enqueue Job",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2260,
        340
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Required Confirm',\n  target: 'Enqueue Job',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9068",
      "name": "Debug Log Before: Enqueue Job <- IF Required Confirm",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2220,
        460
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Required Confirm',\n  target: 'Build Approval Message',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9069",
      "name": "Debug Log After: IF Required Confirm -> Build Approval Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2260,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Required Confirm',\n  target: 'Build Approval Message',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9070",
      "name": "Debug Log Before: Build Approval Message <- IF Required Confirm",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Enqueue Job',\n  target: 'Context Store (job_id)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9071",
      "name": "Debug Log After: Enqueue Job -> Context Store (job_id)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2500,
        460
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Enqueue Job',\n  target: 'Context Store (job_id)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9072",
      "name": "Debug Log Before: Context Store (job_id) <- Enqueue Job",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2460,
        460
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Classify Event (Basic)',\n  target: 'Update Normalized Event',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9073",
      "name": "Debug Log After: Classify Event (Basic) -> Update Normalized Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2020,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Classify Event (Basic)',\n  target: 'Update Normalized Event',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9074",
      "name": "Debug Log Before: Update Normalized Event <- Classify Event (Basic)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1960,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Update Normalized Event',\n  target: 'Load Escalation Matrix (GitLab)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9075",
      "name": "Debug Log After: Update Normalized Event -> Load Escalation Matrix (GitLab)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2240,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Update Normalized Event',\n  target: 'Load Escalation Matrix (GitLab)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9076",
      "name": "Debug Log Before: Load Escalation Matrix (GitLab) <- Update Normalized Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2180,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Context Store (job_id)',\n  target: 'Build Auto-Enqueue Message',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9077",
      "name": "Debug Log After: Context Store (job_id) -> Build Auto-Enqueue Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2740,
        460
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Context Store (job_id)',\n  target: 'Build Auto-Enqueue Message',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9078",
      "name": "Debug Log Before: Build Auto-Enqueue Message <- Context Store (job_id)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2700,
        460
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Approval Message',\n  target: 'Use Chat Core Reply',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9079",
      "name": "Debug Log After: Build Approval Message -> Use Chat Core Reply",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2480,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Approval Message',\n  target: 'Use Chat Core Reply',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9080",
      "name": "Debug Log Before: Use Chat Core Reply <- Build Approval Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3100,
        140
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Auto-Enqueue Message',\n  target: 'Use Chat Core Reply',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9081",
      "name": "Debug Log After: Build Auto-Enqueue Message -> Use Chat Core Reply",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2980,
        460
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Auto-Enqueue Message',\n  target: 'Use Chat Core Reply',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9082",
      "name": "Debug Log Before: Use Chat Core Reply <- Build Auto-Enqueue Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3100,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Zulip Source (Ingest)',\n  target: 'Post to Zulip (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems",
        "url": "={{ (() => {\n  const tenant = $json.reply_target?.tenant ?? $json.reply_target?.realm ?? '';\n  const jsonRaw = $env.N8N_ZULIP_API_BASE_URL || '';\n  const yamlRaw = $env.N8N_ZULIP_API_BASE_URL || '';\n  const fallback = $env.N8N_ZULIP_API_BASE_URL || $env.ZULIP_API_BASE_URL || '';\n  const parseYaml = (text) => {\n    const map = {};\n    String(text).split(/\\r?\\n/).forEach((line) => {\n      const trimmed = line.trim();\n      if (!trimmed || trimmed.startsWith('#')) return;\n      const idx = trimmed.indexOf(':');\n      if (idx <= 0) return;\n      const key = trimmed.slice(0, idx).trim();\n      let value = trimmed.slice(idx + 1).trim();\n      if (!key) return;\n      value = value.replace(/^['\"]|['\"]$/g, '');\n      map[key] = value;\n    });\n    return map;\n  };\n  let map = {};\n  if (jsonRaw) {\n    try {\n      const parsed = JSON.parse(jsonRaw);\n      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n        map = parsed;\n      }\n    } catch (error) {}\n  }\n  if (!Object.keys(map).length && yamlRaw) {\n    map = parseYaml(yamlRaw);\n  }\n  const base = (tenant && map[tenant]) ? map[tenant] : (map.default || fallback);\n  const trimmed = base ? String(base).replace(/\\/+$/, '') : '';\n  if (!trimmed) return '';\n  const apiBase = trimmed.endsWith('/api/v1') ? trimmed : (trimmed + '/api/v1');\n  return apiBase + '/messages';\n})() }}",
        "sendHeaders": true,
        "specifyHeaders": "keypair",
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "={{ (() => {\n  const tenant = $json.reply_target?.tenant ?? $json.reply_target?.realm ?? '';\n  const tokenJsonRaw = $env.N8N_ZULIP_BOT_TOKEN || '';\n  const tokenYamlRaw = $env.ZULIP_BOT_TOKEN || $env.N8N_ZULIP_BOT_TOKEN || '';\n  const emailJsonRaw = $env.N8N_ZULIP_BOT_EMAIL || '';\n  const emailYamlRaw = $env.N8N_ZULIP_BOT_EMAIL || '';\n  const fallbackToken = $env.N8N_ZULIP_BOT_TOKEN || $env.ZULIP_BOT_TOKEN || '';\n  const fallbackEmail = $env.N8N_ZULIP_BOT_EMAIL || $env.ZULIP_BOT_EMAIL || '';\n  const parseYaml = (text) => {\n    const map = {};\n    String(text).split(/\\r?\\n/).forEach((line) => {\n      const trimmed = line.trim();\n      if (!trimmed || trimmed.startsWith('#')) return;\n      const idx = trimmed.indexOf(':');\n      if (idx <= 0) return;\n      const key = trimmed.slice(0, idx).trim();\n      let value = trimmed.slice(idx + 1).trim();\n      if (!key) return;\n      value = value.replace(/^['\"]|['\"]$/g, '');\n      map[key] = value;\n    });\n    return map;\n  };\n  const parseMap = (jsonRaw, yamlRaw) => {\n    let map = {};\n    if (jsonRaw) {\n      try {\n        const parsed = JSON.parse(jsonRaw);\n        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n          map = parsed;\n        }\n      } catch (error) {}\n    }\n    if (!Object.keys(map).length && yamlRaw) {\n      map = parseYaml(yamlRaw);\n    }\n    return map;\n  };\n  const tokenMap = parseMap(tokenJsonRaw, tokenYamlRaw);\n  const emailMap = parseMap(emailJsonRaw, emailYamlRaw);\n  const token = (tenant && tokenMap[tenant]) ? tokenMap[tenant] : (tokenMap.default || fallbackToken);\n  const email = (tenant && emailMap[tenant]) ? emailMap[tenant] : (emailMap.default || fallbackEmail);\n  if (!email || !token) return '';\n  return 'Basic ' + Buffer.from(email + ':' + token).toString('base64');\n})() }}"
            }
          ]
        }
      },
      "id": "9083",
      "name": "Debug Log After: IF Zulip Source (Ingest) -> Post to Zulip (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2660,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Zulip Source (Ingest)',\n  target: 'Post to Zulip (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems",
        "url": "={{ (() => {\n  const tenant = $json.reply_target?.tenant ?? $json.reply_target?.realm ?? '';\n  const jsonRaw = $env.N8N_ZULIP_API_BASE_URL || '';\n  const yamlRaw = $env.N8N_ZULIP_API_BASE_URL || '';\n  const fallback = $env.N8N_ZULIP_API_BASE_URL || $env.ZULIP_API_BASE_URL || '';\n  const parseYaml = (text) => {\n    const map = {};\n    String(text).split(/\\r?\\n/).forEach((line) => {\n      const trimmed = line.trim();\n      if (!trimmed || trimmed.startsWith('#')) return;\n      const idx = trimmed.indexOf(':');\n      if (idx <= 0) return;\n      const key = trimmed.slice(0, idx).trim();\n      let value = trimmed.slice(idx + 1).trim();\n      if (!key) return;\n      value = value.replace(/^['\"]|['\"]$/g, '');\n      map[key] = value;\n    });\n    return map;\n  };\n  let map = {};\n  if (jsonRaw) {\n    try {\n      const parsed = JSON.parse(jsonRaw);\n      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n        map = parsed;\n      }\n    } catch (error) {}\n  }\n  if (!Object.keys(map).length && yamlRaw) {\n    map = parseYaml(yamlRaw);\n  }\n  const base = (tenant && map[tenant]) ? map[tenant] : (map.default || fallback);\n  const trimmed = base ? String(base).replace(/\\/+$/, '') : '';\n  if (!trimmed) return '';\n  const apiBase = trimmed.endsWith('/api/v1') ? trimmed : (trimmed + '/api/v1');\n  return apiBase + '/messages';\n})() }}",
        "sendHeaders": true,
        "specifyHeaders": "keypair",
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "={{ (() => {\n  const tenant = $json.reply_target?.tenant ?? $json.reply_target?.realm ?? '';\n  const tokenJsonRaw = $env.N8N_ZULIP_BOT_TOKEN || '';\n  const tokenYamlRaw = $env.ZULIP_BOT_TOKEN || $env.N8N_ZULIP_BOT_TOKEN || '';\n  const emailJsonRaw = $env.N8N_ZULIP_BOT_EMAIL || '';\n  const emailYamlRaw = $env.N8N_ZULIP_BOT_EMAIL || '';\n  const fallbackToken = $env.N8N_ZULIP_BOT_TOKEN || $env.ZULIP_BOT_TOKEN || '';\n  const fallbackEmail = $env.N8N_ZULIP_BOT_EMAIL || $env.ZULIP_BOT_EMAIL || '';\n  const parseYaml = (text) => {\n    const map = {};\n    String(text).split(/\\r?\\n/).forEach((line) => {\n      const trimmed = line.trim();\n      if (!trimmed || trimmed.startsWith('#')) return;\n      const idx = trimmed.indexOf(':');\n      if (idx <= 0) return;\n      const key = trimmed.slice(0, idx).trim();\n      let value = trimmed.slice(idx + 1).trim();\n      if (!key) return;\n      value = value.replace(/^['\"]|['\"]$/g, '');\n      map[key] = value;\n    });\n    return map;\n  };\n  const parseMap = (jsonRaw, yamlRaw) => {\n    let map = {};\n    if (jsonRaw) {\n      try {\n        const parsed = JSON.parse(jsonRaw);\n        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n          map = parsed;\n        }\n      } catch (error) {}\n    }\n    if (!Object.keys(map).length && yamlRaw) {\n      map = parseYaml(yamlRaw);\n    }\n    return map;\n  };\n  const tokenMap = parseMap(tokenJsonRaw, tokenYamlRaw);\n  const emailMap = parseMap(emailJsonRaw, emailYamlRaw);\n  const token = (tenant && tokenMap[tenant]) ? tokenMap[tenant] : (tokenMap.default || fallbackToken);\n  const email = (tenant && emailMap[tenant]) ? emailMap[tenant] : (emailMap.default || fallbackEmail);\n  if (!email || !token) return '';\n  return 'Basic ' + Buffer.from(email + ':' + token).toString('base64');\n})() }}"
            }
          ]
        }
      },
      "id": "9084",
      "name": "Debug Log Before: Post to Zulip (Ingest) <- IF Zulip Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2600,
        120
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Zulip Source (Ingest)',\n  target: 'IF Slack Source (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9085",
      "name": "Debug Log After: IF Zulip Source (Ingest) -> IF Slack Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2660,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Zulip Source (Ingest)',\n  target: 'IF Slack Source (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9086",
      "name": "Debug Log Before: IF Slack Source (Ingest) <- IF Zulip Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2600,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Slack Source (Ingest)',\n  target: 'Post to Slack (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9087",
      "name": "Debug Log After: IF Slack Source (Ingest) -> Post to Slack (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2880,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Slack Source (Ingest)',\n  target: 'Post to Slack (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9088",
      "name": "Debug Log Before: Post to Slack (Ingest) <- IF Slack Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2820,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Slack Source (Ingest)',\n  target: 'IF Mattermost Source (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9089",
      "name": "Debug Log After: IF Slack Source (Ingest) -> IF Mattermost Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2880,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Slack Source (Ingest)',\n  target: 'IF Mattermost Source (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9090",
      "name": "Debug Log Before: IF Mattermost Source (Ingest) <- IF Slack Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2820,
        360
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Mattermost Source (Ingest)',\n  target: 'Post to Mattermost (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9091",
      "name": "Debug Log After: IF Mattermost Source (Ingest) -> Post to Mattermost (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3100,
        360
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Mattermost Source (Ingest)',\n  target: 'Post to Mattermost (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9092",
      "name": "Debug Log Before: Post to Mattermost (Ingest) <- IF Mattermost Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3020,
        360
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Mattermost Source (Ingest)',\n  target: 'IF Teams Source (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9093",
      "name": "Debug Log After: IF Mattermost Source (Ingest) -> IF Teams Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3100,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Mattermost Source (Ingest)',\n  target: 'IF Teams Source (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9094",
      "name": "Debug Log Before: IF Teams Source (Ingest) <- IF Mattermost Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3020,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Teams Source (Ingest)',\n  target: 'Post to Teams (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9095",
      "name": "Debug Log After: IF Teams Source (Ingest) -> Post to Teams (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3300,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Teams Source (Ingest)',\n  target: 'Post to Teams (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9096",
      "name": "Debug Log Before: Post to Teams (Ingest) <- IF Teams Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3220,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Teams Source (Ingest)',\n  target: 'Log Unknown Source (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9097",
      "name": "Debug Log After: IF Teams Source (Ingest) -> Log Unknown Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3300,
        540
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Teams Source (Ingest)',\n  target: 'Log Unknown Source (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9098",
      "name": "Debug Log Before: Log Unknown Source (Ingest) <- IF Teams Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3220,
        600
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Record Prompt History (Classify)',\n  target: 'OpenAI Classify Event',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9099",
      "name": "Debug Log After: Record Prompt History (Classify) -> OpenAI Classify Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1260,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Record Prompt History (Classify)',\n  target: 'OpenAI Classify Event',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9100",
      "name": "Debug Log Before: OpenAI Classify Event <- Record Prompt History (Classify)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'OpenAI Classify Event',\n  target: 'Parse Classification Response',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9101",
      "name": "Debug Log After: OpenAI Classify Event -> Parse Classification Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1480,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'OpenAI Classify Event',\n  target: 'Parse Classification Response',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9102",
      "name": "Debug Log Before: Parse Classification Response <- OpenAI Classify Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1420,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Parse Classification Response',\n  target: 'IF LLM Classified',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9103",
      "name": "Debug Log After: Parse Classification Response -> IF LLM Classified",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1700,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Parse Classification Response',\n  target: 'IF LLM Classified',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9104",
      "name": "Debug Log Before: IF LLM Classified <- Parse Classification Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1640,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF LLM Classified',\n  target: 'Update Normalized Event',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9105",
      "name": "Debug Log After: IF LLM Classified -> Update Normalized Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1920,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF LLM Classified',\n  target: 'Update Normalized Event',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9106",
      "name": "Debug Log Before: Update Normalized Event <- IF LLM Classified",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1960,
        260
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF LLM Classified',\n  target: 'Classify Event (Basic)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9107",
      "name": "Debug Log After: IF LLM Classified -> Classify Event (Basic)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1920,
        720
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF LLM Classified',\n  target: 'Classify Event (Basic)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9108",
      "name": "Debug Log Before: Classify Event (Basic) <- IF LLM Classified",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1740,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Prompt Override (Classify)',\n  target: 'Load Prompt History (Classify)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9109",
      "name": "Debug Log After: IF Prompt Override (Classify) -> Load Prompt History (Classify)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Prompt Override (Classify)',\n  target: 'Load Prompt History (Classify)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9110",
      "name": "Debug Log Before: Load Prompt History (Classify) <- IF Prompt Override (Classify)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        980,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Prompt Override (Classify)',\n  target: 'Record Prompt History (Classify)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9111",
      "name": "Debug Log After: IF Prompt Override (Classify) -> Record Prompt History (Classify)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        620
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Prompt Override (Classify)',\n  target: 'Record Prompt History (Classify)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9112",
      "name": "Debug Log Before: Record Prompt History (Classify) <- IF Prompt Override (Classify)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        980,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Load Prompt History (Classify)',\n  target: 'Apply Stored Prompt (Classify)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9113",
      "name": "Debug Log After: Load Prompt History (Classify) -> Apply Stored Prompt (Classify)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1260,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Load Prompt History (Classify)',\n  target: 'Apply Stored Prompt (Classify)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9114",
      "name": "Debug Log Before: Apply Stored Prompt (Classify) <- Load Prompt History (Classify)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Apply Stored Prompt (Classify)',\n  target: 'OpenAI Classify Event',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9115",
      "name": "Debug Log After: Apply Stored Prompt (Classify) -> OpenAI Classify Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1480,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Apply Stored Prompt (Classify)',\n  target: 'OpenAI Classify Event',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9116",
      "name": "Debug Log Before: OpenAI Classify Event <- Apply Stored Prompt (Classify)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        720
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Summary Prompt (JP)',\n  target: 'Record Prompt History (Summary)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9117",
      "name": "Debug Log After: Build Summary Prompt (JP) -> Record Prompt History (Summary)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1080,
        820
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Summary Prompt (JP)',\n  target: 'Record Prompt History (Summary)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9118",
      "name": "Debug Log Before: Record Prompt History (Summary) <- Build Summary Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1020,
        820
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Record Prompt History (Summary)',\n  target: 'OpenAI Context Summary',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9119",
      "name": "Debug Log After: Record Prompt History (Summary) -> OpenAI Context Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1300,
        820
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Record Prompt History (Summary)',\n  target: 'OpenAI Context Summary',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9120",
      "name": "Debug Log Before: OpenAI Context Summary <- Record Prompt History (Summary)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1240,
        820
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'OpenAI Context Summary',\n  target: 'Parse Summary Response',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9121",
      "name": "Debug Log After: OpenAI Context Summary -> Parse Summary Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1520,
        820
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'OpenAI Context Summary',\n  target: 'Parse Summary Response',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9122",
      "name": "Debug Log Before: Parse Summary Response <- OpenAI Context Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1460,
        820
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Parse Summary Response',\n  target: 'IF Summary OK',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9123",
      "name": "Debug Log After: Parse Summary Response -> IF Summary OK",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1740,
        820
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Parse Summary Response',\n  target: 'IF Summary OK',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9124",
      "name": "Debug Log Before: IF Summary OK <- Parse Summary Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1680,
        820
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Summary OK',\n  target: 'Update Enrichment Summary',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9125",
      "name": "Debug Log After: IF Summary OK -> Update Enrichment Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1960,
        820
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Summary OK',\n  target: 'Update Enrichment Summary',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9126",
      "name": "Debug Log Before: Update Enrichment Summary <- IF Summary OK",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1900,
        800
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Summary OK',\n  target: 'Call Orchestrator Preview',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9127",
      "name": "Debug Log After: IF Summary OK -> Call Orchestrator Preview",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1960,
        880
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Summary OK',\n  target: 'Call Orchestrator Preview',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9128",
      "name": "Debug Log Before: Call Orchestrator Preview <- IF Summary OK",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1740,
        340
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Update Enrichment Summary',\n  target: 'Call Orchestrator Preview',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9129",
      "name": "Debug Log After: Update Enrichment Summary -> Call Orchestrator Preview",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2180,
        800
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Update Enrichment Summary',\n  target: 'Call Orchestrator Preview',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9130",
      "name": "Debug Log Before: Call Orchestrator Preview <- Update Enrichment Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1740,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Intent Approval',\n  target: 'Parse Approval Token (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9131",
      "name": "Debug Log After: IF Intent Approval -> Parse Approval Token (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2120,
        320
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Intent Approval',\n  target: 'Parse Approval Token (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9132",
      "name": "Debug Log Before: Parse Approval Token (Ingest) <- IF Intent Approval",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2060,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Intent Approval',\n  target: 'IF Intent Feedback',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9133",
      "name": "Debug Log After: IF Intent Approval -> IF Intent Feedback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2120,
        380
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Intent Approval',\n  target: 'IF Intent Feedback',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9134",
      "name": "Debug Log Before: IF Intent Feedback <- IF Intent Approval",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2060,
        360
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Parse Approval Token (Ingest)',\n  target: 'IF Approval Token Valid (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9135",
      "name": "Debug Log After: Parse Approval Token (Ingest) -> IF Approval Token Valid (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2340,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Parse Approval Token (Ingest)',\n  target: 'IF Approval Token Valid (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9136",
      "name": "Debug Log Before: IF Approval Token Valid (Ingest) <- Parse Approval Token (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2280,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Approval Token Valid (Ingest)',\n  target: 'Load Pending Approval (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9137",
      "name": "Debug Log After: IF Approval Token Valid (Ingest) -> Load Pending Approval (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2560,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Approval Token Valid (Ingest)',\n  target: 'Load Pending Approval (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9138",
      "name": "Debug Log Before: Load Pending Approval (Ingest) <- IF Approval Token Valid (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2500,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Approval Token Valid (Ingest)',\n  target: 'Build Approval Error Message (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9139",
      "name": "Debug Log After: IF Approval Token Valid (Ingest) -> Build Approval Error Message (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2560,
        260
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Approval Token Valid (Ingest)',\n  target: 'Build Approval Error Message (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9140",
      "name": "Debug Log Before: Build Approval Error Message (Ingest) <- IF Approval Token Valid (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2500,
        80
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Load Pending Approval (Ingest)',\n  target: 'Validate Pending Approval (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9141",
      "name": "Debug Log After: Load Pending Approval (Ingest) -> Validate Pending Approval (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2780,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Load Pending Approval (Ingest)',\n  target: 'Validate Pending Approval (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9142",
      "name": "Debug Log Before: Validate Pending Approval (Ingest) <- Load Pending Approval (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2720,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Validate Pending Approval (Ingest)',\n  target: 'IF Pending Approval Valid (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9143",
      "name": "Debug Log After: Validate Pending Approval (Ingest) -> IF Pending Approval Valid (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3000,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Validate Pending Approval (Ingest)',\n  target: 'IF Pending Approval Valid (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9144",
      "name": "Debug Log Before: IF Pending Approval Valid (Ingest) <- Validate Pending Approval (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2940,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Pending Approval Valid (Ingest)',\n  target: 'IF Decision Deny (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9145",
      "name": "Debug Log After: IF Pending Approval Valid (Ingest) -> IF Decision Deny (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3220,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Pending Approval Valid (Ingest)',\n  target: 'IF Decision Deny (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9146",
      "name": "Debug Log Before: IF Decision Deny (Ingest) <- IF Pending Approval Valid (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3160,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Pending Approval Valid (Ingest)',\n  target: 'Build Approval Error Message (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9147",
      "name": "Debug Log After: IF Pending Approval Valid (Ingest) -> Build Approval Error Message (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3220,
        260
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Pending Approval Valid (Ingest)',\n  target: 'Build Approval Error Message (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9148",
      "name": "Debug Log Before: Build Approval Error Message (Ingest) <- IF Pending Approval Valid (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2500,
        140
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Decision Deny (Ingest)',\n  target: 'Mark Approval Denied (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9149",
      "name": "Debug Log After: IF Decision Deny (Ingest) -> Mark Approval Denied (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3440,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Decision Deny (Ingest)',\n  target: 'Mark Approval Denied (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9150",
      "name": "Debug Log Before: Mark Approval Denied (Ingest) <- IF Decision Deny (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3380,
        120
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Decision Deny (Ingest)',\n  target: 'Enqueue Job (Approval Confirm Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9151",
      "name": "Debug Log After: IF Decision Deny (Ingest) -> Enqueue Job (Approval Confirm Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3440,
        260
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Decision Deny (Ingest)',\n  target: 'Enqueue Job (Approval Confirm Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9152",
      "name": "Debug Log Before: Enqueue Job (Approval Confirm Ingest) <- IF Decision Deny (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3380,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Mark Approval Denied (Ingest)',\n  target: 'Record Approval Denied (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9153",
      "name": "Debug Log After: Mark Approval Denied (Ingest) -> Record Approval Denied (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3660,
        120
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Mark Approval Denied (Ingest)',\n  target: 'Record Approval Denied (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9154",
      "name": "Debug Log Before: Record Approval Denied (Ingest) <- Mark Approval Denied (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3600,
        120
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Record Approval Denied (Ingest)',\n  target: 'Load Context (Approval Ack Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9155",
      "name": "Debug Log After: Record Approval Denied (Ingest) -> Load Context (Approval Ack Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3880,
        120
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Record Approval Denied (Ingest)',\n  target: 'Load Context (Approval Ack Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9156",
      "name": "Debug Log Before: Load Context (Approval Ack Ingest) <- Record Approval Denied (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4040,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Enqueue Job (Approval Confirm Ingest)',\n  target: 'Context Store (job_id) (Approval Confirm Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9157",
      "name": "Debug Log After: Enqueue Job (Approval Confirm Ingest) -> Context Store (job_id) (Approval Confirm Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3660,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Enqueue Job (Approval Confirm Ingest)',\n  target: 'Context Store (job_id) (Approval Confirm Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9158",
      "name": "Debug Log Before: Context Store (job_id) (Approval Confirm Ingest) <- Enqueue Job (Approval Confirm Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3600,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Context Store (job_id) (Approval Confirm Ingest)',\n  target: 'Record Approval Approved (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9159",
      "name": "Debug Log After: Context Store (job_id) (Approval Confirm Ingest) -> Record Approval Approved (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3880,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Context Store (job_id) (Approval Confirm Ingest)',\n  target: 'Record Approval Approved (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9160",
      "name": "Debug Log Before: Record Approval Approved (Ingest) <- Context Store (job_id) (Approval Confirm Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3820,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Record Approval Approved (Ingest)',\n  target: 'Load Context (Approval Ack Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9161",
      "name": "Debug Log After: Record Approval Approved (Ingest) -> Load Context (Approval Ack Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4100,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Record Approval Approved (Ingest)',\n  target: 'Load Context (Approval Ack Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9162",
      "name": "Debug Log Before: Load Context (Approval Ack Ingest) <- Record Approval Approved (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4040,
        260
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Load Context (Approval Ack Ingest)',\n  target: 'Build Approval Ack (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9163",
      "name": "Debug Log After: Load Context (Approval Ack Ingest) -> Build Approval Ack (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4320,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Load Context (Approval Ack Ingest)',\n  target: 'Build Approval Ack (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9164",
      "name": "Debug Log Before: Build Approval Ack (Ingest) <- Load Context (Approval Ack Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4260,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Approval Ack (Ingest)',\n  target: 'IF Zulip Source (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9165",
      "name": "Debug Log After: Build Approval Ack (Ingest) -> IF Zulip Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4540,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Approval Ack (Ingest)',\n  target: 'IF Zulip Source (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9166",
      "name": "Debug Log Before: IF Zulip Source (Ingest) <- Build Approval Ack (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2380,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Approval Error Message (Ingest)',\n  target: 'IF Zulip Source (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9167",
      "name": "Debug Log After: Build Approval Error Message (Ingest) -> IF Zulip Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2780,
        80
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Approval Error Message (Ingest)',\n  target: 'IF Zulip Source (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9168",
      "name": "Debug Log Before: IF Zulip Source (Ingest) <- Build Approval Error Message (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2380,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Intent Feedback',\n  target: 'IF Feedback Type Preview (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9169",
      "name": "Debug Log After: IF Intent Feedback -> IF Feedback Type Preview (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2340,
        360
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Intent Feedback',\n  target: 'IF Feedback Type Preview (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9170",
      "name": "Debug Log Before: IF Feedback Type Preview (Ingest) <- IF Intent Feedback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2280,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Intent Feedback',\n  target: 'IF Event Kind Other',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9171",
      "name": "Debug Log After: IF Intent Feedback -> IF Event Kind Other",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2340,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Intent Feedback',\n  target: 'IF Event Kind Other',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9172",
      "name": "Debug Log Before: IF Event Kind Other <- IF Intent Feedback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3160,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Feedback Type Preview (Ingest)',\n  target: 'Parse Preview Feedback (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9173",
      "name": "Debug Log After: IF Feedback Type Preview (Ingest) -> Parse Preview Feedback (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2560,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Feedback Type Preview (Ingest)',\n  target: 'Parse Preview Feedback (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9174",
      "name": "Debug Log Before: Parse Preview Feedback (Ingest) <- IF Feedback Type Preview (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2500,
        160
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Feedback Type Preview (Ingest)',\n  target: 'Parse Feedback (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9175",
      "name": "Debug Log After: IF Feedback Type Preview (Ingest) -> Parse Feedback (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2560,
        360
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Feedback Type Preview (Ingest)',\n  target: 'Parse Feedback (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9176",
      "name": "Debug Log Before: Parse Feedback (Ingest) <- IF Feedback Type Preview (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2500,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Parse Preview Feedback (Ingest)',\n  target: 'Store Preview Feedback (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9177",
      "name": "Debug Log After: Parse Preview Feedback (Ingest) -> Store Preview Feedback (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2780,
        160
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Parse Preview Feedback (Ingest)',\n  target: 'Store Preview Feedback (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9178",
      "name": "Debug Log Before: Store Preview Feedback (Ingest) <- Parse Preview Feedback (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2720,
        160
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Store Preview Feedback (Ingest)',\n  target: 'Build Feedback Ack (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9179",
      "name": "Debug Log After: Store Preview Feedback (Ingest) -> Build Feedback Ack (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3000,
        160
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Store Preview Feedback (Ingest)',\n  target: 'Build Feedback Ack (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9180",
      "name": "Debug Log Before: Build Feedback Ack (Ingest) <- Store Preview Feedback (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4040,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Parse Feedback (Ingest)',\n  target: 'Load Feedback Context (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9181",
      "name": "Debug Log After: Parse Feedback (Ingest) -> Load Feedback Context (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2780,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Parse Feedback (Ingest)',\n  target: 'Load Feedback Context (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9182",
      "name": "Debug Log Before: Load Feedback Context (Ingest) <- Parse Feedback (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2720,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Load Feedback Context (Ingest)',\n  target: 'Build Feedback Decision Prompt (JP) (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9183",
      "name": "Debug Log After: Load Feedback Context (Ingest) -> Build Feedback Decision Prompt (JP) (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3000,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Load Feedback Context (Ingest)',\n  target: 'Build Feedback Decision Prompt (JP) (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9184",
      "name": "Debug Log Before: Build Feedback Decision Prompt (JP) (Ingest) <- Load Feedback Context (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2940,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Feedback Decision Prompt (JP) (Ingest)',\n  target: 'Record Prompt History (Feedback Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9185",
      "name": "Debug Log After: Build Feedback Decision Prompt (JP) (Ingest) -> Record Prompt History (Feedback Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3220,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Feedback Decision Prompt (JP) (Ingest)',\n  target: 'Record Prompt History (Feedback Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9186",
      "name": "Debug Log Before: Record Prompt History (Feedback Ingest) <- Build Feedback Decision Prompt (JP) (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3160,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Record Prompt History (Feedback Ingest)',\n  target: 'OpenAI Feedback Decide (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9187",
      "name": "Debug Log After: Record Prompt History (Feedback Ingest) -> OpenAI Feedback Decide (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3440,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Record Prompt History (Feedback Ingest)',\n  target: 'OpenAI Feedback Decide (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9188",
      "name": "Debug Log Before: OpenAI Feedback Decide (Ingest) <- Record Prompt History (Feedback Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3380,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'OpenAI Feedback Decide (Ingest)',\n  target: 'Parse Feedback Decision Response (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9189",
      "name": "Debug Log After: OpenAI Feedback Decide (Ingest) -> Parse Feedback Decision Response (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3660,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'OpenAI Feedback Decide (Ingest)',\n  target: 'Parse Feedback Decision Response (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9190",
      "name": "Debug Log Before: Parse Feedback Decision Response (Ingest) <- OpenAI Feedback Decide (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3600,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Parse Feedback Decision Response (Ingest)',\n  target: 'Store Feedback (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9191",
      "name": "Debug Log After: Parse Feedback Decision Response (Ingest) -> Store Feedback (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3880,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Parse Feedback Decision Response (Ingest)',\n  target: 'Store Feedback (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9192",
      "name": "Debug Log Before: Store Feedback (Ingest) <- Parse Feedback Decision Response (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3820,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Store Feedback (Ingest)',\n  target: 'Build Feedback Ack (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9193",
      "name": "Debug Log After: Store Feedback (Ingest) -> Build Feedback Ack (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4100,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Store Feedback (Ingest)',\n  target: 'Build Feedback Ack (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9194",
      "name": "Debug Log Before: Build Feedback Ack (Ingest) <- Store Feedback (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4040,
        580
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Feedback Ack (Ingest)',\n  target: 'IF Zulip Source (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9195",
      "name": "Debug Log After: Build Feedback Ack (Ingest) -> IF Zulip Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4320,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Feedback Ack (Ingest)',\n  target: 'IF Zulip Source (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9196",
      "name": "Debug Log Before: IF Zulip Source (Ingest) <- Build Feedback Ack (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2380,
        340
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Event Kind Other',\n  target: 'Update Normalized Event (Other)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9197",
      "name": "Debug Log After: IF Event Kind Other -> Update Normalized Event (Other)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3440,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Event Kind Other',\n  target: 'Update Normalized Event (Other)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9198",
      "name": "Debug Log Before: Update Normalized Event (Other) <- IF Event Kind Other",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3380,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Event Kind Other',\n  target: 'Update Normalized Event',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9199",
      "name": "Debug Log After: IF Event Kind Other -> Update Normalized Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3440,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Event Kind Other',\n  target: 'Update Normalized Event',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9200",
      "name": "Debug Log Before: Update Normalized Event <- IF Event Kind Other",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1960,
        320
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Needs Clarification (Other)',\n  target: 'Build Clarification Message (Other)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9201",
      "name": "Debug Log After: IF Needs Clarification (Other) -> Build Clarification Message (Other)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3660,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Needs Clarification (Other)',\n  target: 'Build Clarification Message (Other)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9202",
      "name": "Debug Log Before: Build Clarification Message (Other) <- IF Needs Clarification (Other)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3600,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Needs Clarification (Other)',\n  target: 'Build Friendly Reply (Other)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9203",
      "name": "Debug Log After: IF Needs Clarification (Other) -> Build Friendly Reply (Other)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3660,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Needs Clarification (Other)',\n  target: 'Build Friendly Reply (Other)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9204",
      "name": "Debug Log Before: Build Friendly Reply (Other) <- IF Needs Clarification (Other)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3820,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Clarification Message (Other)',\n  target: 'IF Zulip Source (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9205",
      "name": "Debug Log After: Build Clarification Message (Other) -> IF Zulip Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3880,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Clarification Message (Other)',\n  target: 'IF Zulip Source (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9206",
      "name": "Debug Log Before: IF Zulip Source (Ingest) <- Build Clarification Message (Other)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2380,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Update Normalized Event (Other)',\n  target: 'IF Needs Clarification (Other)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9207",
      "name": "Debug Log After: Update Normalized Event (Other) -> IF Needs Clarification (Other)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3660,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Update Normalized Event (Other)',\n  target: 'IF Needs Clarification (Other)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9208",
      "name": "Debug Log Before: IF Needs Clarification (Other) <- Update Normalized Event (Other)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3380,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Friendly Reply (Other)',\n  target: 'IF Zulip Source (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9209",
      "name": "Debug Log After: Build Friendly Reply (Other) -> IF Zulip Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4100,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Friendly Reply (Other)',\n  target: 'IF Zulip Source (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9210",
      "name": "Debug Log Before: IF Zulip Source (Ingest) <- Build Friendly Reply (Other)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2380,
        460
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Routing Prompt (JP)',\n  target: 'Record Prompt History (Routing)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9211",
      "name": "Debug Log After: Build Routing Prompt (JP) -> Record Prompt History (Routing)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2680,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Routing Prompt (JP)',\n  target: 'Record Prompt History (Routing)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9212",
      "name": "Debug Log Before: Record Prompt History (Routing) <- Build Routing Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2620,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Record Prompt History (Routing)',\n  target: 'OpenAI Routing Decide',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9213",
      "name": "Debug Log After: Record Prompt History (Routing) -> OpenAI Routing Decide",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2900,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Record Prompt History (Routing)',\n  target: 'OpenAI Routing Decide',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9214",
      "name": "Debug Log Before: OpenAI Routing Decide <- Record Prompt History (Routing)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2840,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'OpenAI Routing Decide',\n  target: 'Parse Routing Decide Response',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9215",
      "name": "Debug Log After: OpenAI Routing Decide -> Parse Routing Decide Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3120,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'OpenAI Routing Decide',\n  target: 'Parse Routing Decide Response',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9216",
      "name": "Debug Log Before: Parse Routing Decide Response <- OpenAI Routing Decide",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3060,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Parse Routing Decide Response',\n  target: 'IF Routing Decide OK',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9217",
      "name": "Debug Log After: Parse Routing Decide Response -> IF Routing Decide OK",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3340,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Parse Routing Decide Response',\n  target: 'IF Routing Decide OK',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9218",
      "name": "Debug Log Before: IF Routing Decide OK <- Parse Routing Decide Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3280,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Routing Decide OK',\n  target: 'Apply Selected Routing',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9219",
      "name": "Debug Log After: IF Routing Decide OK -> Apply Selected Routing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3560,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Routing Decide OK',\n  target: 'Apply Selected Routing',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9220",
      "name": "Debug Log Before: Apply Selected Routing <- IF Routing Decide OK",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3500,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Routing Decide OK',\n  target: 'Apply Escalation Routing',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9221",
      "name": "Debug Log After: IF Routing Decide OK -> Apply Escalation Routing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3560,
        580
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Routing Decide OK',\n  target: 'Apply Escalation Routing',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9222",
      "name": "Debug Log Before: Apply Escalation Routing <- IF Routing Decide OK",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Apply Selected Routing',\n  target: 'Update Routing Context',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9223",
      "name": "Debug Log After: Apply Selected Routing -> Update Routing Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3780,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Apply Selected Routing',\n  target: 'Update Routing Context',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9224",
      "name": "Debug Log Before: Update Routing Context <- Apply Selected Routing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2620,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Apply Escalation Routing',\n  target: 'Update Routing Context',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9225",
      "name": "Debug Log After: Apply Escalation Routing -> Update Routing Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2680,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Apply Escalation Routing',\n  target: 'Update Routing Context',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9226",
      "name": "Debug Log Before: Update Routing Context <- Apply Escalation Routing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2620,
        720
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Update Routing Context',\n  target: 'Build Summary Prompt (JP)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9227",
      "name": "Debug Log After: Update Routing Context -> Build Summary Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2900,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Update Routing Context',\n  target: 'Build Summary Prompt (JP)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9228",
      "name": "Debug Log Before: Build Summary Prompt (JP) <- Update Routing Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        820
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Initial Reply Prompt (JP)',\n  target: 'Record Prompt History (Initial Reply)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9229",
      "name": "Debug Log After: Build Initial Reply Prompt (JP) -> Record Prompt History (Initial Reply)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2720,
        140
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Initial Reply Prompt (JP)',\n  target: 'Record Prompt History (Initial Reply)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9230",
      "name": "Debug Log Before: Record Prompt History (Initial Reply) <- Build Initial Reply Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2660,
        140
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Record Prompt History (Initial Reply)',\n  target: 'OpenAI Initial Reply',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9231",
      "name": "Debug Log After: Record Prompt History (Initial Reply) -> OpenAI Initial Reply",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2940,
        140
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Record Prompt History (Initial Reply)',\n  target: 'OpenAI Initial Reply',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9232",
      "name": "Debug Log Before: OpenAI Initial Reply <- Record Prompt History (Initial Reply)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2880,
        140
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'OpenAI Initial Reply',\n  target: 'Use Chat Core Reply',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9233",
      "name": "Debug Log After: OpenAI Initial Reply -> Use Chat Core Reply",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3160,
        140
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'OpenAI Initial Reply',\n  target: 'Use Chat Core Reply',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9234",
      "name": "Debug Log Before: Use Chat Core Reply <- OpenAI Initial Reply",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3100,
        260
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Chat Core Prompt (JP)',\n  target: 'Record Prompt History (Chat Core)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9235",
      "name": "Debug Log After: Build Chat Core Prompt (JP) -> Record Prompt History (Chat Core)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2560,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Chat Core Prompt (JP)',\n  target: 'Record Prompt History (Chat Core)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9236",
      "name": "Debug Log Before: Record Prompt History (Chat Core) <- Build Chat Core Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2500,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Record Prompt History (Chat Core)',\n  target: 'OpenAI Chat Core',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9237",
      "name": "Debug Log After: Record Prompt History (Chat Core) -> OpenAI Chat Core",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2780,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Record Prompt History (Chat Core)',\n  target: 'OpenAI Chat Core',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9238",
      "name": "Debug Log Before: OpenAI Chat Core <- Record Prompt History (Chat Core)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2720,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'OpenAI Chat Core',\n  target: 'AIOPS Observer (Chat Core)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9239",
      "name": "Debug Log After: OpenAI Chat Core -> AIOPS Observer (Chat Core)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3000,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'OpenAI Chat Core',\n  target: 'AIOPS Observer (Chat Core)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9240",
      "name": "Debug Log Before: AIOPS Observer (Chat Core) <- OpenAI Chat Core",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2940,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'AIOPS Observer (Chat Core)',\n  target: 'Parse Chat Core Response',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9241",
      "name": "Debug Log After: AIOPS Observer (Chat Core) -> Parse Chat Core Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3220,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'AIOPS Observer (Chat Core)',\n  target: 'Parse Chat Core Response',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9242",
      "name": "Debug Log Before: Parse Chat Core Response <- AIOPS Observer (Chat Core)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2940,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Parse Chat Core Response',\n  target: 'IF Intent Approval',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9243",
      "name": "Debug Log After: Parse Chat Core Response -> IF Intent Approval",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3220,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Parse Chat Core Response',\n  target: 'IF Intent Approval',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9244",
      "name": "Debug Log Before: IF Intent Approval <- Parse Chat Core Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1840,
        320
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Use Chat Core Reply',\n  target: 'IF Zulip Source (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9245",
      "name": "Debug Log After: Use Chat Core Reply -> IF Zulip Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3380,
        140
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Use Chat Core Reply',\n  target: 'IF Zulip Source (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9246",
      "name": "Debug Log Before: IF Zulip Source (Ingest) <- Use Chat Core Reply",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2380,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Merge Preview with Chat Core',\n  target: 'IF Required Confirm',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9247",
      "name": "Debug Log After: Merge Preview with Chat Core -> IF Required Confirm",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        340
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Merge Preview with Chat Core',\n  target: 'IF Required Confirm',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9248",
      "name": "Debug Log Before: IF Required Confirm <- Merge Preview with Chat Core",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1980,
        340
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Load Escalation Matrix (GitLab)',\n  target: 'Load Escalation Context Age',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9249",
      "name": "Debug Log After: Load Escalation Matrix (GitLab) -> Load Escalation Context Age",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2460,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Load Escalation Matrix (GitLab)',\n  target: 'Load Escalation Context Age',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9250",
      "name": "Debug Log Before: Load Escalation Context Age <- Load Escalation Matrix (GitLab)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2380,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Load Escalation Context Age',\n  target: 'Attach Escalation Context',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9251",
      "name": "Debug Log After: Load Escalation Context Age -> Attach Escalation Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2660,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Load Escalation Context Age',\n  target: 'Attach Escalation Context',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9252",
      "name": "Debug Log Before: Attach Escalation Context <- Load Escalation Context Age",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2580,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Attach Escalation Context',\n  target: 'Build Routing Prompt (JP)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9253",
      "name": "Debug Log After: Attach Escalation Context -> Build Routing Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2860,
        660
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Attach Escalation Context',\n  target: 'Build Routing Prompt (JP)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9254",
      "name": "Debug Log Before: Build Routing Prompt (JP) <- Attach Escalation Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Verify Keycloak Membership (Zulip)',\n  target: 'IF Keycloak Membership OK',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9255",
      "name": "Debug Log After: Verify Keycloak Membership (Zulip) -> IF Keycloak Membership OK",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1180,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Verify Keycloak Membership (Zulip)',\n  target: 'IF Keycloak Membership OK',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9256",
      "name": "Debug Log Before: IF Keycloak Membership OK <- Verify Keycloak Membership (Zulip)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Keycloak Membership OK',\n  target: 'Context Store (Insert)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9257",
      "name": "Debug Log After: IF Keycloak Membership OK -> Context Store (Insert)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1380,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Keycloak Membership OK',\n  target: 'Context Store (Insert)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9258",
      "name": "Debug Log Before: Context Store (Insert) <- IF Keycloak Membership OK",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1020,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Keycloak Membership OK',\n  target: 'Build Keycloak Reject Message (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9259",
      "name": "Debug Log After: IF Keycloak Membership OK -> Build Keycloak Reject Message (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1380,
        260
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Keycloak Membership OK',\n  target: 'Build Keycloak Reject Message (Ingest)',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9260",
      "name": "Debug Log Before: Build Keycloak Reject Message (Ingest) <- IF Keycloak Membership OK",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1320,
        80
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Keycloak Reject Message (Ingest)',\n  target: 'IF Zulip Source (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9261",
      "name": "Debug Log After: Build Keycloak Reject Message (Ingest) -> IF Zulip Source (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        80
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Keycloak Reject Message (Ingest)',\n  target: 'IF Zulip Source (Ingest)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9262",
      "name": "Debug Log Before: IF Zulip Source (Ingest) <- Build Keycloak Reject Message (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2380,
        580
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Guard Valid (Ingest)',\n  target: 'Verify Keycloak Membership (Zulip)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9263",
      "name": "Debug Log After: Guard Valid (Ingest) -> Verify Keycloak Membership (Zulip)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1020,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Guard Valid (Ingest)',\n  target: 'Verify Keycloak Membership (Zulip)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "9264",
      "name": "Debug Log Before: Verify Keycloak Membership (Zulip) <- Guard Valid (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        200
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javaScript",
        "jsCode": "const item = $json ?? {};\nconst intent = item.intent ?? item.event_kind ?? '';\nif (intent !== 'approval') return [];\nreturn [{ json: item }];\n"
      },
      "id": "2001",
      "name": "Guard Approval Intent (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3600,
        60
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javaScript",
        "jsCode": "const item = $json ?? {};\nconst intent = item.intent ?? item.event_kind ?? '';\nif (intent === 'approval') return [];\nreturn [{ json: item }];\n"
      },
      "id": "2002",
      "name": "Guard Non-Approval Intent (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3600,
        340
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javaScript",
        "jsCode": "const item = $json ?? {};\nconst intent = item.intent ?? item.event_kind ?? '';\nif (intent !== 'feedback') return [];\nreturn [{ json: item }];\n"
      },
      "id": "2003",
      "name": "Guard Feedback Intent (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3840,
        260
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javaScript",
        "jsCode": "const item = $json ?? {};\nconst intent = item.intent ?? item.event_kind ?? '';\nif (intent !== 'other') return [];\nreturn [{ json: item }];\n"
      },
      "id": "2004",
      "name": "Guard Other Intent (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3840,
        520
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javaScript",
        "jsCode": "const base = $json ?? {};\n\nif ((base.source ?? base.reply_target?.source) !== 'zulip') {\n  return [{ json: base }];\n}\n\nconst replyTarget = base.reply_target ?? {};\nif (replyTarget.type !== 'stream' || !replyTarget.stream || !replyTarget.topic) {\n  return [{ json: base }];\n}\n\n// Keep webhook responses fast for OQ topics/streams (Zulip outgoing webhook can time out).\n// NOTE: send_stub_event.py（OQ）は X-AIOPS-TRACE-ID を付けるため、\n//       それが付いている場合は OQ でも topic context を取得する。\nconst streamName = String(replyTarget.stream ?? '').trim();\nconst topicName = String(replyTarget.topic ?? '').trim();\nconst isOq = streamName === '0perational Qualification' || topicName === 'oq-runner' || /^oq-/i.test(topicName);\n\nconst hasTraceId = (() => {\n  const ne = (base.normalized_event && typeof base.normalized_event === 'object') ? base.normalized_event : {};\n  const raw = ne.raw_headers ?? ne.rawHeaders ?? {};\n  if (!raw || typeof raw !== 'object') return false;\n  for (const k of Object.keys(raw)) {\n    if (String(k).toLowerCase() === 'x-aiops-trace-id') {\n      const v = raw[k];\n      return v !== undefined && v !== null && String(v).trim() !== '';\n    }\n  }\n  return false;\n})();\n\nif (isOq && !hasTraceId) {\n  // OQ topics also require context continuity; do not skip fetch here.\n}\n\nconst enabledRaw = String($env.N8N_ZULIP_TOPIC_CONTEXT_FETCH_ENABLED ?? 'true').toLowerCase();\nconst enabled = !['0', 'false', 'no', 'off'].includes(enabledRaw);\nif (!enabled) {\n  return [{ json: base }];\n}\n\nconst normalized = { ...(base.normalized_event ?? {}) };\nconst textRaw = String(normalized.text ?? '').trim();\n\nconst stripNoise = (value) => {\n  return String(value ?? '')\n    .replace(/<[^>]+>/g, ' ')\n    .replace(/@[\\w\\-]+/g, ' ')\n    .replace(/[\\*_`]+/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim();\n};\n\nconst text = stripNoise(textRaw);\nif (!text) {\n  return [{ json: base }];\n}\n\nconst maxTextCharsRaw = $env.N8N_ZULIP_TOPIC_CONTEXT_FETCH_TEXT_MAX_CHARS ?? '100';\nconst maxTextChars = Number.isFinite(Number(maxTextCharsRaw)) ? Math.max(1, Math.floor(Number(maxTextCharsRaw))) : 100;\n\nif (text.length >= maxTextChars) {\n  return [{ json: base }];\n}\n\nconst tenant = replyTarget.tenant ?? replyTarget.realm ?? base.actor?.tenant ?? base.actor?.realm ?? 'default';\n\nconst parseYamlMap = (text) => {\n  const map = {};\n  String(text).split(/\\r?\\n/).forEach((line) => {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed.startsWith('#')) return;\n    const idx = trimmed.indexOf(':');\n    if (idx <= 0) return;\n    const key = trimmed.slice(0, idx).trim();\n    let value = trimmed.slice(idx + 1).trim();\n    if (!key) return;\n    value = value.replace(/^['\"]|['\"]$/g, '');\n    map[key] = value;\n  });\n  return map;\n};\n\nconst parseMap = (jsonRaw, yamlRaw) => {\n  let map = {};\n  if (jsonRaw) {\n    try {\n      const parsed = JSON.parse(jsonRaw);\n      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n        map = parsed;\n      }\n    } catch (error) {}\n  }\n  if (!Object.keys(map).length && yamlRaw) {\n    map = parseYamlMap(yamlRaw);\n  }\n  return map;\n};\n\nconst tokenMap = parseMap(\n  $env.N8N_ZULIP_BOT_TOKENS_JSON || $env.N8N_ZULIP_BOT_TOKEN || '',\n  $env.N8N_ZULIP_BOT_TOKENS_YAML || $env.N8N_ZULIP_BOT_TOKEN || $env.ZULIP_BOT_TOKEN || ''\n);\nconst emailMap = parseMap(\n  $env.N8N_ZULIP_BOT_EMAILS_JSON || $env.N8N_ZULIP_BOT_EMAIL || '',\n  $env.N8N_ZULIP_BOT_EMAILS_YAML || $env.N8N_ZULIP_BOT_EMAIL || $env.ZULIP_BOT_EMAIL || ''\n);\nconst baseUrlMap = parseMap(\n  $env.N8N_ZULIP_API_BASE_URLS_JSON || $env.N8N_ZULIP_API_BASE_URL || '',\n  $env.N8N_ZULIP_API_BASE_URLS_YAML || $env.N8N_ZULIP_API_BASE_URL || $env.ZULIP_API_BASE_URL || ''\n);\n\nconst botToken = (tenant && tokenMap[tenant]) ? tokenMap[tenant] : (tokenMap.default || $env.N8N_ZULIP_BOT_TOKEN || $env.ZULIP_BOT_TOKEN || '');\nconst botEmail = (tenant && emailMap[tenant]) ? emailMap[tenant] : (emailMap.default || $env.N8N_ZULIP_BOT_EMAIL || $env.ZULIP_BOT_EMAIL || '');\nconst baseUrl = (tenant && baseUrlMap[tenant]) ? baseUrlMap[tenant] : (baseUrlMap.default || $env.N8N_ZULIP_API_BASE_URL || $env.ZULIP_API_BASE_URL || '');\n\nif (!botEmail || !botToken || !baseUrl) {\n  normalized.zulip_topic_context = {\n    fetched: false,\n    reason: 'missing_zulip_bot_credentials'\n  };\n  return [{ json: { ...base, normalized_event: normalized } }];\n}\n\nconst maxMessagesRaw = $env.N8N_ZULIP_TOPIC_CONTEXT_FETCH_MAX_MESSAGES ?? '10';\nconst maxMessages = Number.isFinite(Number(maxMessagesRaw)) ? Math.max(1, Math.floor(Number(maxMessagesRaw))) : 10;\n\nconst perMessageMaxCharsRaw = $env.N8N_ZULIP_TOPIC_CONTEXT_FETCH_MAX_CHARS_PER_MESSAGE ?? '200';\nconst perMessageMaxChars = Number.isFinite(Number(perMessageMaxCharsRaw)) ? Math.max(20, Math.floor(Number(perMessageMaxCharsRaw))) : 200;\n\nconst timeoutMsRaw = $env.N8N_ZULIP_TOPIC_CONTEXT_FETCH_TIMEOUT_MS ?? '5000';\nconst timeoutMs = Number.isFinite(Number(timeoutMsRaw)) ? Math.max(1000, Math.floor(Number(timeoutMsRaw))) : 5000;\n\nconst trimmed = String(baseUrl).replace(/\\/+$/, '');\nconst apiBase = trimmed.endsWith('/api/v1') ? trimmed : (trimmed + '/api/v1');\n\nconst streamOperand = Number.isFinite(Number(replyTarget.stream)) ? Number(replyTarget.stream) : String(replyTarget.stream);\nconst narrow = [\n  { operator: 'stream', operand: streamOperand },\n  { operator: 'topic', operand: String(replyTarget.topic) }\n];\n\nconst anchor = 'newest';\nconst qs = [\n  ['anchor', anchor],\n  ['num_before', String(maxMessages)],\n  ['num_after', '0'],\n  ['narrow', JSON.stringify(narrow)]\n].map(([k, v]) => encodeURIComponent(String(k)) + '=' + encodeURIComponent(String(v))).join('&');\n\nconst url = apiBase + '/messages?' + qs;\nconst auth = 'Basic ' + Buffer.from(String(botEmail) + ':' + String(botToken)).toString('base64');\n\nlet responseRaw;\nlet parsed = null;\ntry {\n  responseRaw = await this.helpers.httpRequest({\n    method: 'GET',\n    url,\n    headers: { Authorization: auth },\n    timeout: timeoutMs\n  });\n\n  parsed = responseRaw;\n  if (typeof responseRaw === 'string') {\n    try { parsed = JSON.parse(responseRaw); } catch (error) { parsed = null; }\n  }\n} catch (error) {\n  normalized.zulip_topic_context = {\n    fetched: false,\n    reason: 'zulip_api_error',\n    error: String(error?.message || error)\n  };\n  return [{ json: { ...base, normalized_event: normalized } }];\n}\n\nconst messages = Array.isArray(parsed?.messages) ? parsed.messages : [];\n\nconst sanitizeContent = (value) => {\n  const raw = String(value ?? '');\n  const collapsed = raw.replace(/\\s+/g, ' ').trim();\n  const maskedEmail = collapsed.replace(/[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}/g, '(email)');\n  return maskedEmail.length > perMessageMaxChars ? (maskedEmail.slice(0, perMessageMaxChars) + '…') : maskedEmail;\n};\n\nconst contextMessages = messages\n  .slice(-maxMessages)\n  .map((m) => ({\n    id: m?.id ?? null,\n    timestamp: m?.timestamp ?? null,\n    role: m?.is_me_message ? 'bot' : 'user',\n    content: sanitizeContent(m?.content ?? '')\n  }))\n  .filter((m) => m.content);\n\nnormalized.zulip_topic_context = {\n  fetched: true,\n  tenant,\n  stream: streamOperand,\n  topic: String(replyTarget.topic),\n  anchor,\n  messages: contextMessages\n};\n\nreturn [{ json: { ...base, normalized_event: normalized } }];\n"
      },
      "id": "9901",
      "name": "Maybe Fetch Zulip Topic Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1440,
        120
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javaScript",
        "jsCode": "const base = $json ?? {};\n\nif ((base.source ?? base.reply_target?.source) !== 'zulip') {\n  return [{ json: base }];\n}\n\nconst normalized = { ...(base.normalized_event ?? {}) };\nconst ztc = (normalized.zulip_topic_context && typeof normalized.zulip_topic_context === 'object')\n  ? normalized.zulip_topic_context\n  : null;\n\nconst messages = Array.isArray(ztc?.messages) ? ztc.messages : null;\nif (!messages) {\n  return [{ json: base }];\n}\n\nconst decodeEntities = (value) => String(value ?? '')\n  .replace(/&nbsp;/g, ' ')\n  .replace(/&lt;/g, '<')\n  .replace(/&gt;/g, '>')\n  .replace(/&amp;/g, '&')\n  .replace(/&quot;/g, '\"')\n  .replace(/&#39;/g, \"'\");\n\nconst stripHtml = (value) => {\n  const raw = decodeEntities(value);\n  return raw\n    .replace(/<[^>]+>/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim();\n};\n\nconst nextMessages = messages\n  .map((m) => {\n    const msg = (m && typeof m === 'object') ? { ...m } : { content: String(m ?? '') };\n    msg.content = stripHtml(msg.content);\n    return msg;\n  })\n  .filter((m) => m.content);\n\nnormalized.zulip_topic_context = {\n  ...ztc,\n  messages: nextMessages\n};\n\nreturn [{\n  json: {\n    ...base,\n    normalized_event: normalized\n  }\n}];\n"
      },
      "id": "strip-html-zulip-topic-context",
      "name": "Strip HTML (Zulip Topic Context)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1560,
        120
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT\n  context_id::text AS context_id,\n  reply_target->>'message_id' AS message_id,\n  reply_target->>'stream' AS stream,\n  reply_target->>'topic' AS topic,\n  normalized_event->>'received_at' AS received_at,\n  normalized_event->>'text' AS text\nFROM aiops_context\nWHERE source = 'zulip'\n  AND reply_target->>'stream' = '{{ String($json.reply_target.stream ?? '').replace(/'/g, \"''\") }}'\n  AND reply_target->>'topic' = '{{ String($json.reply_target.topic ?? '').replace(/'/g, \"''\") }}'\nORDER BY NULLIF(normalized_event->>'received_at','')::timestamptz DESC NULLS LAST\nLIMIT 10;"
      },
      "id": "9905",
      "name": "Load Zulip Topic Context (DB)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        1660,
        40
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javaScript",
        "jsCode": "const base = (() => {\n  try {\n    const items = $items('Maybe Fetch Zulip Topic Context');\n    if (Array.isArray(items) && items[0] && items[0].json) return items[0].json;\n  } catch (error) {}\n  return $json ?? {};\n})();\n\nconst normalized = { ...(base.normalized_event ?? {}) };\nconst existing = (normalized.zulip_topic_context && typeof normalized.zulip_topic_context === 'object')\n  ? { ...normalized.zulip_topic_context }\n  : {};\n\nconst sanitizeText = (value) => {\n  return String(value ?? '')\n    .replace(/<script[\\s\\S]*?<\\/script>/gi, ' ')\n    .replace(/<style[\\s\\S]*?<\\/style>/gi, ' ')\n    .replace(/<br\\s*\\/?>/gi, ' ')\n    .replace(/<\\/p\\s*>/gi, ' ')\n    .replace(/<[^>]+>/g, ' ')\n    .replace(/&nbsp;/gi, ' ')\n    .replace(/&amp;/gi, '&')\n    .replace(/&quot;/gi, '\"')\n    .replace(/&#39;/g, \"'\")\n    .replace(/&lt;/gi, '<')\n    .replace(/&gt;/gi, '>')\n    .replace(/[\\*_`]+/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim();\n};\n\nconst already = Array.isArray(existing.messages) ? existing.messages : [];\nif (already.length === 0) {\n  const rows = $input.all().map((item) => item.json);\n  const mapped = rows\n    .map((row) => {\n      const content = sanitizeText(row?.text ?? '');\n      if (!content) return null;\n      return {\n        id: row?.message_id ?? row?.context_id ?? null,\n        timestamp: row?.received_at ?? null,\n        role: 'user',\n        content\n      };\n    })\n    .filter(Boolean)\n    .reverse();\n\n  existing.anchor = existing.anchor ?? 'db';\n  existing.messages = mapped;\n}\n\nexisting.messages = (Array.isArray(existing.messages) ? existing.messages : [])\n  .map((m) => ({ ...m, content: sanitizeText(m?.content ?? '') }))\n  .filter((m) => m.content);\n\nexisting.fetched = existing.fetched ?? true;\nexisting.stream = existing.stream ?? base.reply_target?.stream ?? null;\nexisting.topic = existing.topic ?? base.reply_target?.topic ?? null;\nexisting.tenant = existing.tenant ?? base.reply_target?.tenant ?? base.reply_target?.realm ?? null;\n\nconst currentText = String(normalized.text ?? '').trim();\nconst msgs = Array.isArray(existing.messages) ? existing.messages : [];\nif (msgs.length >= 1 && currentText && currentText.length < 120) {\n  const history = msgs.map((m) => `- ${m.content}`).join('\\n');\n  const combined = currentText + '\\n\\n同一トピックの過去発言:\\n' + history;\n  if (!normalized.original_text) normalized.original_text = normalized.text;\n  normalized.text = combined;\n}\n\nnormalized.zulip_topic_context = existing;\n\nreturn [{\n  json: {\n    ...base,\n    normalized_event: normalized\n  }\n}];\n"
      },
      "id": "9906",
      "name": "Attach Zulip Topic Context (DB Fallback)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1860,
        40
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javaScript",
        "jsCode": "const base = $json ?? {};\n\nif ((base.source ?? base.reply_target?.source) !== 'zulip') {\n  return [{ json: base }];\n}\n\nconst normalized = { ...(base.normalized_event ?? {}) };\nconst ztc = (normalized.zulip_topic_context && typeof normalized.zulip_topic_context === 'object')\n  ? normalized.zulip_topic_context\n  : null;\n\nconst anchor = String(ztc?.anchor ?? '').toLowerCase();\nif (anchor !== 'db') {\n  return [{ json: base }];\n}\n\n// DBフォールバックの履歴は誤ったトピック混入を起こしやすいため、\n// LLM入力（normalized.text）へ短文結合した内容がある場合は元に戻す\nconst original = String(normalized.original_text ?? '').trim();\nif (!original) {\n  return [{ json: base }];\n}\n\nnormalized.text = original;\n\nreturn [{\n  json: {\n    ...base,\n    normalized_event: normalized\n  }\n}];\n"
      },
      "id": "sanitize-zulip-topic-context-text",
      "name": "Sanitize Zulip Topic Context Text (DB Fallback)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        80
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE aiops_context\nSET\n  normalized_event = normalized_event || COALESCE(NULLIF('{{ JSON.stringify($json.normalized_event || {}).replace(/'/g, \"''\") }}','undefined')::jsonb, '{}'::jsonb)\nWHERE context_id = NULLIF(NULLIF('{{ $json.context_id }}',''), 'undefined')::uuid;\n\nSELECT 1 AS ok;\n",
        "options": {}
      },
      "id": "9902",
      "name": "Persist Topic Context (Zulip)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        1660,
        120
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javaScript",
        "jsCode": "try {\n  return $items('Attach Zulip Topic Context (DB Fallback)');\n} catch (error) {\n  try {\n    return $items('Maybe Fetch Zulip Topic Context');\n  } catch (inner) {\n    return $input.all();\n  }\n}\n"
      },
      "id": "9903",
      "name": "Pass Through After Topic Context Persist",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1860,
        120
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javaScript",
        "jsCode": "let restored = $input.all();\n\nfunction use(items) {\n  if (Array.isArray(items) && items.length > 0) restored = items;\n}\n\ntry { use($items('Validate Zulip')); } catch (error) {}\ntry { use($items('Validate Slack')); } catch (error) {}\ntry { use($items('Validate Mattermost')); } catch (error) {}\ntry { use($items('Validate Teams')); } catch (error) {}\ntry { use($items('Validate CloudWatch')); } catch (error) {}\n\nreturn restored;\n"
      },
      "id": "9904",
      "name": "Restore Items After Respond",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1240,
        200
      ]
    },
    {
      "id": "9907",
      "name": "Build Enrichment Plan Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3500,
        440
      ],
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst base = $json ?? {};\nconst normalizedEvent = { ...(base.normalized_event ?? {}) };\ndelete normalizedEvent.raw_headers;\ndelete normalizedEvent.raw_body;\n\nconst input = {\n  normalized_event: normalizedEvent,\n  actor: base.actor ?? {},\n  reply_target: base.reply_target ?? {},\n  iam_context: base.iam_context ?? {},\n  policy_context: base.policy_context ?? {},\n  rag_route: base.rag_route ?? null\n};\n\nconst promptText = \"__PROMPT__ENRICHMENT_PLAN__\";\nconst promptHash = crypto.createHash('sha256').update(promptText).digest('hex');\n\nreturn [{\n  json: {\n    ...base,\n    prompt_key: 'adapter.enrichment_plan.v1',\n    prompt_version: 'ja-1',\n    prompt_text: promptText,\n    prompt_hash: promptHash,\n    prompt_input: JSON.stringify(input)\n  }\n}];\n"
      }
    },
    {
      "id": "9908",
      "name": "Record Prompt History (Enrichment Plan)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        3500,
        560
      ],
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO aiops_prompt_history (prompt_key, prompt_version, prompt_text, prompt_hash, source_workflow, source_node)\nVALUES (\n  '{{ String($json.prompt_key ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_version ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_text ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_hash ?? \"\").replace(/'/g, \"''\") }}',\n  'aiops-adapter-ingest',\n  'OpenAI Enrichment Plan'\n)\nON CONFLICT (prompt_key, prompt_hash) DO NOTHING;"
      }
    },
    {
      "id": "9909",
      "name": "OpenAI Enrichment Plan",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        3500,
        680
      ],
      "parameters": {
        "resource": "chat",
        "operation": "complete",
        "model": "={{$env.OPENAI_MODEL || 'gpt-4o-mini'}}",
        "prompt": {
          "messages": [
            {
              "role": "system",
              "content": "={{ $node['Build Enrichment Plan Prompt (JP)'].json.prompt_text }}"
            },
            {
              "role": "user",
              "content": "={{ '入力:\\n' + $node['Build Enrichment Plan Prompt (JP)'].json.prompt_input }}"
            }
          ]
        },
        "options": {
          "temperature": 0.2,
          "baseURL": "={{$env.OPENAI_BASE_URL}}",
          "maxTokens": "={{$json.policy_context?.limits?.llm_output_tokens || 1200}}"
        }
      },
      "credentials": {
        "openAiApi": {
          "name": "aiops-openai"
        }
      },
      "disabled": true
    },
    {
      "id": "9910",
      "name": "Parse Enrichment Plan Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3500,
        800
      ],
      "parameters": {
        "jsCode": "const base = $node['Build Enrichment Plan Prompt (JP)'].json ?? {};\nconst response = $json ?? {};\n\nconst extractContent = (payload) => {\n  return payload?.message?.content\n    ?? payload?.choices?.[0]?.message?.content\n    ?? payload?.choices?.[0]?.text\n    ?? payload?.data?.choices?.[0]?.message?.content\n    ?? payload?.data?.choices?.[0]?.text\n    ?? payload?.content\n    ?? '';\n};\n\nconst rawContent = extractContent(response);\nlet parsed = null;\nif (typeof rawContent === 'string') {\n  try {\n    parsed = JSON.parse(rawContent);\n  } catch (error) {\n    const match = rawContent.match(/\\{[\\s\\S]*\\}/);\n    if (match) {\n      try {\n        parsed = JSON.parse(match[0]);\n      } catch (inner) {\n        parsed = null;\n      }\n    }\n  }\n} else if (rawContent && typeof rawContent === 'object') {\n  parsed = rawContent;\n}\n\nconst policyContext = base.policy_context ?? {};\nconst defaults = policyContext?.defaults?.enrichment_plan ?? {};\nconst fallbacks = policyContext?.fallbacks?.enrichment_plan ?? {};\nconst limits = policyContext?.limits?.enrichment_plan ?? {};\n\nconst isObject = (v) => Boolean(v) && typeof v === 'object' && !Array.isArray(v);\nconst isNonEmptyString = (v) => typeof v === 'string' && v.trim().length > 0;\n\nfunction clampInt(value, min, max, fallback) {\n  const n = Number.parseInt(String(value ?? ''), 10);\n  if (!Number.isFinite(n)) return fallback;\n  return Math.max(min, Math.min(max, n));\n}\n\nfunction normalizeTarget(entry) {\n  if (!entry) return null;\n  if (typeof entry === 'string') {\n    return { target: entry.trim().toLowerCase(), enabled: true };\n  }\n  if (!isObject(entry)) return null;\n  const target = isNonEmptyString(entry.target) ? String(entry.target).trim().toLowerCase() : null;\n  if (!target) return null;\n  const enabled = typeof entry.enabled === 'boolean' ? entry.enabled : true;\n  const method = isNonEmptyString(entry.method) ? String(entry.method).trim().toLowerCase() : null;\n  return { target, enabled, method };\n}\n\nconst planWrapper = isObject(parsed?.enrichment_plan) ? parsed.enrichment_plan : null;\nconst outPlan = planWrapper && isObject(planWrapper)\n  ? { ...defaults, ...planWrapper }\n  : { ...defaults };\n\nconst cap = clampInt(outPlan?.chat_context?.max_messages, 0,\n  clampInt(limits?.chat_context_max_messages_cap, 0, 1000, 20),\n  clampInt(defaults?.chat_context?.max_messages, 0, 1000, 0)\n);\nif (!isObject(outPlan.chat_context)) outPlan.chat_context = { ...(defaults?.chat_context ?? {}) };\noutPlan.chat_context.max_messages = cap;\n\nconst targetsRaw = Array.isArray(outPlan.targets) ? outPlan.targets : (Array.isArray(defaults?.targets) ? defaults.targets : []);\nconst targets = targetsRaw.map(normalizeTarget).filter(Boolean);\noutPlan.targets = targets;\n\nconst needsClarification = typeof parsed?.needs_clarification === 'boolean'\n  ? parsed.needs_clarification\n  : Boolean(fallbacks?.needs_clarification ?? false);\n\nconst clarifyingQuestions = Array.isArray(parsed?.clarifying_questions)\n  ? parsed.clarifying_questions.map((v) => String(v)).filter((v) => v.trim())\n  : [];\n\nconst confidence = typeof parsed?.confidence === 'number' ? parsed.confidence : null;\n\nreturn [{\n  json: {\n    ...base,\n    enrichment_plan: outPlan,\n    enrichment_plan_llm_ok: Boolean(planWrapper),\n    needs_clarification: needsClarification,\n    clarifying_questions: clarifyingQuestions,\n    enrichment_plan_confidence: confidence,\n    enrichment_plan_rationale: parsed?.rationale ?? null\n  }\n}];\n"
      }
    },
    {
      "id": "9911",
      "name": "Enrich RAG Route (Enrichment)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3500,
        920
      ],
      "parameters": {
        "jsCode": "const input = $json ?? {};\nconst policyContext = input.policy_context ?? {};\n\nconst ragRoute = input.rag_route ?? {};\nconst defaults = policyContext?.defaults?.rag_router ?? {};\nconst limits = policyContext?.limits?.rag_router ?? {};\n\nfunction sanitizeSqlString(value) {\n  if (value === null || value === undefined) return null;\n  const s = String(value).trim();\n  if (!s) return null;\n  return s.replace(/'/g, \"''\");\n}\n\nfunction sanitizeVocab(value) {\n  if (value === null || value === undefined) return null;\n  const s = String(value).trim().toLowerCase();\n  if (!s) return null;\n  return s;\n}\n\nconst allowedModes = Array.isArray(policyContext?.taxonomy?.rag_mode_vocab)\n  ? new Set(policyContext.taxonomy.rag_mode_vocab.map((v) => String(v).trim()))\n  : null;\n\nconst rawMode = String(ragRoute.mode ?? ragRoute.rag_mode ?? defaults.mode ?? 'kedb_documents').trim();\nconst rag_mode = allowedModes && !allowedModes.has(rawMode) ? (defaults.mode ?? 'kedb_documents') : rawMode;\n\nconst maxDefault = Number.isFinite(Number(limits?.top_k_default)) ? Number(limits.top_k_default) : 5;\nconst maxCap = Number.isFinite(Number(limits?.top_k_cap)) ? Number(limits.top_k_cap) : 10;\nconst requestedTopK = Number.isFinite(Number(ragRoute.top_k)) ? Number(ragRoute.top_k) : null;\nconst rag_top_k = Math.max(1, Math.min(maxCap, Math.floor(requestedTopK ?? maxDefault)));\n\nconst query = String(ragRoute.query ?? input.normalized_event?.text ?? '').slice(0, 400);\nconst sanitizedQuery = query.replace(/[\u0000-\u001f]/g, ' ').trim();\n\nconst filters = (ragRoute.filters && typeof ragRoute.filters === 'object') ? ragRoute.filters : {};\nconst problemStatuses = Array.isArray(filters.problem_statuses) ? filters.problem_statuses.slice(0, 20).map((v) => sanitizeVocab(v)).filter(Boolean) : [];\nconst problemStatusesSql = problemStatuses.length > 0\n  ? `ARRAY[${problemStatuses.map((v) => `'${v}'`).join(',')}]::text[]`\n  : null;\n\nconst allowedDomains = Array.isArray(policyContext?.taxonomy?.management_domain_vocab)\n  ? new Set(policyContext.taxonomy.management_domain_vocab.map((v) => String(v).trim().toLowerCase()).filter(Boolean))\n  : null;\n\nconst rawDomains = Array.isArray(filters.management_domains)\n  ? filters.management_domains\n  : (filters.management_domain ? [filters.management_domain] : []);\n\nlet managementDomains = rawDomains.map((v) => sanitizeVocab(v)).filter(Boolean);\nif (allowedDomains) managementDomains = managementDomains.filter((v) => allowedDomains.has(v));\nmanagementDomains = [...new Set(managementDomains)].slice(0, 10);\nconst managementDomainsSql = managementDomains.length > 0\n  ? `ARRAY[${managementDomains.map((v) => `'${v}'`).join(',')}]::text[]`\n  : null;\n\nreturn [{\n  json: {\n    ...input,\n    rag_mode,\n    rag_query: sanitizedQuery,\n    rag_top_k,\n    rag_filters: {\n      service_name: sanitizeSqlString(filters.service_name),\n      ci_ref: sanitizeSqlString(filters.ci_ref),\n      problem_number: sanitizeSqlString(filters.problem_number),\n      known_error_number: sanitizeSqlString(filters.known_error_number),\n      problem_statuses: problemStatuses,\n      problem_statuses_sql: problemStatusesSql,\n      management_domains: managementDomains,\n      management_domains_sql: managementDomainsSql\n    }\n  }\n}];\n"
      }
    },
    {
      "id": "9912",
      "name": "Enrichment RAG Query (KEDB)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        3500,
        1040
      ],
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH ranked AS (\nSELECT\n  d.document_id,\n  d.content,\n  (\n    {{ $json.rag_query ? `ts_rank_cd(to_tsvector('simple', d.content), plainto_tsquery('simple', '${$json.rag_query}'))` : '0' }}\n    + {{ $json.rag_filters?.service_name ? `0.2` : '0' }}\n    + {{ $json.rag_filters?.ci_ref ? `0.2` : '0' }}\n  ) AS rag_score,\n  ke.known_error_id,\n  ke.title AS known_error_title,\n  ke.risk_level AS known_error_risk_level,\n  ke.service_name,\n  ke.ci_ref,\n  w.workaround_id,\n  w.title AS workaround_title,\n  w.automation_hint\nFROM itsm_kedb_documents d\nLEFT JOIN itsm_known_error ke ON ke.known_error_id = d.known_error_id\nLEFT JOIN itsm_workaround w ON w.workaround_id = ke.workaround_id\nWHERE d.active\n  AND (\n    {{$json.rag_query ? `to_tsvector('simple', d.content) @@ plainto_tsquery('simple', '${$json.rag_query}')` : 'false'}}\n    OR {{$json.rag_filters?.service_name ? `d.metadata->>'service_name' = '${$json.rag_filters.service_name}'` : 'false'}}\n    OR {{$json.rag_filters?.ci_ref ? `d.metadata->>'ci_ref' = '${$json.rag_filters.ci_ref}'` : 'false'}}\n  )\nORDER BY\n  rag_score DESC,\n  d.updated_at DESC\nLIMIT {{$json.rag_top_k}}\n)\nSELECT COALESCE(jsonb_agg(to_jsonb(ranked)), '[]'::jsonb) AS rag_items FROM ranked;"
      }
    },
    {
      "id": "9913",
      "name": "Enrichment RAG Query (Problem)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        3500,
        1160
      ],
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH ranked AS (\nSELECT\n  ke.known_error_id,\n  ke.known_error_number,\n  ke.title AS known_error_title,\n  ke.risk_level,\n  ke.service_name,\n  ke.ci_ref,\n  w.workaround_id,\n  w.automation_hint,\n  p.problem_id,\n  p.problem_number,\n  p.status,\n  (\n    CASE\n      WHEN {{$json.rag_filters?.problem_number ? `p.problem_number = '${$json.rag_filters.problem_number}'` : 'false'}} THEN 3\n      WHEN {{$json.rag_filters?.known_error_number ? `ke.known_error_number = '${$json.rag_filters.known_error_number}'` : 'false'}} THEN 2\n      WHEN {{$json.rag_filters?.problem_statuses_sql ? `p.status = ANY(${$json.rag_filters.problem_statuses_sql})` : 'false'}} THEN 1\n      ELSE 0\n    END\n  ) AS rag_score\nFROM itsm_known_error ke\nLEFT JOIN itsm_workaround w ON w.workaround_id = ke.workaround_id\nLEFT JOIN itsm_problem p ON p.problem_id = ke.problem_id\nWHERE ke.status = 'published'\n  AND (\n    {{$json.rag_filters?.problem_number ? `p.problem_number = '${$json.rag_filters.problem_number}'` : 'false'}}\n    OR {{$json.rag_filters?.known_error_number ? `ke.known_error_number = '${$json.rag_filters.known_error_number}'` : 'false'}}\n    OR {{$json.rag_filters?.problem_statuses_sql ? `p.status = ANY(${$json.rag_filters.problem_statuses_sql})` : 'false'}}\n  )\nORDER BY rag_score DESC, p.updated_at DESC\nLIMIT {{$json.rag_top_k}}\n)\nSELECT COALESCE(jsonb_agg(to_jsonb(ranked)), '[]'::jsonb) AS rag_items FROM ranked;"
      }
    },
    {
      "id": "9914",
      "name": "Enrichment RAG Query (GitLab Docs)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        3500,
        1280
      ],
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH ranked AS (\nSELECT\n  d.document_id,\n  d.issue_title,\n  d.source_url,\n  d.project_path,\n  d.management_domain,\n  d.content,\n  (\n    {{ $json.rag_query ? `ts_rank_cd(to_tsvector('simple', d.content), plainto_tsquery('simple', '${$json.rag_query}'))` : '0' }}\n  ) AS rag_score,\n  d.metadata\nFROM itsm_gitlab_issue_documents d\nWHERE (\n  {{$json.rag_filters?.management_domains_sql ? `d.management_domain = ANY(${$json.rag_filters.management_domains_sql})` : 'true'}}\n)\nAND (\n  {{$json.rag_query ? `to_tsvector('simple', d.content) @@ plainto_tsquery('simple', '${$json.rag_query}')` : 'true'}}\n)\nORDER BY\n  rag_score DESC,\n  d.updated_at DESC\nLIMIT {{$json.rag_top_k}}\n)\nSELECT COALESCE(jsonb_agg(to_jsonb(ranked)), '[]'::jsonb) AS rag_items FROM ranked;"
      }
    },
    {
      "id": "9915",
      "name": "Merge Enrichment RAG Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3500,
        1400
      ],
      "parameters": {
        "jsCode": "const base = $node['Enrich RAG Route (Enrichment)'].json ?? {};\nconst items = $json?.rag_items ?? [];\n\nreturn [{\n  json: {\n    ...base,\n    enrichment_rag: {\n      mode: String(base.rag_mode ?? '').trim() || null,\n      query: base.rag_query ?? null,\n      top_k: base.rag_top_k ?? null,\n      filters: base.rag_filters ?? {},\n      items\n    }\n  }\n}];\n"
      }
    },
    {
      "id": "9916",
      "name": "Fetch CMDB/Runbook (GitLab) (Enrichment)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3500,
        1520
      ],
      "parameters": {
        "jsCode": "const workflowContext = this;\nconst input = $json ?? {};\nconst iam = input.iam_context ?? {};\n\nconst realm = iam.realm\n  ?? input.reply_target?.realm\n  ?? input.reply_target?.tenant\n  ?? 'default';\n\nconst ttlSecondsRaw = $env.N8N_GITLAB_CACHE_TTL_SECONDS ?? '300';\nconst ttlSeconds = Number.parseInt(String(ttlSecondsRaw), 10);\nconst ttlMs = Number.isFinite(ttlSeconds) ? Math.max(30, ttlSeconds) * 1000 : 300000;\n\nconst hasStaticData = workflowContext && typeof workflowContext.getWorkflowStaticData === 'function';\nconst cache = hasStaticData ? workflowContext.getWorkflowStaticData('global') : {};\n\nconst baseUrl = String($env.GITLAB_API_BASE_URL || $env.GITLAB_API_BASE_URL || '').replace(/\\/$/, '');\nconst token = $env.N8N_GITLAB_TOKEN || $env.GITLAB_TOKEN || '';\nconst defaultRef = $env.N8N_GITLAB_REF || 'main';\n\nconst realmKey = String(realm || '').toUpperCase().replace(/[^A-Z0-9]+/g, '_');\nconst projectPath = $env[`N8N_GITLAB_PROJECT_PATH_${realmKey}`] || $env.N8N_GITLAB_PROJECT_PATH || '';\n\nconst cmdbPath = $env[`N8N_GITLAB_CMDB_MD_PATH_${realmKey}`] || $env.N8N_GITLAB_CMDB_MD_PATH || '';\nconst cmdbDirPath = $env[`N8N_GITLAB_CMDB_DIR_PATH_${realmKey}`] || $env.N8N_GITLAB_CMDB_DIR_PATH || '';\nconst runbookPath = $env[`N8N_GITLAB_RUNBOOK_MD_PATH_${realmKey}`] || $env.N8N_GITLAB_RUNBOOK_MD_PATH || '';\n\nconst allowExternalRunbookUrl = String($env.N8N_ALLOW_EXTERNAL_RUNBOOK_URL ?? 'false').toLowerCase() === 'true';\nconst maxRunbooksRaw = $env.N8N_CMDB_RUNBOOK_MAX ?? '3';\nconst maxRunbooks = (() => {\n  const n = Number.parseInt(String(maxRunbooksRaw), 10);\n  if (!Number.isFinite(n)) return 3;\n  return Math.max(0, Math.min(10, n));\n})();\n\nconst maxCmdbFilesRaw = $env.N8N_CMDB_MAX_FILES ?? '50';\nconst maxCmdbFiles = (() => {\n  const n = Number.parseInt(String(maxCmdbFilesRaw), 10);\n  if (!Number.isFinite(n)) return 50;\n  return Math.max(0, Math.min(200, n));\n})();\n\nfunction cleanText(value) {\n  if (value === null || value === undefined) return null;\n  const trimmed = String(value).trim();\n  if (!trimmed || trimmed.toLowerCase() === 'null') return null;\n  return trimmed;\n}\n\nfunction normalizeHeader(header) {\n  return String(header ?? '')\n    .trim()\n    .toLowerCase()\n    .replace(/[\\s\\-]+/g, '_')\n    .replace(/[^a-z0-9_\u3040-\u30ff\u4e00-\u9faf]+/g, '')\n    .replace(/^_+|_+$/g, '');\n}\n\nfunction splitRow(line) {\n  return line.trim().replace(/^\\|/, '').replace(/\\|$/, '').split('|').map((v) => v.trim());\n}\n\nfunction parseFirstTable(text, mustHaveHeaderKeys) {\n  const lines = String(text || '').split(/\\r?\\n/);\n\n  for (let i = 0; i < lines.length - 1; i += 1) {\n    const headerLine = (lines[i] ?? '').trim();\n    const sepLine = (lines[i + 1] ?? '').trim();\n    if (!headerLine.startsWith('|') || !sepLine.startsWith('|')) continue;\n    if (!/\\|\\s*:?[-]{3,}:?\\s*\\|/.test(sepLine)) continue;\n\n    const headers = splitRow(headerLine).map(normalizeHeader);\n    if (!headers.length) continue;\n\n    if (mustHaveHeaderKeys && mustHaveHeaderKeys.size) {\n      const set = new Set(headers);\n      let ok = false;\n      for (const key of mustHaveHeaderKeys) {\n        if (set.has(key)) {\n          ok = true;\n          break;\n        }\n      }\n      if (!ok) continue;\n    }\n\n    const rows = [];\n    for (let j = i + 2; j < lines.length; j += 1) {\n      const line = (lines[j] ?? '').trim();\n      if (!line.startsWith('|')) break;\n      if (line.replace(/\\s/g, '').startsWith('|---')) continue;\n      const cols = splitRow(line);\n      if (cols.length === 1 && cols[0] === '') continue;\n      rows.push(cols);\n    }\n\n    return { headers, rows };\n  }\n\n  return { headers: [], rows: [] };\n}\n\nfunction stripMarkdown(text) {\n  let out = String(text ?? '');\n  out = out.replace(/`([^`]+)`/g, '$1');\n  out = out.replace(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g, '$1 $2');\n  out = out.replace(/[*_]/g, '');\n  return out;\n}\n\nfunction matchScore(needle, haystack) {\n  const n = cleanText(needle);\n  const h = cleanText(haystack);\n  if (!n || !h) return 0;\n  const nn = stripMarkdown(n).toLowerCase();\n  const hh = stripMarkdown(h).toLowerCase();\n  if (!nn || !hh) return 0;\n  if (nn === hh) return 5;\n  if (hh.includes(nn) || nn.includes(hh)) return 3;\n  return 0;\n}\n\nfunction extractLinks(text) {\n  const raw = String(text ?? '');\n  const links = [];\n\n  const mdLinkRe = /\\[[^\\]]*\\]\\(([^)]+)\\)/g;\n  let m;\n  while ((m = mdLinkRe.exec(raw)) !== null) {\n    if (m[1]) links.push(m[1]);\n  }\n\n  const urlRe = /https?:\\/\\/[^\\s)]+/g;\n  while ((m = urlRe.exec(raw)) !== null) {\n    if (m[0]) links.push(m[0]);\n  }\n\n  const mdPathRe = /\b[\\w./-]+\\.md\b/g;\n  while ((m = mdPathRe.exec(raw)) !== null) {\n    if (m[0]) links.push(m[0]);\n  }\n\n  if (!links.length) {\n    const cleaned = cleanText(raw);\n    if (cleaned) links.push(cleaned);\n  }\n\n  const cleaned = links\n    .map((v) => String(v).trim().replace(/^</, '').replace(/>$/, '').replace(/[),.;]+$/, ''))\n    .filter(Boolean);\n\n  return [...new Set(cleaned)].slice(0, 10);\n}\n\nfunction tryParseGitLabBlobUrl(urlStr) {\n  const cleaned = cleanText(urlStr);\n  if (!cleaned || !cleaned.startsWith('http')) return null;\n\n  let u;\n  try {\n    u = new URL(cleaned);\n  } catch {\n    return null;\n  }\n\n  const apiBase = baseUrl.replace(/\\/$/, '');\n  const webBase = apiBase.replace(/\\/api\\/v4$/, '');\n\n  let web;\n  try {\n    web = new URL(webBase);\n  } catch {\n    return null;\n  }\n  if (u.origin !== web.origin) return null;\n\n  const path = decodeURIComponent(u.pathname);\n  const marker = `/${projectPath}/-/blob/`;\n  const idx = path.indexOf(marker);\n  if (idx < 0) return null;\n\n  const rest = path.slice(idx + marker.length);\n  const parts = rest.split('/').filter(Boolean);\n  if (parts.length < 2) return null;\n\n  const ref = parts[0];\n  const filePath = parts.slice(1).join('/');\n  return { ref, file_path: filePath };\n}\n\nfunction extractRunbookRefsFromCmdb(cmdbText, serviceName, ciName) {\n  const headerCandidates = {\n    service: ['service', 'service_name', 'service\u540d', '\u30b5\u30fc\u30d3\u30b9', '\u30b5\u30fc\u30d3\u30b9\u540d'],\n    ci: ['ci', 'ci_name', 'ci_ref', 'ci\u540d', '\u69cb\u6210\u30a2\u30a4\u30c6\u30e0', '\u69cb\u6210\u9805\u76ee'],\n    runbook: ['runbook', 'runbook_url', 'runbook_path', 'runbook_md_path', 'runbook_link', '\u5bfe\u5fdc\u624b\u9806', '\u624b\u9806', '\u904b\u7528\u624b\u9806']\n  };\n\n  const serviceKeys = new Set(headerCandidates.service.map(normalizeHeader));\n  const ciKeys = new Set(headerCandidates.ci.map(normalizeHeader));\n  const runbookKeys = new Set(headerCandidates.runbook.map(normalizeHeader));\n\n  const table = parseFirstTable(cmdbText, runbookKeys);\n  if (!table.headers.length) return [];\n\n  const serviceIdx = table.headers.findIndex((h) => serviceKeys.has(h));\n  const ciIdx = table.headers.findIndex((h) => ciKeys.has(h));\n  const runbookIdx = table.headers.findIndex((h) => runbookKeys.has(h));\n  if (runbookIdx < 0) return [];\n\n  const scored = [];\n  for (let i = 0; i < table.rows.length; i += 1) {\n    const row = table.rows[i];\n    const serviceCell = serviceIdx >= 0 ? row[serviceIdx] : null;\n    const ciCell = ciIdx >= 0 ? row[ciIdx] : null;\n\n    const score = matchScore(serviceName, serviceCell) + matchScore(ciName, ciCell);\n    if (score <= 0) continue;\n\n    const runbookCell = row[runbookIdx] ?? null;\n    scored.push({ score, runbook_cell: runbookCell });\n  }\n\n  scored.sort((a, b) => b.score - a.score);\n\n  const refs = [];\n  for (const hit of scored.slice(0, maxRunbooks)) {\n    const links = extractLinks(hit.runbook_cell);\n    for (const link of links) {\n      const blob = tryParseGitLabBlobUrl(link);\n      if (blob) {\n        refs.push({ kind: 'file', file_path: blob.file_path, ref: blob.ref, source: 'cmdb_table_gitlab_blob', score: hit.score });\n      } else if (link.startsWith('http')) {\n        refs.push({ kind: 'url', url: link, source: 'cmdb_table_url', score: hit.score });\n      } else {\n        refs.push({ kind: 'file', file_path: link, ref: defaultRef, source: 'cmdb_table_path', score: hit.score });\n      }\n    }\n  }\n\n  const uniq = [];\n  const seen = new Set();\n  for (const r of refs) {\n    const key = r.kind === 'file' ? `file:${r.file_path}@${r.ref}` : `url:${r.url}`;\n    if (seen.has(key)) continue;\n    seen.add(key);\n    uniq.push(r);\n  }\n\n  return uniq.slice(0, maxRunbooks);\n}\n\nfunction normalizeDirPath(p) {\n  const cleaned = cleanText(p);\n  if (!cleaned) return null;\n  return cleaned.replace(/\\/+$/, '');\n}\n\nfunction isDirPath(p) {\n  const cleaned = cleanText(p);\n  if (!cleaned) return false;\n  if (cleaned.endsWith('/')) return true;\n  const lower = cleaned.toLowerCase();\n  if (lower.endsWith('.md')) return false;\n  return !lower.includes('.');\n}\n\nfunction pickFilePathFromMeta(meta) {\n  const fp = meta?.file_path ?? null;\n  if (fp) return String(fp);\n  const key = meta?.key ?? null;\n  if (!key) return null;\n  const s = String(key);\n  return s.includes('@') ? s.split('@')[0] : s;\n}\n\nasync function fetchFile(filePath, refOverride) {\n  const file = cleanText(filePath);\n  if (!baseUrl || !projectPath || !file) return null;\n  const projectEncoded = encodeURIComponent(projectPath);\n  const fileEncoded = encodeURIComponent(file);\n  const refToUse = cleanText(refOverride) || defaultRef;\n  const url = `${baseUrl}/projects/${projectEncoded}/repository/files/${fileEncoded}/raw?ref=${encodeURIComponent(refToUse)}`;\n  const headers = token ? { 'PRIVATE-TOKEN': token } : {};\n  return await workflowContext.helpers.httpRequest({ method: 'GET', url, headers, json: false });\n}\n\nasync function listRepositoryTree(dirPath, refOverride) {\n  const dir = normalizeDirPath(dirPath);\n  if (!baseUrl || !projectPath || !dir) return [];\n  const projectEncoded = encodeURIComponent(projectPath);\n  const headers = token ? { 'PRIVATE-TOKEN': token } : {};\n  const refToUse = cleanText(refOverride) || defaultRef;\n\n  const perPage = 100;\n  const maxPages = 20;\n  const out = [];\n\n  for (let page = 1; page <= maxPages; page += 1) {\n    const url = `${baseUrl}/projects/${projectEncoded}/repository/tree?path=${encodeURIComponent(dir)}&ref=${encodeURIComponent(refToUse)}&recursive=true&per_page=${perPage}&page=${page}`;\n    const items = await workflowContext.helpers.httpRequest({ method: 'GET', url, headers, json: true });\n    if (Array.isArray(items)) out.push(...items);\n    if (!Array.isArray(items) || items.length < perPage) break;\n  }\n\n  return out;\n}\n\nasync function fetchCached(kind, key, fetcher) {\n  const cacheKey = `gitlab:${kind}:${realm}:${key}`;\n  const cached = cache?.[cacheKey] || null;\n  const fresh = cached && cached.fetched_at && (Date.now() - cached.fetched_at) < ttlMs;\n  if (fresh) return { text: cached.text ?? null, meta: { cached: true, key: key || null, ...(cached.meta || {}) } };\n\n  try {\n    const { text, meta } = await fetcher();\n    cache[cacheKey] = { fetched_at: Date.now(), text: String(text ?? ''), meta: meta || {} };\n    return { text: String(text ?? ''), meta: { cached: false, ...(meta || {}), key: key || null } };\n  } catch (error) {\n    return { text: null, meta: { cached: Boolean(cached?.text), key: key || null, ...(cached?.meta || {}), error: String(error?.message || error) } };\n  }\n}\n\nasync function fetchCmdbBundle() {\n  const dirCandidate = cleanText(cmdbDirPath) || (isDirPath(cmdbPath) ? cleanText(cmdbPath) : null);\n  const fileCandidate = dirCandidate ? null : cleanText(cmdbPath);\n\n  if (dirCandidate) {\n    const dir = normalizeDirPath(dirCandidate);\n    let treeItems = [];\n    try {\n      treeItems = await listRepositoryTree(dir, defaultRef);\n    } catch (error) {\n      treeItems = [];\n    }\n\n    const mdPaths = (Array.isArray(treeItems) ? treeItems : [])\n      .filter((it) => it && it.type === 'blob' && typeof it.path === 'string')\n      .map((it) => it.path)\n      .filter((p) => String(p).toLowerCase().endsWith('.md'))\n      .slice(0, maxCmdbFiles);\n\n    const cmdbFiles = [];\n    for (const p of mdPaths) {\n      const fetched = await fetchCached('cmdb_file', `${p}@${defaultRef}`, async () => {\n        const text = await fetchFile(p, defaultRef);\n        return { text: String(text ?? ''), meta: { file_path: p, ref: defaultRef, source: 'gitlab_tree' } };\n      });\n      cmdbFiles.push(fetched);\n    }\n\n    const cmdbAggregate = {\n      text: null,\n      meta: {\n        dir_path: dir,\n        ref: defaultRef,\n        file_count: mdPaths.length,\n        file_paths: mdPaths\n      }\n    };\n\n    return { cmdb: cmdbAggregate, cmdb_files: cmdbFiles, cmdb_dir_path: dir };\n  }\n\n  if (fileCandidate) {\n    const cmdbSingle = await fetchCached('cmdb', fileCandidate, async () => {\n      const text = await fetchFile(fileCandidate, defaultRef);\n      return { text: String(text ?? ''), meta: { file_path: fileCandidate || null, ref: defaultRef } };\n    });\n    return { cmdb: cmdbSingle, cmdb_files: [cmdbSingle], cmdb_dir_path: null };\n  }\n\n  return {\n    cmdb: { text: null, meta: { file_path: null, ref: defaultRef, missing: true } },\n    cmdb_files: [],\n    cmdb_dir_path: null\n  };\n}\n\nconst cmdbBundle = await fetchCmdbBundle();\nconst cmdb = cmdbBundle.cmdb;\nconst cmdbFiles = Array.isArray(cmdbBundle.cmdb_files) ? cmdbBundle.cmdb_files : [];\nconst cmdbDirUsed = cmdbBundle.cmdb_dir_path;\n\nconst runbookDefault = await fetchCached('runbook_default', runbookPath, async () => {\n  const text = await fetchFile(runbookPath, defaultRef);\n  return { text: String(text ?? ''), meta: { file_path: runbookPath || null, ref: defaultRef } };\n});\n\nconst serviceName = cleanText(input.normalized_event?.extracted_params?.service_name)\n  ?? cleanText(input.normalized_event?.service_name)\n  ?? cleanText(input.normalized_event?.service)\n  ?? null;\n\nconst ciName = cleanText(input.normalized_event?.extracted_params?.ci_name)\n  ?? cleanText(input.normalized_event?.ci_name)\n  ?? cleanText(input.normalized_event?.ci_ref)\n  ?? cleanText(input.normalized_event?.ci)\n  ?? null;\n\nconst runbookRefsRaw = [];\nif (serviceName || ciName) {\n  for (const f of cmdbFiles) {\n    const text = cleanText(f?.text);\n    if (!text) continue;\n    const cmdbFilePath = pickFilePathFromMeta(f?.meta);\n    const extracted = extractRunbookRefsFromCmdb(text, serviceName, ciName)\n      .map((r) => ({ ...r, cmdb_file_path: cmdbFilePath }));\n    runbookRefsRaw.push(...extracted);\n  }\n}\n\nrunbookRefsRaw.sort((a, b) => (Number(b?.score ?? 0) - Number(a?.score ?? 0)));\nconst runbookRefs = [];\n{\n  const seen = new Set();\n  for (const r of runbookRefsRaw) {\n    if (!r) continue;\n    const key = r.kind === 'file'\n      ? `file:${r.file_path}@${r.ref}`\n      : `url:${r.url}`;\n    if (seen.has(key)) continue;\n    seen.add(key);\n    runbookRefs.push(r);\n    if (runbookRefs.length >= maxRunbooks) break;\n  }\n}\n\nconst runbooksFromCmdb = [];\nfor (const r of runbookRefs) {\n  if (r.kind === 'file' && r.file_path) {\n    const fetched = await fetchCached('runbook_cmdb', `${r.file_path}@${r.ref}`, async () => {\n      const text = await fetchFile(r.file_path, r.ref);\n      return {\n        text: String(text ?? ''),\n        meta: {\n          file_path: r.file_path,\n          ref: r.ref,\n          source: r.source,\n          score: r.score,\n          cmdb_file_path: r.cmdb_file_path || null\n        }\n      };\n    });\n    runbooksFromCmdb.push(fetched);\n  } else if (r.kind === 'url' && r.url) {\n    if (!allowExternalRunbookUrl) {\n      runbooksFromCmdb.push({ text: null, meta: { url: r.url, skipped: true, reason: 'external_url_disabled', source: r.source, score: r.score, cmdb_file_path: r.cmdb_file_path || null } });\n      continue;\n    }\n\n    const fetched = await fetchCached('runbook_cmdb_url', r.url, async () => {\n      const text = await workflowContext.helpers.httpRequest({ method: 'GET', url: r.url, json: false });\n      return { text: String(text ?? ''), meta: { url: r.url, ref: null, source: r.source, score: r.score, cmdb_file_path: r.cmdb_file_path || null } };\n    });\n    runbooksFromCmdb.push(fetched);\n  }\n}\n\nconst runbookResolved = runbooksFromCmdb.find((rb) => cleanText(rb?.text)) || null;\nconst runbookSelected = runbookResolved ?? runbookDefault;\n\nreturn [{\n  json: {\n    ...input,\n    enrichment_gitlab: {\n      realm,\n      project_path: projectPath || null,\n      ref: defaultRef,\n      cmdb,\n      cmdb_files: cmdbFiles,\n      cmdb_dir_path: cmdbDirUsed,\n      runbook: runbookSelected,\n      runbook_default: runbookDefault,\n      runbooks_from_cmdb: runbooksFromCmdb,\n      runbook_resolution: {\n        service_name: serviceName,\n        ci_name: ciName,\n        derived_count: runbooksFromCmdb.length,\n        allow_external_url: allowExternalRunbookUrl\n      }\n    }\n  }\n}];\n"
      }
    },
    {
      "id": "9917",
      "name": "Build Enrichment Evidence",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3500,
        1640
      ],
      "parameters": {
        "jsCode": "const base = $json ?? {};\n\nconst plan = base.enrichment_plan ?? {};\nconst rag = base.enrichment_rag ?? {};\nconst gitlab = base.enrichment_gitlab ?? {};\n\nconst refs = [];\n\nfunction pickGitlabFilePath(meta) {\n  const fp = meta?.file_path ?? null;\n  if (fp) return String(fp);\n  const key = meta?.key ?? null;\n  if (!key) return null;\n  const s = String(key);\n  return s.includes('@') ? s.split('@')[0] : s;\n}\n\nif (Array.isArray(rag.items)) {\n  for (const item of rag.items) {\n    if (!item || typeof item !== 'object') continue;\n    const docId = item.document_id ?? item.known_error_id ?? item.problem_id ?? null;\n    refs.push({\n      target: 'rag',\n      ref: docId ? String(docId) : 'rag',\n      title: item.issue_title ?? item.known_error_title ?? item.problem_number ?? null,\n      url: item.source_url ?? null\n    });\n  }\n}\n\nconst cmdbFilePaths = [];\nconst cmdbPrimary = pickGitlabFilePath(gitlab?.cmdb?.meta);\nif (cmdbPrimary) cmdbFilePaths.push(cmdbPrimary);\nif (Array.isArray(gitlab?.cmdb_files)) {\n  for (const f of gitlab.cmdb_files) {\n    const fp = pickGitlabFilePath(f?.meta);\n    if (fp) cmdbFilePaths.push(fp);\n  }\n}\n\nfor (const fp of [...new Set(cmdbFilePaths)]) {\n  refs.push({ target: 'cmdb', ref: String(fp), title: 'GitLab CMDB', url: null });\n}\n\nconst runbookRefs = [];\nconst selectedRunbookFilePath = pickGitlabFilePath(gitlab?.runbook?.meta);\nif (selectedRunbookFilePath) {\n  runbookRefs.push({ target: 'runbook', ref: selectedRunbookFilePath, title: 'GitLab Runbook (selected)', url: null });\n} else if (gitlab?.runbook?.meta?.url) {\n  runbookRefs.push({ target: 'runbook', ref: 'runbook', title: 'Runbook (selected)', url: String(gitlab.runbook.meta.url) });\n}\n\nconst defaultRunbookFilePath = pickGitlabFilePath(gitlab?.runbook_default?.meta);\nif (defaultRunbookFilePath && (!selectedRunbookFilePath || selectedRunbookFilePath !== defaultRunbookFilePath)) {\n  runbookRefs.push({ target: 'runbook', ref: defaultRunbookFilePath, title: 'GitLab Runbook (default)', url: null });\n}\n\nif (Array.isArray(gitlab?.runbooks_from_cmdb)) {\n  for (const rb of gitlab.runbooks_from_cmdb) {\n    const fp = pickGitlabFilePath(rb?.meta);\n    const u = rb?.meta?.url || null;\n    if (fp) {\n      runbookRefs.push({ target: 'runbook', ref: String(fp), title: 'GitLab Runbook (from CMDB)', url: null });\n    } else if (u) {\n      runbookRefs.push({ target: 'runbook', ref: 'runbook', title: 'Runbook (from CMDB)', url: String(u) });\n    }\n  }\n}\n\nconst seen = new Set();\nfor (const r of runbookRefs) {\n  const key = `${r.target}:${r.ref}:${r.url ?? ''}`;\n  if (seen.has(key)) continue;\n  seen.add(key);\n  refs.push(r);\n}\n\nconst enrichmentEvidence = {\n  plan,\n  refs,\n  rag,\n  cmdb: gitlab?.cmdb ?? null,\n  cmdb_files: gitlab?.cmdb_files ?? null,\n  runbook: gitlab?.runbook ?? null,\n  gitlab\n};\n\nreturn [{\n  json: {\n    ...base,\n    enrichment_evidence: enrichmentEvidence,\n    enrichment_refs_raw: refs\n  }\n}];\n"
      }
    },
    {
      "id": "9918",
      "name": "Build Enrichment Summary Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3500,
        1760
      ],
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst base = $json ?? {};\nconst normalizedEvent = { ...(base.normalized_event ?? {}) };\ndelete normalizedEvent.raw_headers;\ndelete normalizedEvent.raw_body;\n\nconst input = {\n  normalized_event: normalizedEvent,\n  enrichment_plan: base.enrichment_plan ?? {},\n  enrichment_evidence: base.enrichment_evidence ?? {},\n  actor: base.actor ?? {},\n  reply_target: base.reply_target ?? {},\n  iam_context: base.iam_context ?? {},\n  policy_context: base.policy_context ?? {}\n};\n\nconst promptText = \"__PROMPT__ENRICHMENT_SUMMARY__\";\nconst promptHash = crypto.createHash('sha256').update(promptText).digest('hex');\n\nreturn [{\n  json: {\n    ...base,\n    prompt_key: 'adapter.enrichment_summary.v2',\n    prompt_version: 'ja-1',\n    prompt_text: promptText,\n    prompt_hash: promptHash,\n    prompt_input: JSON.stringify(input)\n  }\n}];\n"
      }
    },
    {
      "id": "9919",
      "name": "Record Prompt History (Enrichment Summary)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        3500,
        1880
      ],
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO aiops_prompt_history (prompt_key, prompt_version, prompt_text, prompt_hash, source_workflow, source_node)\nVALUES (\n  '{{ String($json.prompt_key ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_version ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_text ?? \"\").replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_hash ?? \"\").replace(/'/g, \"''\") }}',\n  'aiops-adapter-ingest',\n  'OpenAI Enrichment Summary'\n)\nON CONFLICT (prompt_key, prompt_hash) DO NOTHING;"
      }
    },
    {
      "id": "9920",
      "name": "OpenAI Enrichment Summary",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        3500,
        2000
      ],
      "parameters": {
        "resource": "chat",
        "operation": "complete",
        "model": "={{$env.OPENAI_MODEL || 'gpt-4o-mini'}}",
        "prompt": {
          "messages": [
            {
              "role": "system",
              "content": "={{ $node['Build Enrichment Summary Prompt (JP)'].json.prompt_text }}"
            },
            {
              "role": "user",
              "content": "={{ '入力:\\n' + $node['Build Enrichment Summary Prompt (JP)'].json.prompt_input }}"
            }
          ]
        },
        "options": {
          "temperature": 0.2,
          "baseURL": "={{$env.OPENAI_BASE_URL}}",
          "maxTokens": "={{$json.policy_context?.limits?.llm_output_tokens || 1200}}"
        }
      },
      "credentials": {
        "openAiApi": {
          "name": "aiops-openai"
        }
      },
      "disabled": true
    },
    {
      "id": "9921",
      "name": "Parse Enrichment Summary Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3500,
        2120
      ],
      "parameters": {
        "jsCode": "const base = $node['Build Enrichment Summary Prompt (JP)'].json ?? {};\nconst response = $json ?? {};\n\nconst extractContent = (payload) => {\n  return payload?.message?.content\n    ?? payload?.choices?.[0]?.message?.content\n    ?? payload?.choices?.[0]?.text\n    ?? payload?.data?.choices?.[0]?.message?.content\n    ?? payload?.data?.choices?.[0]?.text\n    ?? payload?.content\n    ?? '';\n};\n\nconst rawContent = extractContent(response);\nlet parsed = null;\nif (typeof rawContent === 'string') {\n  try {\n    parsed = JSON.parse(rawContent);\n  } catch (error) {\n    const match = rawContent.match(/\\{[\\s\\S]*\\}/);\n    if (match) {\n      try {\n        parsed = JSON.parse(match[0]);\n      } catch (inner) {\n        parsed = null;\n      }\n    }\n  }\n} else if (rawContent && typeof rawContent === 'object') {\n  parsed = rawContent;\n}\n\nconst summary = parsed?.enrichment_summary;\nconst refs = Array.isArray(parsed?.enrichment_refs) ? parsed.enrichment_refs : (base.enrichment_refs_raw ?? []);\n\nreturn [{\n  json: {\n    ...base,\n    enrichment_summary: typeof summary === 'string' ? summary : null,\n    enrichment_refs: refs,\n    enrichment_summary_llm_ok: typeof summary === 'string',\n    enrichment_summary_confidence: typeof parsed?.confidence === 'number' ? parsed.confidence : null,\n    enrichment_summary_rationale: parsed?.rationale ?? null\n  }\n}];\n"
      }
    },
    {
      "id": "9922",
      "name": "Update Enrichment Results (Context Store)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        3500,
        2240
      ],
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE aiops_context\nSET normalized_event = normalized_event\n  || jsonb_build_object(\n    'enrichment_plan', COALESCE(NULLIF('{{ JSON.stringify($json.enrichment_plan || {}).replace(/'/g, \"''\") }}','undefined')::jsonb, '{}'::jsonb),\n    'enrichment_summary', NULLIF(NULLIF('{{ String($json.enrichment_summary || '').replace(/'/g, \"''\") }}','undefined'), ''),\n    'enrichment_refs', COALESCE(NULLIF('{{ JSON.stringify($json.enrichment_refs || []).replace(/'/g, \"''\") }}','undefined')::jsonb, '[]'::jsonb),\n    'enrichment_details', COALESCE(NULLIF('{{ JSON.stringify($json.enrichment_evidence || {}).replace(/'/g, \"''\") }}','undefined')::jsonb, '{}'::jsonb)\n  )\nWHERE context_id = NULLIF(NULLIF('{{ $json.context_id }}',''), 'undefined')::uuid;\n\nSELECT 1 AS ok;"
      }
    },
    {
      "id": "9923",
      "name": "IF RAG Mode = Problem (Enrichment)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        3780,
        920
      ],
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.rag_mode}}",
              "operation": "equals",
              "value2": "problem_management"
            }
          ]
        }
      }
    },
    {
      "id": "9924",
      "name": "IF RAG Mode = GitLab Docs (Enrichment)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        4020,
        1060
      ],
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.rag_mode}}",
              "operation": "equals",
              "value2": "gitlab_management_docs"
            }
          ]
        }
      }
    },
    {
      "id": "9925",
      "name": "Restore Payload After Enrichment Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3760,
        2240
      ],
      "parameters": {
        "jsCode": "const base = $node['Parse Enrichment Summary Response'].json ?? {};\nconst update = $json ?? {};\n\nreturn [{\n  json: {\n    ...base,\n    enrichment_update_ok: update.ok ?? null\n  }\n}];\n"
      }
    },
    {
      "id": "pii-redaction-ingest",
      "name": "PII Redaction (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1180,
        260
      ],
      "parameters": {
        "jsCode": "function redactSecretsInText(raw) {\n  const text = String(raw ?? '');\n  if (!text) return { redacted: text, findings: [] };\n  const rules = [\n    { name: 'slack_token', re: /\\bxox[baprs]-[A-Za-z0-9-]{10,}\\b/g },\n    { name: 'gitlab_pat', re: /\\bglpat-[A-Za-z0-9_-]{10,}\\b/g },\n    { name: 'github_pat', re: /\\bghp_[A-Za-z0-9]{20,}\\b/g },\n    { name: 'aws_access_key_id', re: /\\bAKIA[0-9A-Z]{16}\\b/g },\n    { name: 'jwt', re: /\\beyJ[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\.[a-zA-Z0-9_-]{10,}\\b/g },\n    { name: 'bearer_token', re: /\\bBearer\\s+[A-Za-z0-9._-]{20,}\\b/gi, replace: () => 'Bearer (masked)' },\n    { name: 'token_query_param', re: /([?&](?:token|access_token|id_token|refresh_token|api_key|apikey|secret|password)=)([^&\\s]+)/gi, replace: (m, p1) => `${p1}(masked)` }\n  ];\n\n  let out = text;\n  const findings = [];\n  for (const rule of rules) {\n    const before = out;\n    out = out.replace(rule.re, rule.replace ? rule.replace : '(masked)');\n    if (before !== out) {\n      const count = (before.match(rule.re) ?? []).length;\n      findings.push({ rule: rule.name, count });\n    }\n  }\n  return { redacted: out, findings };\n}\n\nfunction scrub(value, depth = 0) {\n  if (depth > 6) return '[max-depth]';\n  if (value === null || value === undefined) return value;\n  if (typeof value === 'string') return redactSecretsInText(value).redacted;\n  if (Array.isArray(value)) return value.map((v) => scrub(v, depth + 1));\n  if (typeof value === 'object') {\n    const result = {};\n    for (const [k, v] of Object.entries(value)) {\n      const keyLower = String(k).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[k] = '***';\n      } else {\n        result[k] = scrub(v, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nfunction sanitizeHeaders(rawHeaders) {\n  const headers = (rawHeaders && typeof rawHeaders === 'object') ? rawHeaders : {};\n  const allow = new Set([\n    'x-aiops-trace-id',\n    'x-aiops-realm',\n    'x-aiops-tenant',\n    'x-aiops-groups',\n    'x-aiops-roles',\n    'x-aiops-approval-policy',\n    'x-forwarded-for',\n    'x-forwarded-proto',\n    'x-forwarded-host',\n    'x-forwarded-uri',\n    'x-original-uri'\n  ]);\n\n  const out = {};\n  for (const [k, v] of Object.entries(headers)) {\n    const keyLower = String(k).toLowerCase();\n    if (allow.has(keyLower)) {\n      out[keyLower] = scrub(v);\n    }\n  }\n  return out;\n}\n\nfunction sanitizeRawBody(source, rawBody, eventId) {\n  const body = (rawBody && typeof rawBody === 'object') ? rawBody : null;\n  if (!body) return null;\n\n  if (source === 'zulip') {\n    const msg = body.message ?? {};\n    return {\n      token_present: Boolean(body.token),\n      message: {\n        id: msg.id ?? eventId ?? null,\n        type: msg.type ?? null,\n        stream_id: msg.stream_id ?? null,\n        subject: msg.subject ?? null,\n        sender_id: msg.sender_id ?? null,\n        sender_email: msg.sender_email ?? null\n      }\n    };\n  }\n\n  return scrub(body);\n}\n\nconst base = $json ?? {};\nconst normalized = { ...(base.normalized_event ?? {}) };\nconst source = String(normalized.source ?? base.source ?? base.reply_target?.source ?? 'unknown');\n\nlet rawTextForDetection = normalized.original_text ?? normalized.text ?? '';\nif ((normalized.original_text === undefined || normalized.original_text === null || String(normalized.original_text).trim() === '') && source === 'zulip') {\n  const rawBody = (normalized.raw_body && typeof normalized.raw_body === 'object') ? normalized.raw_body : null;\n  const content = rawBody?.message?.content ?? null;\n  if (typeof content === 'string' && content.trim()) rawTextForDetection = content;\n}\nconst detection = redactSecretsInText(rawTextForDetection);\n\nconst redaction = redactSecretsInText(normalized.text ?? '');\nif (normalized.original_text !== undefined && normalized.original_text !== null) {\n  normalized.original_text = redactSecretsInText(normalized.original_text).redacted;\n}\n\nnormalized.text = redaction.redacted;\nnormalized.pii_redaction = {\n  ingest: true,\n  pre_llm: true,\n  detected: detection.findings.length > 0,\n  findings: detection.findings,\n  redacted_at: new Date().toISOString()\n};\n\nnormalized.raw_headers = sanitizeHeaders(normalized.raw_headers ?? base.headers ?? null);\nnormalized.raw_body = sanitizeRawBody(source, normalized.raw_body ?? null, normalized.event_id ?? null);\n\nreturn [{\n  json: {\n    ...base,\n    normalized_event: normalized\n  }\n}];\n"
      }
    },
    {
      "id": "if-secret-detected-ingest",
      "name": "IF Secret Detected (Ingest)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1720,
        320
      ],
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.secret_detected_flag === 'true' }}",
              "value2": true,
              "operation": "equal"
            }
          ]
        }
      }
    },
    {
      "id": "compute-secret-detected-flag",
      "name": "Compute Secret Detected Flag",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1520,
        320
      ],
      "parameters": {
        "jsCode": "const base = $json ?? {};\nconst normalized = base.normalized_event ?? {};\nconst pii = normalized.pii_redaction ?? {};\nconst detected = pii?.detected === true;\n\nreturn [{\n  json: {\n    ...base,\n    secret_detected_flag: detected ? 'true' : ''\n  }\n}];\n"
      }
    },
    {
      "id": "build-secret-warning-ingest",
      "name": "Build Secret Warning Message (Ingest)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1940,
        220
      ],
      "parameters": {
        "jsCode": "const base = $json ?? {};\n\nconst content = [\n  '機密情報（キー/パスワード/トークン等）が含まれている可能性があるため、そのまま扱えません。',\n  '',\n  'お願い：',\n  '1) その投稿を削除/編集できる場合は削除してください（必要なら管理者にも連絡）。',\n  '2) 送ってしまったキー/トークンは失効・ローテーションしてください。',\n  '3) 以後は値を伏せて共有してください（例: 先頭/末尾だけ残して他は伏字）。もしくは SSM/Secrets Manager 等に登録し、参照名だけ送ってください。',\n  '',\n  '差し支えない範囲で、どの種類の秘密（AWS/Slack/GitLab/tfvars など）か教えてください。対応手順を案内します。'\n].join('\\n');\n\nreturn [{\n  json: {\n    ...base,\n    next_action: 'ask_clarification',\n    required_confirm: true,\n    content\n  }\n}];\n"
      }
    }
  ],
  "connections": {
    "Webhook (Slack Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Webhook (Slack Ingest) -> Validate Slack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Slack": {
      "main": [
        [
          {
            "node": "Debug Log After: Validate Slack -> IF Slack Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Slack Valid": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Slack Valid -> Respond 200",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Slack Valid -> Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook (Zulip Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Webhook (Zulip Ingest) -> Debug Log (Zulip Payload)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log (Zulip Payload)": {
      "main": [
        [
          {
            "node": "Debug Log After: Debug Log (Zulip Payload) -> Validate Zulip",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Sulu Monitoring Enabled": {
      "main": [
        [
          {
            "node": "Post to Sulu Monitoring",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Build Sulu Monitoring Payload (After: OpenAI Classify Event)": {
      "main": [
        [
          {
            "node": "IF Sulu Monitoring Enabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Sulu Monitoring Payload (After: OpenAI Context Summary)": {
      "main": [
        [
          {
            "node": "IF Sulu Monitoring Enabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Sulu Monitoring Payload (After: OpenAI Routing Decide)": {
      "main": [
        [
          {
            "node": "IF Sulu Monitoring Enabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Sulu Monitoring Payload (After: OpenAI Chat Core)": {
      "main": [
        [
          {
            "node": "IF Sulu Monitoring Enabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Sulu Monitoring Payload (After: OpenAI Initial Reply)": {
      "main": [
        [
          {
            "node": "IF Sulu Monitoring Enabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Sulu Monitoring Payload (After: OpenAI Feedback Decide (Ingest))": {
      "main": [
        [
          {
            "node": "IF Sulu Monitoring Enabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Sulu Monitoring Payload (After: OpenAI Enrichment Plan)": {
      "main": [
        [
          {
            "node": "IF Sulu Monitoring Enabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Sulu Monitoring Payload (After: OpenAI Enrichment Summary)": {
      "main": [
        [
          {
            "node": "IF Sulu Monitoring Enabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Zulip": {
      "main": [
        [
          {
            "node": "Debug Log After: Validate Zulip -> IF Zulip Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Zulip Valid": {
      "main": [
        [
          {
            "node": "Guard Valid (Ingest)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Zulip Valid -> Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook (Mattermost Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Webhook (Mattermost Ingest) -> Validate Mattermost",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Mattermost": {
      "main": [
        [
          {
            "node": "Debug Log After: Validate Mattermost -> IF Mattermost Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Mattermost Valid": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Mattermost Valid -> Respond 200",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Mattermost Valid -> Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook (Teams Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Webhook (Teams Ingest) -> Validate Teams",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Teams": {
      "main": [
        [
          {
            "node": "Debug Log After: Validate Teams -> IF Teams Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Teams Valid": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Teams Valid -> Respond 200",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Teams Valid -> Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook (CloudWatch Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Webhook (CloudWatch Ingest) -> Validate CloudWatch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate CloudWatch": {
      "main": [
        [
          {
            "node": "Debug Log After: Validate CloudWatch -> IF CloudWatch Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF CloudWatch Valid": {
      "main": [
        [
          {
            "node": "Debug Log After: IF CloudWatch Valid -> Respond 200",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF CloudWatch Valid -> Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond 200": {
      "main": [
        [
          {
            "node": "Debug Log After: Respond 200 -> Guard Valid (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Context Store (Insert)": {
      "main": [
        [
          {
            "node": "Debug Log After: Context Store (Insert) -> Normalize Duplicate Flag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Duplicate Flag": {
      "main": [
        [
          {
            "node": "Debug Log After: Normalize Duplicate Flag -> Build IAM & Policy Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build IAM & Policy Context": {
      "main": [
        [
          {
            "node": "Debug Log After: Build IAM & Policy Context -> IF Duplicate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Duplicate": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Duplicate -> Build Chat Core Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Duplicate -> Build Chat Core Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Orchestrator Preview": {
      "main": [
        [
          {
            "node": "Debug Log After: Call Orchestrator Preview -> Merge Preview with Chat Core",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Required Confirm": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Required Confirm -> Enqueue Job",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Required Confirm -> Build Approval Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enqueue Job": {
      "main": [
        [
          {
            "node": "Debug Log After: Enqueue Job -> Context Store (job_id)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Classify Event (Basic)": {
      "main": [
        [
          {
            "node": "Debug Log After: Classify Event (Basic) -> Update Normalized Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Normalized Event": {
      "main": [
        [
          {
            "node": "Debug Log After: Update Normalized Event -> Load Escalation Matrix (GitLab)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Context Store (job_id)": {
      "main": [
        [
          {
            "node": "Debug Log After: Context Store (job_id) -> Build Auto-Enqueue Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Approval Message": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Approval Message -> Use Chat Core Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Auto-Enqueue Message": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Auto-Enqueue Message -> Use Chat Core Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Zulip Source (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Zulip Source (Ingest) -> Post to Zulip (Ingest)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Zulip Source (Ingest) -> IF Slack Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Slack Source (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Slack Source (Ingest) -> Post to Slack (Ingest)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Slack Source (Ingest) -> IF Mattermost Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Mattermost Source (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Mattermost Source (Ingest) -> Post to Mattermost (Ingest)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Mattermost Source (Ingest) -> IF Teams Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Teams Source (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Teams Source (Ingest) -> Post to Teams (Ingest)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Teams Source (Ingest) -> Log Unknown Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Record Prompt History (Classify)": {
      "main": [
        [
          {
            "node": "Debug Log After: Record Prompt History (Classify) -> OpenAI Classify Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Classify Event": {
      "main": [
        [
          {
            "node": "Debug Log After: OpenAI Classify Event -> Parse Classification Response",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Sulu Monitoring Payload (After: OpenAI Classify Event)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Classification Response": {
      "main": [
        [
          {
            "node": "Debug Log After: Parse Classification Response -> IF LLM Classified",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF LLM Classified": {
      "main": [
        [
          {
            "node": "Debug Log After: IF LLM Classified -> Update Normalized Event",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF LLM Classified -> Classify Event (Basic)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Prompt Override (Classify)": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Prompt Override (Classify) -> Load Prompt History (Classify)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Prompt Override (Classify) -> Record Prompt History (Classify)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Prompt History (Classify)": {
      "main": [
        [
          {
            "node": "Debug Log After: Load Prompt History (Classify) -> Apply Stored Prompt (Classify)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply Stored Prompt (Classify)": {
      "main": [
        [
          {
            "node": "Debug Log After: Apply Stored Prompt (Classify) -> OpenAI Classify Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Summary Prompt (JP)": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Summary Prompt (JP) -> Record Prompt History (Summary)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Record Prompt History (Summary)": {
      "main": [
        [
          {
            "node": "Debug Log After: Record Prompt History (Summary) -> OpenAI Context Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Context Summary": {
      "main": [
        [
          {
            "node": "Debug Log After: OpenAI Context Summary -> Parse Summary Response",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Sulu Monitoring Payload (After: OpenAI Context Summary)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Summary Response": {
      "main": [
        [
          {
            "node": "Debug Log After: Parse Summary Response -> IF Summary OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Summary OK": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Summary OK -> Update Enrichment Summary",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Summary OK -> Call Orchestrator Preview",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Enrichment Summary": {
      "main": [
        [
          {
            "node": "Debug Log After: Update Enrichment Summary -> Call Orchestrator Preview",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Intent Approval": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Intent Approval -> Parse Approval Token (Ingest)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Guard Non-Approval Intent (Ingest)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Intent Approval -> IF Intent Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Approval Token (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Parse Approval Token (Ingest) -> IF Approval Token Valid (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Approval Token Valid (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Approval Token Valid (Ingest) -> Load Pending Approval (Ingest)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Approval Token Valid (Ingest) -> Build Approval Error Message (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Pending Approval (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Load Pending Approval (Ingest) -> Validate Pending Approval (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Pending Approval (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Validate Pending Approval (Ingest) -> IF Pending Approval Valid (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Pending Approval Valid (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Pending Approval Valid (Ingest) -> IF Decision Deny (Ingest)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Pending Approval Valid (Ingest) -> Build Approval Error Message (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Decision Deny (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Decision Deny (Ingest) -> Mark Approval Denied (Ingest)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Decision Deny (Ingest) -> Enqueue Job (Approval Confirm Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Approval Denied (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Mark Approval Denied (Ingest) -> Record Approval Denied (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Record Approval Denied (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Record Approval Denied (Ingest) -> Load Context (Approval Ack Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enqueue Job (Approval Confirm Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Enqueue Job (Approval Confirm Ingest) -> Context Store (job_id) (Approval Confirm Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Context Store (job_id) (Approval Confirm Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Context Store (job_id) (Approval Confirm Ingest) -> Record Approval Approved (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Record Approval Approved (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Record Approval Approved (Ingest) -> Load Context (Approval Ack Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Context (Approval Ack Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Load Context (Approval Ack Ingest) -> Build Approval Ack (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Approval Ack (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Approval Ack (Ingest) -> IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Approval Error Message (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Approval Error Message (Ingest) -> IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Intent Feedback": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Intent Feedback -> IF Feedback Type Preview (Ingest)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Intent Feedback -> IF Event Kind Other",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Feedback Type Preview (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Feedback Type Preview (Ingest) -> Parse Preview Feedback (Ingest)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Feedback Type Preview (Ingest) -> Parse Feedback (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Preview Feedback (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Parse Preview Feedback (Ingest) -> Store Preview Feedback (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Preview Feedback (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Store Preview Feedback (Ingest) -> Build Feedback Ack (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Feedback (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Parse Feedback (Ingest) -> Load Feedback Context (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Feedback Context (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Load Feedback Context (Ingest) -> Build Feedback Decision Prompt (JP) (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Feedback Decision Prompt (JP) (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Feedback Decision Prompt (JP) (Ingest) -> Record Prompt History (Feedback Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Record Prompt History (Feedback Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Record Prompt History (Feedback Ingest) -> OpenAI Feedback Decide (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Feedback Decide (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: OpenAI Feedback Decide (Ingest) -> Parse Feedback Decision Response (Ingest)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Sulu Monitoring Payload (After: OpenAI Feedback Decide (Ingest))",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Feedback Decision Response (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Parse Feedback Decision Response (Ingest) -> Store Feedback (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Feedback (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Store Feedback (Ingest) -> Build Feedback Ack (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Feedback Ack (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Feedback Ack (Ingest) -> IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Event Kind Other": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Event Kind Other -> Update Normalized Event (Other)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Event Kind Other -> Update Normalized Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Needs Clarification (Other)": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Needs Clarification (Other) -> Build Clarification Message (Other)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Needs Clarification (Other) -> Build Friendly Reply (Other)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Clarification Message (Other)": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Clarification Message (Other) -> IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Normalized Event (Other)": {
      "main": [
        [
          {
            "node": "Restore Context (Other)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Context (Other)": {
      "main": [
        [
          {
            "node": "Debug Log After: Update Normalized Event (Other) -> IF Needs Clarification (Other)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Friendly Reply (Other)": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Friendly Reply (Other) -> IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Routing Prompt (JP)": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Routing Prompt (JP) -> Record Prompt History (Routing)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Record Prompt History (Routing)": {
      "main": [
        [
          {
            "node": "Debug Log After: Record Prompt History (Routing) -> OpenAI Routing Decide",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Routing Decide": {
      "main": [
        [
          {
            "node": "Debug Log After: OpenAI Routing Decide -> Parse Routing Decide Response",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Sulu Monitoring Payload (After: OpenAI Routing Decide)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Routing Decide Response": {
      "main": [
        [
          {
            "node": "Debug Log After: Parse Routing Decide Response -> IF Routing Decide OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Routing Decide OK": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Routing Decide OK -> Apply Selected Routing",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Routing Decide OK -> Apply Escalation Routing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply Selected Routing": {
      "main": [
        [
          {
            "node": "Debug Log After: Apply Selected Routing -> Update Routing Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply Escalation Routing": {
      "main": [
        [
          {
            "node": "Debug Log After: Apply Escalation Routing -> Update Routing Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Routing Context": {
      "main": [
        [
          {
            "node": "Debug Log After: Update Routing Context -> Build Summary Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Initial Reply Prompt (JP)": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Initial Reply Prompt (JP) -> Record Prompt History (Initial Reply)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Record Prompt History (Initial Reply)": {
      "main": [
        [
          {
            "node": "Debug Log After: Record Prompt History (Initial Reply) -> OpenAI Initial Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Initial Reply": {
      "main": [
        [
          {
            "node": "Debug Log After: OpenAI Initial Reply -> Use Chat Core Reply",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Sulu Monitoring Payload (After: OpenAI Initial Reply)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Chat Core Prompt (JP)": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Chat Core Prompt (JP) -> Record Prompt History (Chat Core)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Record Prompt History (Chat Core)": {
      "main": [
        [
          {
            "node": "Debug Log After: Record Prompt History (Chat Core) -> OpenAI Chat Core",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Core": {
      "main": [
        [
          {
            "node": "Debug Log After: OpenAI Chat Core -> AIOPS Observer (Chat Core)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Sulu Monitoring Payload (After: OpenAI Chat Core)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AIOPS Observer (Chat Core)": {
      "main": [
        [
          {
            "node": "Debug Log After: AIOPS Observer (Chat Core) -> Parse Chat Core Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Chat Core Response": {
      "main": [
        [
          {
            "node": "Build Enrichment Plan Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Force CloudWatch Request": {
      "main": [
        [
          {
            "node": "IF CloudWatch Source (After Parse)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF CloudWatch Source (After Parse)": {
      "main": [
        [
          {
            "node": "Call Orchestrator Preview",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: Parse Chat Core Response -> IF Intent Approval",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Chat Core Reply": {
      "main": [
        [
          {
            "node": "Debug Log After: Use Chat Core Reply -> IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Preview with Chat Core": {
      "main": [
        [
          {
            "node": "Debug Log After: Merge Preview with Chat Core -> IF Required Confirm",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Escalation Matrix (GitLab)": {
      "main": [
        [
          {
            "node": "Debug Log After: Load Escalation Matrix (GitLab) -> Load Escalation Context Age",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Escalation Context Age": {
      "main": [
        [
          {
            "node": "Debug Log After: Load Escalation Context Age -> Attach Escalation Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Attach Escalation Context": {
      "main": [
        [
          {
            "node": "Debug Log After: Attach Escalation Context -> Build Routing Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verify Keycloak Membership (Zulip)": {
      "main": [
        [
          {
            "node": "Debug Log After: Verify Keycloak Membership (Zulip) -> IF Keycloak Membership OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Keycloak Membership OK": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Keycloak Membership OK -> Context Store (Insert)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Keycloak Membership OK -> Build Keycloak Reject Message (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Keycloak Reject Message (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Keycloak Reject Message (Ingest) -> IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Guard Valid (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log After: Guard Valid (Ingest) -> Verify Keycloak Membership (Zulip)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Webhook (Slack Ingest) -> Validate Slack": {
      "main": [
        [
          {
            "node": "Debug Log Before: Validate Slack <- Webhook (Slack Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Validate Slack <- Webhook (Slack Ingest)": {
      "main": [
        [
          {
            "node": "Validate Slack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Validate Slack -> IF Slack Valid": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Slack Valid <- Validate Slack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Slack Valid <- Validate Slack": {
      "main": [
        [
          {
            "node": "IF Slack Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Slack Valid -> Respond 200": {
      "main": [
        [
          {
            "node": "Debug Log Before: Respond 200 <- IF Slack Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Respond 200 <- IF Slack Valid": {
      "main": [
        [
          {
            "node": "Respond 200",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Slack Valid -> Respond Error": {
      "main": [
        [
          {
            "node": "Debug Log Before: Respond Error <- IF Slack Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Respond Error <- IF Slack Valid": {
      "main": [
        [
          {
            "node": "Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Webhook (Zulip Ingest) -> Debug Log (Zulip Payload)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Debug Log (Zulip Payload) <- Webhook (Zulip Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Debug Log (Zulip Payload) <- Webhook (Zulip Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log (Zulip Payload)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Debug Log (Zulip Payload) -> Validate Zulip": {
      "main": [
        [
          {
            "node": "Debug Log Before: Validate Zulip <- Debug Log (Zulip Payload)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Validate Zulip <- Debug Log (Zulip Payload)": {
      "main": [
        [
          {
            "node": "Validate Zulip",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Debug Log (Zulip Payload) -> IF Sulu Monitoring Enabled": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Sulu Monitoring Enabled <- Debug Log (Zulip Payload)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Sulu Monitoring Enabled <- Debug Log (Zulip Payload)": {
      "main": [
        [
          {
            "node": "IF Sulu Monitoring Enabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Sulu Monitoring Enabled -> Build Sulu Monitoring Payload (Zulip)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Sulu Monitoring Payload (Zulip) <- IF Sulu Monitoring Enabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Sulu Monitoring Payload (Zulip) <- IF Sulu Monitoring Enabled": {
      "main": [
        [
          {
            "node": "Post to Sulu Monitoring",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Sulu Monitoring Payload (Zulip) -> Post to Sulu Monitoring": {
      "main": [
        [
          {
            "node": "Debug Log Before: Post to Sulu Monitoring <- Build Sulu Monitoring Payload (Zulip)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Post to Sulu Monitoring <- Build Sulu Monitoring Payload (Zulip)": {
      "main": [
        [
          {
            "node": "Post to Sulu Monitoring",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Validate Zulip -> IF Zulip Valid": {
      "main": [
        [
          {
            "node": "Respond Ack (Zulip Webhook)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond Ack (Zulip Webhook)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Zulip Valid <- Validate Zulip",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Zulip Valid <- Validate Zulip": {
      "main": [
        [
          {
            "node": "IF Zulip Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Zulip Valid -> Respond 200": {
      "main": [
        [
          {
            "node": "Debug Log Before: Respond 200 <- IF Zulip Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Respond 200 <- IF Zulip Valid": {
      "main": [
        [
          {
            "node": "Context Store (Insert)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Zulip Valid -> Respond Error": {
      "main": [
        [
          {
            "node": "Debug Log Before: Respond Error <- IF Zulip Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Respond Error <- IF Zulip Valid": {
      "main": [
        [
          {
            "node": "Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Webhook (Mattermost Ingest) -> Validate Mattermost": {
      "main": [
        [
          {
            "node": "Debug Log Before: Validate Mattermost <- Webhook (Mattermost Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Validate Mattermost <- Webhook (Mattermost Ingest)": {
      "main": [
        [
          {
            "node": "Validate Mattermost",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Validate Mattermost -> IF Mattermost Valid": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Mattermost Valid <- Validate Mattermost",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Mattermost Valid <- Validate Mattermost": {
      "main": [
        [
          {
            "node": "IF Mattermost Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Mattermost Valid -> Respond 200": {
      "main": [
        [
          {
            "node": "Debug Log Before: Respond 200 <- IF Mattermost Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Respond 200 <- IF Mattermost Valid": {
      "main": [
        [
          {
            "node": "Respond 200",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Mattermost Valid -> Respond Error": {
      "main": [
        [
          {
            "node": "Debug Log Before: Respond Error <- IF Mattermost Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Respond Error <- IF Mattermost Valid": {
      "main": [
        [
          {
            "node": "Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Webhook (Teams Ingest) -> Validate Teams": {
      "main": [
        [
          {
            "node": "Debug Log Before: Validate Teams <- Webhook (Teams Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Validate Teams <- Webhook (Teams Ingest)": {
      "main": [
        [
          {
            "node": "Validate Teams",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Validate Teams -> IF Teams Valid": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Teams Valid <- Validate Teams",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Teams Valid <- Validate Teams": {
      "main": [
        [
          {
            "node": "IF Teams Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Teams Valid -> Respond 200": {
      "main": [
        [
          {
            "node": "Debug Log Before: Respond 200 <- IF Teams Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Respond 200 <- IF Teams Valid": {
      "main": [
        [
          {
            "node": "Respond 200",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Teams Valid -> Respond Error": {
      "main": [
        [
          {
            "node": "Debug Log Before: Respond Error <- IF Teams Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Respond Error <- IF Teams Valid": {
      "main": [
        [
          {
            "node": "Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Webhook (CloudWatch Ingest) -> Validate CloudWatch": {
      "main": [
        [
          {
            "node": "Debug Log Before: Validate CloudWatch <- Webhook (CloudWatch Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Validate CloudWatch <- Webhook (CloudWatch Ingest)": {
      "main": [
        [
          {
            "node": "Validate CloudWatch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Validate CloudWatch -> IF CloudWatch Valid": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF CloudWatch Valid <- Validate CloudWatch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF CloudWatch Valid <- Validate CloudWatch": {
      "main": [
        [
          {
            "node": "IF CloudWatch Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF CloudWatch Valid -> Respond 200": {
      "main": [
        [
          {
            "node": "Debug Log Before: Respond 200 <- IF CloudWatch Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Respond 200 <- IF CloudWatch Valid": {
      "main": [
        [
          {
            "node": "Respond 200",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF CloudWatch Valid -> Respond Error": {
      "main": [
        [
          {
            "node": "Debug Log Before: Respond Error <- IF CloudWatch Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Respond Error <- IF CloudWatch Valid": {
      "main": [
        [
          {
            "node": "Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Respond 200 -> Guard Valid (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Guard Valid (Ingest) <- Respond 200",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Guard Valid (Ingest) <- Respond 200": {
      "main": [
        [
          {
            "node": "Restore Items After Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Items After Respond": {
      "main": [
        [
          {
            "node": "Guard Valid (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Context Store (Insert) -> Normalize Duplicate Flag": {
      "main": [
        [
          {
            "node": "Debug Log Before: Normalize Duplicate Flag <- Context Store (Insert)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Normalize Duplicate Flag <- Context Store (Insert)": {
      "main": [
        [
          {
            "node": "Maybe Fetch Zulip Topic Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Maybe Fetch Zulip Topic Context": {
      "main": [
        [
          {
            "node": "Strip HTML (Zulip Topic Context)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Strip HTML (Zulip Topic Context)": {
      "main": [
        [
          {
            "node": "Load Zulip Topic Context (DB)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Zulip Topic Context (DB)": {
      "main": [
        [
          {
            "node": "Attach Zulip Topic Context (DB Fallback)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Attach Zulip Topic Context (DB Fallback)": {
      "main": [
        [
          {
            "node": "Sanitize Zulip Topic Context Text (DB Fallback)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sanitize Zulip Topic Context Text (DB Fallback)": {
      "main": [
        [
          {
            "node": "Persist Topic Context (Zulip)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Persist Topic Context (Zulip)": {
      "main": [
        [
          {
            "node": "Pass Through After Topic Context Persist",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pass Through After Topic Context Persist": {
      "main": [
        [
          {
            "node": "Normalize Duplicate Flag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Normalize Duplicate Flag -> Build IAM & Policy Context": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build IAM & Policy Context <- Normalize Duplicate Flag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build IAM & Policy Context <- Normalize Duplicate Flag": {
      "main": [
        [
          {
            "node": "Build IAM & Policy Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build IAM & Policy Context -> IF Duplicate": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Duplicate <- Build IAM & Policy Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Duplicate <- Build IAM & Policy Context": {
      "main": [
        [
          {
            "node": "Compute Secret Detected Flag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute Secret Detected Flag": {
      "main": [
        [
          {
            "node": "IF Secret Detected (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Secret Detected (Ingest)": {
      "main": [
        [
          {
            "node": "IF Duplicate",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Secret Warning Message (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Secret Warning Message (Ingest)": {
      "main": [
        [
          {
            "node": "IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Duplicate -> Build Chat Core Prompt (JP)": {
      "main": [
        [
          {
            "node": "IF CloudWatch Source (Direct Preview)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF CloudWatch Source (Direct Preview)": {
      "main": [
        [
          {
            "node": "Call Orchestrator Preview",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log Before: Build Chat Core Prompt (JP) <- IF Duplicate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Chat Core Prompt (JP) <- IF Duplicate": {
      "main": [
        [
          {
            "node": "IF Zulip Response Mode (Fast)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Zulip Response Mode (Fast)": {
      "main": [
        [
          {
            "node": "Fast Zulip Response (Build)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "IF Defer Slow Response (Zulip)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Defer Slow Response (Zulip)": {
      "main": [
        [
          {
            "node": "Respond Deferred (Zulip)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Chat Core Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond Deferred (Zulip)": {
      "main": [
        [
          {
            "node": "Build Chat Core Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fast Zulip Response (Build)": {
      "main": [
        [
          {
            "node": "IF Save Pending Approval (Zulip)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Save Pending Approval (Zulip)": {
      "main": [
        [
          {
            "node": "Save Pending Approval (Zulip)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond Zulip Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Pending Approval (Zulip)": {
      "main": [
        [
          {
            "node": "Restore Items After Save Pending (Zulip)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Items After Save Pending (Zulip)": {
      "main": [
        [
          {
            "node": "Respond Zulip Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Call Orchestrator Preview -> Merge Preview with Chat Core": {
      "main": [
        [
          {
            "node": "Debug Log Before: Merge Preview with Chat Core <- Call Orchestrator Preview",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Merge Preview with Chat Core <- Call Orchestrator Preview": {
      "main": [
        [
          {
            "node": "Merge Preview with Chat Core",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Required Confirm -> Enqueue Job": {
      "main": [
        [
          {
            "node": "Debug Log Before: Enqueue Job <- IF Required Confirm",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Enqueue Job <- IF Required Confirm": {
      "main": [
        [
          {
            "node": "Enqueue Job",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Required Confirm -> Build Approval Message": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Approval Message <- IF Required Confirm",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Approval Message <- IF Required Confirm": {
      "main": [
        [
          {
            "node": "Build Approval Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Enqueue Job -> Context Store (job_id)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Context Store (job_id) <- Enqueue Job",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Context Store (job_id) <- Enqueue Job": {
      "main": [
        [
          {
            "node": "Context Store (job_id)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Classify Event (Basic) -> Update Normalized Event": {
      "main": [
        [
          {
            "node": "Debug Log Before: Update Normalized Event <- Classify Event (Basic)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Update Normalized Event <- Classify Event (Basic)": {
      "main": [
        [
          {
            "node": "Update Normalized Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Update Normalized Event -> Load Escalation Matrix (GitLab)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Load Escalation Matrix (GitLab) <- Update Normalized Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Load Escalation Matrix (GitLab) <- Update Normalized Event": {
      "main": [
        [
          {
            "node": "Load Escalation Matrix (GitLab)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Context Store (job_id) -> Build Auto-Enqueue Message": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Auto-Enqueue Message <- Context Store (job_id)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Auto-Enqueue Message <- Context Store (job_id)": {
      "main": [
        [
          {
            "node": "Build Auto-Enqueue Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Approval Message -> Use Chat Core Reply": {
      "main": [
        [
          {
            "node": "Debug Log Before: Use Chat Core Reply <- Build Approval Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Use Chat Core Reply <- Build Approval Message": {
      "main": [
        [
          {
            "node": "Use Chat Core Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Auto-Enqueue Message -> Use Chat Core Reply": {
      "main": [
        [
          {
            "node": "Debug Log Before: Use Chat Core Reply <- Build Auto-Enqueue Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Use Chat Core Reply <- Build Auto-Enqueue Message": {
      "main": [
        [
          {
            "node": "Use Chat Core Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Zulip Source (Ingest) -> Post to Zulip (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Post to Zulip (Ingest) <- IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Post to Zulip (Ingest) <- IF Zulip Source (Ingest)": {
      "main": [
        [
          {
            "node": "Post to Zulip (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Zulip Source (Ingest) -> IF Slack Source (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Slack Source (Ingest) <- IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Slack Source (Ingest) <- IF Zulip Source (Ingest)": {
      "main": [
        [
          {
            "node": "IF Slack Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Slack Source (Ingest) -> Post to Slack (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Post to Slack (Ingest) <- IF Slack Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Post to Slack (Ingest) <- IF Slack Source (Ingest)": {
      "main": [
        [
          {
            "node": "Post to Slack (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Slack Source (Ingest) -> IF Mattermost Source (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Mattermost Source (Ingest) <- IF Slack Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Mattermost Source (Ingest) <- IF Slack Source (Ingest)": {
      "main": [
        [
          {
            "node": "IF Mattermost Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Mattermost Source (Ingest) -> Post to Mattermost (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Post to Mattermost (Ingest) <- IF Mattermost Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Post to Mattermost (Ingest) <- IF Mattermost Source (Ingest)": {
      "main": [
        [
          {
            "node": "Post to Mattermost (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Mattermost Source (Ingest) -> IF Teams Source (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Teams Source (Ingest) <- IF Mattermost Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Teams Source (Ingest) <- IF Mattermost Source (Ingest)": {
      "main": [
        [
          {
            "node": "IF Teams Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Teams Source (Ingest) -> Post to Teams (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Post to Teams (Ingest) <- IF Teams Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Post to Teams (Ingest) <- IF Teams Source (Ingest)": {
      "main": [
        [
          {
            "node": "Post to Teams (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Teams Source (Ingest) -> Log Unknown Source (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Log Unknown Source (Ingest) <- IF Teams Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Log Unknown Source (Ingest) <- IF Teams Source (Ingest)": {
      "main": [
        [
          {
            "node": "Log Unknown Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Record Prompt History (Classify) -> OpenAI Classify Event": {
      "main": [
        [
          {
            "node": "Debug Log Before: OpenAI Classify Event <- Record Prompt History (Classify)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: OpenAI Classify Event <- Record Prompt History (Classify)": {
      "main": [
        [
          {
            "node": "OpenAI Classify Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: OpenAI Classify Event -> Parse Classification Response": {
      "main": [
        [
          {
            "node": "Debug Log Before: Parse Classification Response <- OpenAI Classify Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Parse Classification Response <- OpenAI Classify Event": {
      "main": [
        [
          {
            "node": "Parse Classification Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Parse Classification Response -> IF LLM Classified": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF LLM Classified <- Parse Classification Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF LLM Classified <- Parse Classification Response": {
      "main": [
        [
          {
            "node": "IF LLM Classified",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF LLM Classified -> Update Normalized Event": {
      "main": [
        [
          {
            "node": "Debug Log Before: Update Normalized Event <- IF LLM Classified",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Update Normalized Event <- IF LLM Classified": {
      "main": [
        [
          {
            "node": "Update Normalized Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF LLM Classified -> Classify Event (Basic)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Classify Event (Basic) <- IF LLM Classified",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Classify Event (Basic) <- IF LLM Classified": {
      "main": [
        [
          {
            "node": "Classify Event (Basic)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Prompt Override (Classify) -> Load Prompt History (Classify)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Load Prompt History (Classify) <- IF Prompt Override (Classify)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Load Prompt History (Classify) <- IF Prompt Override (Classify)": {
      "main": [
        [
          {
            "node": "Load Prompt History (Classify)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Prompt Override (Classify) -> Record Prompt History (Classify)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Record Prompt History (Classify) <- IF Prompt Override (Classify)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Record Prompt History (Classify) <- IF Prompt Override (Classify)": {
      "main": [
        [
          {
            "node": "Record Prompt History (Classify)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Load Prompt History (Classify) -> Apply Stored Prompt (Classify)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Apply Stored Prompt (Classify) <- Load Prompt History (Classify)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Apply Stored Prompt (Classify) <- Load Prompt History (Classify)": {
      "main": [
        [
          {
            "node": "Apply Stored Prompt (Classify)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Apply Stored Prompt (Classify) -> OpenAI Classify Event": {
      "main": [
        [
          {
            "node": "Debug Log Before: OpenAI Classify Event <- Apply Stored Prompt (Classify)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: OpenAI Classify Event <- Apply Stored Prompt (Classify)": {
      "main": [
        [
          {
            "node": "OpenAI Classify Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Summary Prompt (JP) -> Record Prompt History (Summary)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Record Prompt History (Summary) <- Build Summary Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Record Prompt History (Summary) <- Build Summary Prompt (JP)": {
      "main": [
        [
          {
            "node": "Record Prompt History (Summary)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Record Prompt History (Summary) -> OpenAI Context Summary": {
      "main": [
        [
          {
            "node": "Debug Log Before: OpenAI Context Summary <- Record Prompt History (Summary)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: OpenAI Context Summary <- Record Prompt History (Summary)": {
      "main": [
        [
          {
            "node": "OpenAI Context Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: OpenAI Context Summary -> Parse Summary Response": {
      "main": [
        [
          {
            "node": "Debug Log Before: Parse Summary Response <- OpenAI Context Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Parse Summary Response <- OpenAI Context Summary": {
      "main": [
        [
          {
            "node": "Parse Summary Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Parse Summary Response -> IF Summary OK": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Summary OK <- Parse Summary Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Summary OK <- Parse Summary Response": {
      "main": [
        [
          {
            "node": "IF Summary OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Summary OK -> Update Enrichment Summary": {
      "main": [
        [
          {
            "node": "Debug Log Before: Update Enrichment Summary <- IF Summary OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Update Enrichment Summary <- IF Summary OK": {
      "main": [
        [
          {
            "node": "Update Enrichment Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Summary OK -> Call Orchestrator Preview": {
      "main": [
        [
          {
            "node": "Debug Log Before: Call Orchestrator Preview <- IF Summary OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Call Orchestrator Preview <- IF Summary OK": {
      "main": [
        [
          {
            "node": "Call Orchestrator Preview",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Update Enrichment Summary -> Call Orchestrator Preview": {
      "main": [
        [
          {
            "node": "Debug Log Before: Call Orchestrator Preview <- Update Enrichment Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Call Orchestrator Preview <- Update Enrichment Summary": {
      "main": [
        [
          {
            "node": "Call Orchestrator Preview",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Intent Approval -> Parse Approval Token (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Parse Approval Token (Ingest) <- IF Intent Approval",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Parse Approval Token (Ingest) <- IF Intent Approval": {
      "main": [
        [
          {
            "node": "Guard Approval Intent (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Intent Approval -> IF Intent Feedback": {
      "main": [
        [
          {
            "node": "Guard Non-Approval Intent (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Intent Feedback <- IF Intent Approval": {
      "main": [
        [
          {
            "node": "IF Intent Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Parse Approval Token (Ingest) -> IF Approval Token Valid (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Approval Token Valid (Ingest) <- Parse Approval Token (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Approval Token Valid (Ingest) <- Parse Approval Token (Ingest)": {
      "main": [
        [
          {
            "node": "IF Approval Token Valid (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Approval Token Valid (Ingest) -> Load Pending Approval (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Load Pending Approval (Ingest) <- IF Approval Token Valid (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Load Pending Approval (Ingest) <- IF Approval Token Valid (Ingest)": {
      "main": [
        [
          {
            "node": "Load Pending Approval (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Approval Token Valid (Ingest) -> Build Approval Error Message (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Approval Error Message (Ingest) <- IF Approval Token Valid (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Approval Error Message (Ingest) <- IF Approval Token Valid (Ingest)": {
      "main": [
        [
          {
            "node": "Build Approval Error Message (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Load Pending Approval (Ingest) -> Validate Pending Approval (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Validate Pending Approval (Ingest) <- Load Pending Approval (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Validate Pending Approval (Ingest) <- Load Pending Approval (Ingest)": {
      "main": [
        [
          {
            "node": "Validate Pending Approval (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Validate Pending Approval (Ingest) -> IF Pending Approval Valid (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Pending Approval Valid (Ingest) <- Validate Pending Approval (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Pending Approval Valid (Ingest) <- Validate Pending Approval (Ingest)": {
      "main": [
        [
          {
            "node": "IF Pending Approval Valid (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Pending Approval Valid (Ingest) -> IF Decision Deny (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Decision Deny (Ingest) <- IF Pending Approval Valid (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Decision Deny (Ingest) <- IF Pending Approval Valid (Ingest)": {
      "main": [
        [
          {
            "node": "IF Decision Deny (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Pending Approval Valid (Ingest) -> Build Approval Error Message (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Approval Error Message (Ingest) <- IF Pending Approval Valid (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Approval Error Message (Ingest) <- IF Pending Approval Valid (Ingest)": {
      "main": [
        [
          {
            "node": "Build Approval Error Message (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Decision Deny (Ingest) -> Mark Approval Denied (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Mark Approval Denied (Ingest) <- IF Decision Deny (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Mark Approval Denied (Ingest) <- IF Decision Deny (Ingest)": {
      "main": [
        [
          {
            "node": "Mark Approval Denied (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Decision Deny (Ingest) -> Enqueue Job (Approval Confirm Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Enqueue Job (Approval Confirm Ingest) <- IF Decision Deny (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Enqueue Job (Approval Confirm Ingest) <- IF Decision Deny (Ingest)": {
      "main": [
        [
          {
            "node": "Enqueue Job (Approval Confirm Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Mark Approval Denied (Ingest) -> Record Approval Denied (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Record Approval Denied (Ingest) <- Mark Approval Denied (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Record Approval Denied (Ingest) <- Mark Approval Denied (Ingest)": {
      "main": [
        [
          {
            "node": "Record Approval Denied (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Record Approval Denied (Ingest) -> Load Context (Approval Ack Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Load Context (Approval Ack Ingest) <- Record Approval Denied (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Load Context (Approval Ack Ingest) <- Record Approval Denied (Ingest)": {
      "main": [
        [
          {
            "node": "Load Context (Approval Ack Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Enqueue Job (Approval Confirm Ingest) -> Context Store (job_id) (Approval Confirm Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Context Store (job_id) (Approval Confirm Ingest) <- Enqueue Job (Approval Confirm Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Context Store (job_id) (Approval Confirm Ingest) <- Enqueue Job (Approval Confirm Ingest)": {
      "main": [
        [
          {
            "node": "Context Store (job_id) (Approval Confirm Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Context Store (job_id) (Approval Confirm Ingest) -> Record Approval Approved (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Record Approval Approved (Ingest) <- Context Store (job_id) (Approval Confirm Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Record Approval Approved (Ingest) <- Context Store (job_id) (Approval Confirm Ingest)": {
      "main": [
        [
          {
            "node": "Record Approval Approved (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Record Approval Approved (Ingest) -> Load Context (Approval Ack Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Load Context (Approval Ack Ingest) <- Record Approval Approved (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Load Context (Approval Ack Ingest) <- Record Approval Approved (Ingest)": {
      "main": [
        [
          {
            "node": "Load Context (Approval Ack Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Load Context (Approval Ack Ingest) -> Build Approval Ack (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Approval Ack (Ingest) <- Load Context (Approval Ack Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Approval Ack (Ingest) <- Load Context (Approval Ack Ingest)": {
      "main": [
        [
          {
            "node": "Build Approval Ack (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Approval Ack (Ingest) -> IF Zulip Source (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Zulip Source (Ingest) <- Build Approval Ack (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Zulip Source (Ingest) <- Build Approval Ack (Ingest)": {
      "main": [
        [
          {
            "node": "IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Approval Error Message (Ingest) -> IF Zulip Source (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Zulip Source (Ingest) <- Build Approval Error Message (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Zulip Source (Ingest) <- Build Approval Error Message (Ingest)": {
      "main": [
        [
          {
            "node": "IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Intent Feedback -> IF Feedback Type Preview (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Feedback Type Preview (Ingest) <- IF Intent Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Feedback Type Preview (Ingest) <- IF Intent Feedback": {
      "main": [
        [
          {
            "node": "IF Feedback Type Preview (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Intent Feedback -> IF Event Kind Other": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Event Kind Other <- IF Intent Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Event Kind Other <- IF Intent Feedback": {
      "main": [
        [
          {
            "node": "IF Event Kind Other",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Feedback Type Preview (Ingest) -> Parse Preview Feedback (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Parse Preview Feedback (Ingest) <- IF Feedback Type Preview (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Parse Preview Feedback (Ingest) <- IF Feedback Type Preview (Ingest)": {
      "main": [
        [
          {
            "node": "Parse Preview Feedback (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Feedback Type Preview (Ingest) -> Parse Feedback (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Parse Feedback (Ingest) <- IF Feedback Type Preview (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Parse Feedback (Ingest) <- IF Feedback Type Preview (Ingest)": {
      "main": [
        [
          {
            "node": "Parse Feedback (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Parse Preview Feedback (Ingest) -> Store Preview Feedback (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Store Preview Feedback (Ingest) <- Parse Preview Feedback (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Store Preview Feedback (Ingest) <- Parse Preview Feedback (Ingest)": {
      "main": [
        [
          {
            "node": "Store Preview Feedback (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Store Preview Feedback (Ingest) -> Build Feedback Ack (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Feedback Ack (Ingest) <- Store Preview Feedback (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Feedback Ack (Ingest) <- Store Preview Feedback (Ingest)": {
      "main": [
        [
          {
            "node": "Build Feedback Ack (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Parse Feedback (Ingest) -> Load Feedback Context (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Load Feedback Context (Ingest) <- Parse Feedback (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Load Feedback Context (Ingest) <- Parse Feedback (Ingest)": {
      "main": [
        [
          {
            "node": "Load Feedback Context (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Load Feedback Context (Ingest) -> Build Feedback Decision Prompt (JP) (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Feedback Decision Prompt (JP) (Ingest) <- Load Feedback Context (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Feedback Decision Prompt (JP) (Ingest) <- Load Feedback Context (Ingest)": {
      "main": [
        [
          {
            "node": "Build Feedback Decision Prompt (JP) (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Feedback Decision Prompt (JP) (Ingest) -> Record Prompt History (Feedback Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Record Prompt History (Feedback Ingest) <- Build Feedback Decision Prompt (JP) (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Record Prompt History (Feedback Ingest) <- Build Feedback Decision Prompt (JP) (Ingest)": {
      "main": [
        [
          {
            "node": "Record Prompt History (Feedback Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Record Prompt History (Feedback Ingest) -> OpenAI Feedback Decide (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: OpenAI Feedback Decide (Ingest) <- Record Prompt History (Feedback Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: OpenAI Feedback Decide (Ingest) <- Record Prompt History (Feedback Ingest)": {
      "main": [
        [
          {
            "node": "OpenAI Feedback Decide (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: OpenAI Feedback Decide (Ingest) -> Parse Feedback Decision Response (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Parse Feedback Decision Response (Ingest) <- OpenAI Feedback Decide (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Parse Feedback Decision Response (Ingest) <- OpenAI Feedback Decide (Ingest)": {
      "main": [
        [
          {
            "node": "Parse Feedback Decision Response (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Parse Feedback Decision Response (Ingest) -> Store Feedback (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Store Feedback (Ingest) <- Parse Feedback Decision Response (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Store Feedback (Ingest) <- Parse Feedback Decision Response (Ingest)": {
      "main": [
        [
          {
            "node": "Store Feedback (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Store Feedback (Ingest) -> Build Feedback Ack (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Feedback Ack (Ingest) <- Store Feedback (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Feedback Ack (Ingest) <- Store Feedback (Ingest)": {
      "main": [
        [
          {
            "node": "Build Feedback Ack (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Feedback Ack (Ingest) -> IF Zulip Source (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Zulip Source (Ingest) <- Build Feedback Ack (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Zulip Source (Ingest) <- Build Feedback Ack (Ingest)": {
      "main": [
        [
          {
            "node": "IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Event Kind Other -> Update Normalized Event (Other)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Update Normalized Event (Other) <- IF Event Kind Other",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Update Normalized Event (Other) <- IF Event Kind Other": {
      "main": [
        [
          {
            "node": "Update Normalized Event (Other)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Event Kind Other -> Update Normalized Event": {
      "main": [
        [
          {
            "node": "Debug Log Before: Update Normalized Event <- IF Event Kind Other",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Update Normalized Event <- IF Event Kind Other": {
      "main": [
        [
          {
            "node": "Update Normalized Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Needs Clarification (Other) -> Build Clarification Message (Other)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Clarification Message (Other) <- IF Needs Clarification (Other)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Clarification Message (Other) <- IF Needs Clarification (Other)": {
      "main": [
        [
          {
            "node": "Build Clarification Message (Other)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Needs Clarification (Other) -> Build Friendly Reply (Other)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Friendly Reply (Other) <- IF Needs Clarification (Other)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Friendly Reply (Other) <- IF Needs Clarification (Other)": {
      "main": [
        [
          {
            "node": "Build Friendly Reply (Other)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Clarification Message (Other) -> IF Zulip Source (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Zulip Source (Ingest) <- Build Clarification Message (Other)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Zulip Source (Ingest) <- Build Clarification Message (Other)": {
      "main": [
        [
          {
            "node": "IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Update Normalized Event (Other) -> IF Needs Clarification (Other)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Needs Clarification (Other) <- Update Normalized Event (Other)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Needs Clarification (Other) <- Update Normalized Event (Other)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Friendly Reply (Other) <- IF Needs Clarification (Other)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Friendly Reply (Other) -> IF Zulip Source (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Zulip Source (Ingest) <- Build Friendly Reply (Other)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Zulip Source (Ingest) <- Build Friendly Reply (Other)": {
      "main": [
        [
          {
            "node": "IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Routing Prompt (JP) -> Record Prompt History (Routing)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Record Prompt History (Routing) <- Build Routing Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Record Prompt History (Routing) <- Build Routing Prompt (JP)": {
      "main": [
        [
          {
            "node": "Record Prompt History (Routing)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Record Prompt History (Routing) -> OpenAI Routing Decide": {
      "main": [
        [
          {
            "node": "Debug Log Before: OpenAI Routing Decide <- Record Prompt History (Routing)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: OpenAI Routing Decide <- Record Prompt History (Routing)": {
      "main": [
        [
          {
            "node": "OpenAI Routing Decide",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: OpenAI Routing Decide -> Parse Routing Decide Response": {
      "main": [
        [
          {
            "node": "Debug Log Before: Parse Routing Decide Response <- OpenAI Routing Decide",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Parse Routing Decide Response <- OpenAI Routing Decide": {
      "main": [
        [
          {
            "node": "Parse Routing Decide Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Parse Routing Decide Response -> IF Routing Decide OK": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Routing Decide OK <- Parse Routing Decide Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Routing Decide OK <- Parse Routing Decide Response": {
      "main": [
        [
          {
            "node": "IF Routing Decide OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Routing Decide OK -> Apply Selected Routing": {
      "main": [
        [
          {
            "node": "Debug Log Before: Apply Selected Routing <- IF Routing Decide OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Apply Selected Routing <- IF Routing Decide OK": {
      "main": [
        [
          {
            "node": "Apply Selected Routing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Routing Decide OK -> Apply Escalation Routing": {
      "main": [
        [
          {
            "node": "Debug Log Before: Apply Escalation Routing <- IF Routing Decide OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Apply Escalation Routing <- IF Routing Decide OK": {
      "main": [
        [
          {
            "node": "Apply Escalation Routing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Apply Selected Routing -> Update Routing Context": {
      "main": [
        [
          {
            "node": "Debug Log Before: Update Routing Context <- Apply Selected Routing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Update Routing Context <- Apply Selected Routing": {
      "main": [
        [
          {
            "node": "Update Routing Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Apply Escalation Routing -> Update Routing Context": {
      "main": [
        [
          {
            "node": "Debug Log Before: Update Routing Context <- Apply Escalation Routing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Update Routing Context <- Apply Escalation Routing": {
      "main": [
        [
          {
            "node": "Update Routing Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Update Routing Context -> Build Summary Prompt (JP)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Summary Prompt (JP) <- Update Routing Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Summary Prompt (JP) <- Update Routing Context": {
      "main": [
        [
          {
            "node": "Build Summary Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Initial Reply Prompt (JP) -> Record Prompt History (Initial Reply)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Record Prompt History (Initial Reply) <- Build Initial Reply Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Record Prompt History (Initial Reply) <- Build Initial Reply Prompt (JP)": {
      "main": [
        [
          {
            "node": "Record Prompt History (Initial Reply)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Record Prompt History (Initial Reply) -> OpenAI Initial Reply": {
      "main": [
        [
          {
            "node": "Debug Log Before: OpenAI Initial Reply <- Record Prompt History (Initial Reply)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: OpenAI Initial Reply <- Record Prompt History (Initial Reply)": {
      "main": [
        [
          {
            "node": "OpenAI Initial Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: OpenAI Initial Reply -> Use Chat Core Reply": {
      "main": [
        [
          {
            "node": "Parse Initial Reply Response (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Initial Reply Response (JP)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Use Chat Core Reply <- OpenAI Initial Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Use Chat Core Reply <- OpenAI Initial Reply": {
      "main": [
        [
          {
            "node": "Use Chat Core Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Chat Core Prompt (JP) -> Record Prompt History (Chat Core)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Record Prompt History (Chat Core) <- Build Chat Core Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Record Prompt History (Chat Core) <- Build Chat Core Prompt (JP)": {
      "main": [
        [
          {
            "node": "Record Prompt History (Chat Core)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Record Prompt History (Chat Core) -> OpenAI Chat Core": {
      "main": [
        [
          {
            "node": "Debug Log Before: OpenAI Chat Core <- Record Prompt History (Chat Core)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: OpenAI Chat Core <- Record Prompt History (Chat Core)": {
      "main": [
        [
          {
            "node": "OpenAI Chat Core",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: OpenAI Chat Core -> AIOPS Observer (Chat Core)": {
      "main": [
        [
          {
            "node": "Debug Log Before: AIOPS Observer (Chat Core) <- OpenAI Chat Core",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: AIOPS Observer (Chat Core) <- OpenAI Chat Core": {
      "main": [
        [
          {
            "node": "AIOPS Observer (Chat Core)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: AIOPS Observer (Chat Core) -> Parse Chat Core Response": {
      "main": [
        [
          {
            "node": "Debug Log Before: Parse Chat Core Response <- AIOPS Observer (Chat Core)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Parse Chat Core Response <- AIOPS Observer (Chat Core)": {
      "main": [
        [
          {
            "node": "Parse Chat Core Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Parse Chat Core Response -> IF Intent Approval": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Intent Approval <- Parse Chat Core Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Intent Approval <- Parse Chat Core Response": {
      "main": [
        [
          {
            "node": "IF Intent Approval",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Use Chat Core Reply -> IF Zulip Source (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Zulip Source (Ingest) <- Use Chat Core Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Zulip Source (Ingest) <- Use Chat Core Reply": {
      "main": [
        [
          {
            "node": "Augment Ask Clarification (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Augment Ask Clarification (JP)": {
      "main": [
        [
          {
            "node": "Secret Handling Guidance (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Secret Handling Guidance (JP)": {
      "main": [
        [
          {
            "node": "Explain SLO Term (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Explain SLO Term (JP)": {
      "main": [
        [
          {
            "node": "Prevent Topic Token Leak (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prevent Topic Token Leak (JP)": {
      "main": [
        [
          {
            "node": "IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Merge Preview with Chat Core -> IF Required Confirm": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Required Confirm <- Merge Preview with Chat Core",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Required Confirm <- Merge Preview with Chat Core": {
      "main": [
        [
          {
            "node": "IF Required Confirm",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Load Escalation Matrix (GitLab) -> Load Escalation Context Age": {
      "main": [
        [
          {
            "node": "Debug Log Before: Load Escalation Context Age <- Load Escalation Matrix (GitLab)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Load Escalation Context Age <- Load Escalation Matrix (GitLab)": {
      "main": [
        [
          {
            "node": "Load Escalation Context Age",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Load Escalation Context Age -> Attach Escalation Context": {
      "main": [
        [
          {
            "node": "Debug Log Before: Attach Escalation Context <- Load Escalation Context Age",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Attach Escalation Context <- Load Escalation Context Age": {
      "main": [
        [
          {
            "node": "Attach Escalation Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Attach Escalation Context -> Build Routing Prompt (JP)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Routing Prompt (JP) <- Attach Escalation Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Routing Prompt (JP) <- Attach Escalation Context": {
      "main": [
        [
          {
            "node": "Build Routing Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Verify Keycloak Membership (Zulip) -> IF Keycloak Membership OK": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Keycloak Membership OK <- Verify Keycloak Membership (Zulip)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Keycloak Membership OK <- Verify Keycloak Membership (Zulip)": {
      "main": [
        [
          {
            "node": "IF Keycloak Membership OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Keycloak Membership OK -> Context Store (Insert)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Context Store (Insert) <- IF Keycloak Membership OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Context Store (Insert) <- IF Keycloak Membership OK": {
      "main": [
        [
          {
            "node": "PII Redaction (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PII Redaction (Ingest)": {
      "main": [
        [
          {
            "node": "Context Store (Insert)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Keycloak Membership OK -> Build Keycloak Reject Message (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Keycloak Reject Message (Ingest) <- IF Keycloak Membership OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Keycloak Reject Message (Ingest) <- IF Keycloak Membership OK": {
      "main": [
        [
          {
            "node": "Build Keycloak Reject Message (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Keycloak Reject Message (Ingest) -> IF Zulip Source (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Zulip Source (Ingest) <- Build Keycloak Reject Message (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Zulip Source (Ingest) <- Build Keycloak Reject Message (Ingest)": {
      "main": [
        [
          {
            "node": "IF Zulip Source (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Guard Valid (Ingest) -> Verify Keycloak Membership (Zulip)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Verify Keycloak Membership (Zulip) <- Guard Valid (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Verify Keycloak Membership (Zulip) <- Guard Valid (Ingest)": {
      "main": [
        [
          {
            "node": "Verify Keycloak Membership (Zulip)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Guard Approval Intent (Ingest)": {
      "main": [
        [
          {
            "node": "Parse Approval Token (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Guard Non-Approval Intent (Ingest)": {
      "main": [
        [
          {
            "node": "Guard Feedback Intent (Ingest)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Guard Other Intent (Ingest)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Guard Feedback Intent (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Feedback Type Preview (Ingest) <- IF Intent Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Guard Other Intent (Ingest)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Update Normalized Event (Other) <- IF Event Kind Other",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Enrichment Plan Prompt (JP)": {
      "main": [
        [
          {
            "node": "Record Prompt History (Enrichment Plan)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Record Prompt History (Enrichment Plan)": {
      "main": [
        [
          {
            "node": "OpenAI Enrichment Plan",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Enrichment Plan": {
      "main": [
        [
          {
            "node": "Parse Enrichment Plan Response",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Sulu Monitoring Payload (After: OpenAI Enrichment Plan)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Enrichment Plan Response": {
      "main": [
        [
          {
            "node": "Enrich RAG Route (Enrichment)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrich RAG Route (Enrichment)": {
      "main": [
        [
          {
            "node": "IF RAG Mode = Problem (Enrichment)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrichment RAG Query (KEDB)": {
      "main": [
        [
          {
            "node": "Merge Enrichment RAG Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrichment RAG Query (Problem)": {
      "main": [
        [
          {
            "node": "Merge Enrichment RAG Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrichment RAG Query (GitLab Docs)": {
      "main": [
        [
          {
            "node": "Merge Enrichment RAG Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Enrichment RAG Results": {
      "main": [
        [
          {
            "node": "Fetch CMDB/Runbook (GitLab) (Enrichment)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch CMDB/Runbook (GitLab) (Enrichment)": {
      "main": [
        [
          {
            "node": "Build Enrichment Evidence",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Enrichment Evidence": {
      "main": [
        [
          {
            "node": "Build Enrichment Summary Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Enrichment Summary Prompt (JP)": {
      "main": [
        [
          {
            "node": "Record Prompt History (Enrichment Summary)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Record Prompt History (Enrichment Summary)": {
      "main": [
        [
          {
            "node": "OpenAI Enrichment Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Enrichment Summary": {
      "main": [
        [
          {
            "node": "Parse Enrichment Summary Response",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Sulu Monitoring Payload (After: OpenAI Enrichment Summary)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Enrichment Summary Response": {
      "main": [
        [
          {
            "node": "Update Enrichment Results (Context Store)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Enrichment Results (Context Store)": {
      "main": [
        [
          {
            "node": "Restore Payload After Enrichment Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF RAG Mode = Problem (Enrichment)": {
      "main": [
        [
          {
            "node": "Enrichment RAG Query (Problem)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "IF RAG Mode = GitLab Docs (Enrichment)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF RAG Mode = GitLab Docs (Enrichment)": {
      "main": [
        [
          {
            "node": "Enrichment RAG Query (GitLab Docs)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Enrichment RAG Query (KEDB)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Payload After Enrichment Update": {
      "main": [
        [
          {
            "node": "Force CloudWatch Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionTimeout": 300
  },
  "versionId": "00000000-0000-0000-0000-000000000000",
  "meta": {
    "aiops": {
      "purpose": "Adapter: ingest -> normalize -> dedupe -> preview -> enqueue"
    }
  }
}
