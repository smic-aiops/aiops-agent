{
  "name": "aiops-adapter-callback",
  "nodes": [
    {
      "parameters": {
        "path": "callback/job-engine",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "1",
      "name": "Webhook (Job Callback)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        240,
        240
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { ok: true } }}",
        "options": {}
      },
      "id": "2",
      "name": "Respond 200",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        460,
        240
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH input AS (\n  SELECT\n    NULLIF(NULLIF('{{ String($json.body?.job_id ?? $json.job_id ?? '').replace(/'/g, \"''\") }}',''), 'undefined')::uuid AS job_id,\n    '{{ String($json.body?.status ?? $json.status ?? '').replace(/'/g, \"''\") }}' AS status,\n    NULLIF('{{ JSON.stringify($json.body?.result_payload ?? $json.result_payload ?? null).replace(/'/g, \"''\") }}','undefined')::jsonb AS result_payload,\n    NULLIF('{{ JSON.stringify($json.body?.error_payload ?? $json.error_payload ?? null).replace(/'/g, \"''\") }}','undefined')::jsonb AS error_payload\n)\nSELECT\n  reply_target,\n  actor,\n  normalized_event,\n  (SELECT trace_id FROM aiops_job_queue WHERE job_id = (SELECT job_id FROM input)) AS trace_id\nFROM aiops_context\nWHERE context_id = (SELECT context_id FROM aiops_job_queue WHERE job_id = (SELECT job_id FROM input));\n\nWITH input AS (\n  SELECT\n    NULLIF(NULLIF('{{ String($json.body?.job_id ?? $json.job_id ?? '').replace(/'/g, \"''\") }}',''), 'undefined')::uuid AS job_id,\n    '{{ String($json.body?.status ?? $json.status ?? '').replace(/'/g, \"''\") }}' AS status,\n    NULLIF('{{ JSON.stringify($json.body?.result_payload ?? $json.result_payload ?? null).replace(/'/g, \"''\") }}','undefined')::jsonb AS result_payload,\n    NULLIF('{{ JSON.stringify($json.body?.error_payload ?? $json.error_payload ?? null).replace(/'/g, \"''\") }}','undefined')::jsonb AS error_payload\n)\nINSERT INTO aiops_job_results (job_id, status, result_payload, error_payload)\nVALUES (\n  (SELECT job_id FROM input),\n  (SELECT status FROM input),\n  (SELECT result_payload FROM input),\n  (SELECT error_payload FROM input)\n)\nON CONFLICT (job_id) DO UPDATE SET\n  status = EXCLUDED.status,\n  result_payload = EXCLUDED.result_payload,\n  error_payload = EXCLUDED.error_payload;\n\nWITH input AS (\n  SELECT\n    NULLIF(NULLIF('{{ String($json.body?.job_id ?? $json.job_id ?? '').replace(/'/g, \"''\") }}',''), 'undefined')::uuid AS job_id,\n    '{{ String($json.body?.status ?? $json.status ?? '').replace(/'/g, \"''\") }}' AS status\n)\nUPDATE aiops_job_queue\nSET status = (SELECT status FROM input), finished_at = NOW()\nWHERE job_id = (SELECT job_id FROM input);"
      },
      "id": "3",
      "name": "Load Context + Save Result",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        460,
        440
      ]
    },
    {
      "parameters": {
        "url": "={{ (() => {\n  const tenant = $json.reply_target?.tenant ?? $json.reply_target?.realm ?? '';\n  const jsonRaw = $env.N8N_ZULIP_API_BASE_URL || '';\n  const yamlRaw = $env.N8N_ZULIP_API_BASE_URL || '';\n  const fallback = $env.N8N_ZULIP_API_BASE_URL || $env.ZULIP_API_BASE_URL || '';\n  const parseYaml = (text) => {\n    const map = {};\n    String(text).split(/\\r?\\n/).forEach((line) => {\n      const trimmed = line.trim();\n      if (!trimmed || trimmed.startsWith('#')) return;\n      const idx = trimmed.indexOf(':');\n      if (idx <= 0) return;\n      const key = trimmed.slice(0, idx).trim();\n      let value = trimmed.slice(idx + 1).trim();\n      if (!key) return;\n      value = value.replace(/^['\"]|['\"]$/g, '');\n      map[key] = value;\n    });\n    return map;\n  };\n  let map = {};\n  if (jsonRaw) {\n    try {\n      const parsed = JSON.parse(jsonRaw);\n      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n        map = parsed;\n      }\n    } catch (error) {}\n  }\n  if (!Object.keys(map).length && yamlRaw) {\n    map = parseYaml(yamlRaw);\n  }\n  const base = (tenant && map[tenant]) ? map[tenant] : (map.default || fallback);\n  const trimmed = base ? String(base).replace(/\\/+$/, '') : '';\n  if (!trimmed) return '';\n  const apiBase = trimmed.endsWith('/api/v1') ? trimmed : (trimmed + '/api/v1');\n  return apiBase + '/messages';\n})() }}",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { type: 'stream', to: $json.reply_target.stream, topic: $json.reply_target.topic, content: $json.content } }}",
        "options": {},
        "sendHeaders": true,
        "specifyHeaders": "keypair",
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "={{ (() => {\n  const tenant = $json.reply_target?.tenant ?? $json.reply_target?.realm ?? '';\n  const tokenJsonRaw = $env.N8N_ZULIP_BOT_TOKEN || '';\n  const tokenYamlRaw = $env.ZULIP_BOT_TOKEN || $env.N8N_ZULIP_BOT_TOKEN || '';\n  const emailJsonRaw = $env.N8N_ZULIP_BOT_EMAIL || '';\n  const emailYamlRaw = $env.N8N_ZULIP_BOT_EMAIL || '';\n  const fallbackToken = $env.N8N_ZULIP_BOT_TOKEN || $env.ZULIP_BOT_TOKEN || '';\n  const fallbackEmail = $env.N8N_ZULIP_BOT_EMAIL || $env.ZULIP_BOT_EMAIL || '';\n  const parseYaml = (text) => {\n    const map = {};\n    String(text).split(/\\r?\\n/).forEach((line) => {\n      const trimmed = line.trim();\n      if (!trimmed || trimmed.startsWith('#')) return;\n      const idx = trimmed.indexOf(':');\n      if (idx <= 0) return;\n      const key = trimmed.slice(0, idx).trim();\n      let value = trimmed.slice(idx + 1).trim();\n      if (!key) return;\n      value = value.replace(/^['\"]|['\"]$/g, '');\n      map[key] = value;\n    });\n    return map;\n  };\n  const parseMap = (jsonRaw, yamlRaw) => {\n    let map = {};\n    if (jsonRaw) {\n      try {\n        const parsed = JSON.parse(jsonRaw);\n        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n          map = parsed;\n        }\n      } catch (error) {}\n    }\n    if (!Object.keys(map).length && yamlRaw) {\n      map = parseYaml(yamlRaw);\n    }\n    return map;\n  };\n  const tokenMap = parseMap(tokenJsonRaw, tokenYamlRaw);\n  const emailMap = parseMap(emailJsonRaw, emailYamlRaw);\n  const token = (tenant && tokenMap[tenant]) ? tokenMap[tenant] : (tokenMap.default || fallbackToken);\n  const email = (tenant && emailMap[tenant]) ? emailMap[tenant] : (emailMap.default || fallbackEmail);\n  if (!email || !token) return '';\n  return 'Basic ' + Buffer.from(email + ':' + token).toString('base64');\n})() }}"
            }
          ]
        }
      },
      "id": "5",
      "name": "Post to Zulip",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1380,
        120
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.reply_target?.source ?? 'zulip' }}",
              "value2": "zulip"
            }
          ]
        }
      },
      "id": "6",
      "name": "IF Zulip Source",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1260,
        120
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.reply_target?.source ?? '' }}",
              "value2": "slack"
            }
          ]
        }
      },
      "id": "7",
      "name": "IF Slack Source",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1260,
        240
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.reply_target?.source ?? '' }}",
              "value2": "mattermost"
            }
          ]
        }
      },
      "id": "8",
      "name": "IF Mattermost Source",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1260,
        360
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.reply_target?.source ?? '' }}",
              "value2": "teams"
            }
          ]
        }
      },
      "id": "9",
      "name": "IF Teams Source",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1260,
        480
      ]
    },
    {
      "parameters": {
        "url": "https://slack.com/api/chat.postMessage",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ (() => { const payload = { channel: $json.reply_target?.channel ?? $json.reply_target?.channel_id, text: $json.content }; if ($json.reply_target?.thread_ts) payload.thread_ts = $json.reply_target.thread_ts; return payload; })() }}",
        "options": {
          "headers": {
            "Authorization": "Bearer {{$env.SLACK_BOT_TOKEN}}",
            "Content-Type": "application/json"
          }
        }
      },
      "id": "10",
      "name": "Post to Slack",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        1480,
        240
      ]
    },
    {
      "parameters": {
        "url": "={{ ($env.MATTERMOST_API_BASE_URL ?? 'https://mattermost.example.com') + '/api/v4/posts' }}",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { channel_id: $json.reply_target?.channel_id ?? $json.reply_target?.channel, message: $json.content } }}",
        "options": {
          "headers": {
            "Authorization": "Bearer {{$env.MATTERMOST_BOT_TOKEN}}",
            "Content-Type": "application/json"
          }
        }
      },
      "id": "11",
      "name": "Post to Mattermost",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        1480,
        360
      ]
    },
    {
      "parameters": {
        "url": "={{ ($json.reply_target?.service_url ?? 'https://smba.trafficmanager.net/teams/') + 'v3/conversations/' + ($json.reply_target?.conversation_id ?? '') + '/activities' }}",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { type: 'message', text: $json.content } }}",
        "options": {
          "headers": {
            "Authorization": "Bearer {{$env.N8N_TEAMS_BOT_TOKEN}}",
            "Content-Type": "application/json"
          }
        }
      },
      "id": "12",
      "name": "Post to Teams",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        1480,
        480
      ]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "message",
              "value": "={{ `Unknown reply target source ${$json.reply_target?.source ?? \"unknown\"}` }}"
            },
            {
              "name": "reply_target",
              "value": "={{ $json.reply_target }}"
            }
          ]
        },
        "options": {}
      },
      "id": "13",
      "name": "Log Unknown Source",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [
        1480,
        600
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst baseRow = Array.isArray($json) ? ($json[0] ?? {}) : ($json ?? {});\nconst replyTarget = baseRow.reply_target ?? null;\nif (!replyTarget) throw new Error('reply_target not found');\n\nconst jobResult = $input.first().json ?? {};\nconst jobId = jobResult.job_id ?? null;\n\nlet decisionPolicyDoc = null;\ntry {\n  decisionPolicyDoc = JSON.parse(\"__POLICY__DECISION__\");\n} catch (error) {\n  decisionPolicyDoc = null;\n}\n\nlet interactionGrammar = null;\ntry {\n  interactionGrammar = JSON.parse(\"__POLICY__INTERACTION_GRAMMAR__\");\n} catch (error) {\n  interactionGrammar = null;\n}\n\nlet sourceCapabilitiesDoc = null;\ntry {\n  sourceCapabilitiesDoc = JSON.parse(\"__POLICY__SOURCE_CAPABILITIES__\");\n} catch (error) {\n  sourceCapabilitiesDoc = null;\n}\n\nconst source = replyTarget.source ?? 'unknown';\nconst sourceCapabilities = sourceCapabilitiesDoc?.sources?.[source] ?? {};\n\nconst policyContext = {\n  limits: decisionPolicyDoc?.limits ?? {},\n  taxonomy: decisionPolicyDoc?.taxonomy ?? {},\n  thresholds: decisionPolicyDoc?.thresholds ?? {},\n  defaults: decisionPolicyDoc?.defaults ?? {},\n  rules: decisionPolicyDoc?.rules ?? {},\n  fallbacks: decisionPolicyDoc?.fallbacks ?? {},\n  interaction_grammar: interactionGrammar\n};\n\nconst input = {\n  policy_context: policyContext,\n  source,\n  job_id: jobId,\n  capabilities: {\n    supports_buttons: sourceCapabilities.supports_buttons ?? null,\n    supports_links: sourceCapabilities.supports_links ?? null,\n    supports_text_commands: sourceCapabilities.supports_text_commands ?? null,\n    preferred_interaction: sourceCapabilities.preferred_interaction ?? null\n  }\n};\n\nconst promptText = \"__PROMPT__FEEDBACK_REQUEST_RENDER__\";\nconst promptHash = crypto.createHash('sha256').update(promptText).digest('hex');\n\nreturn [{\n  json: {\n    ...baseRow,\n    reply_target: replyTarget,\n    source,\n    policy_context: policyContext,\n    job_result: {\n      job_id: jobId,\n      status: jobResult.status ?? null,\n      result_payload: jobResult.result_payload ?? null,\n      error_payload: jobResult.error_payload ?? null,\n      trace_id: jobResult.trace_id ?? baseRow.trace_id ?? null\n    },\n    prompt_key: 'adapter.feedback_request_render.v1',\n    prompt_version: 'ja-1',\n    prompt_text: promptText,\n    prompt_hash: promptHash,\n    prompt_input: JSON.stringify(input)\n  }\n}];\n"
      },
      "id": "14",
      "name": "Build Feedback Request Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        440
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO aiops_prompt_history (prompt_key, prompt_version, prompt_text, prompt_hash, source_workflow, source_node)\nVALUES (\n  '{{ String($json.prompt_key ?? '').replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_version ?? '').replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_text ?? '').replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_hash ?? '').replace(/'/g, \"''\") }}',\n  'aiops-adapter-callback',\n  'OpenAI Feedback Request Render'\n)\nON CONFLICT (prompt_key, prompt_hash) DO NOTHING;"
      },
      "id": "15",
      "name": "Record Prompt History (Feedback Request)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        940,
        440
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "operation": "complete",
        "model": "={{$env.OPENAI_MODEL || 'gpt-4o-mini'}}",
        "prompt": {
          "messages": [
            {
              "role": "system",
              "content": "={{ $node['Build Feedback Request Prompt (JP)'].json.prompt_text }}"
            },
            {
              "role": "user",
              "content": "={{ '入力:\\n' + $node['Build Feedback Request Prompt (JP)'].json.prompt_input }}"
            }
          ]
        },
        "options": {
          "temperature": 0.2,
          "baseURL": "={{$env.OPENAI_BASE_URL}}",
          "maxTokens": "={{$json.policy_context?.limits?.llm_output_tokens || 1200}}"
        }
      },
      "id": "16",
      "name": "OpenAI Feedback Request Render",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        1180,
        440
      ],
      "credentials": {
        "openAiApi": {
          "name": "aiops-openai"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const base = $node['Build Feedback Request Prompt (JP)'].json ?? {};\nconst response = $json ?? {};\n\nfunction normalizeNewlines(raw) {\n  let text = String(raw ?? '');\n  if (!text) return text;\n  // Normalize actual CRLF/CR\n  text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  // Normalize double-escaped sequences (e.g., \"\\\\n\")\n  text = text.replace(/\\\\r\\\\n/g, '\\n').replace(/\\\\n/g, '\\n').replace(/\\\\r/g, '\\n');\n  return text;\n}\n\nconst extractContent = (payload) => {\n  return payload?.choices?.[0]?.message?.content\n    ?? payload?.choices?.[0]?.text\n    ?? payload?.data?.choices?.[0]?.message?.content\n    ?? '';\n};\n\nconst rawContent = extractContent(response);\nlet parsed = null;\nif (typeof rawContent === 'string') {\n  try {\n    parsed = JSON.parse(rawContent);\n  } catch (error) {\n    const match = rawContent.match(/\\{[\\s\\S]*\\}/);\n    if (match) {\n      try {\n        parsed = JSON.parse(match[0]);\n      } catch (inner) {\n        parsed = null;\n      }\n    }\n  }\n} else if (rawContent && typeof rawContent === 'object') {\n  parsed = rawContent;\n}\n\nconst isObject = (v) => Boolean(v) && typeof v === 'object' && !Array.isArray(v);\nconst ok = isObject(parsed) && typeof parsed.feedback_request_text === 'string';\n\nconst policyContext = base.policy_context ?? {};\nconst fallbacks = policyContext?.fallbacks?.feedback_request_render ?? {};\nconst defaults = policyContext?.defaults?.feedback_request_render ?? {};\n\nconst safeDecision = ok ? parsed : {\n  feedback_request_text: fallbacks.default_text ?? defaults.default_text ?? '',\n  needs_clarification: Boolean(fallbacks.clarifying_question),\n  clarifying_question: fallbacks.clarifying_question ?? null,\n  confidence: 0,\n  rationale: fallbacks.rationale ?? 'モデル出力が無効なためフォールバック'\n};\n\nsafeDecision.feedback_request_text = normalizeNewlines(safeDecision.feedback_request_text);\nif (ok) {\n  parsed.feedback_request_text = safeDecision.feedback_request_text;\n}\n\nreturn [{\n  json: {\n    ...base,\n    llm_feedback_request_ok: ok,\n    feedback_request_render: safeDecision,\n    feedback_request_text: safeDecision.feedback_request_text\n  }\n}];\n"
      },
      "id": "17",
      "name": "Parse Feedback Request Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1420,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nconst base = $json ?? {};\nconst replyTarget = base.reply_target ?? null;\nif (!replyTarget) throw new Error('reply_target not found');\n\nconst jobResult = base.job_result ?? {};\nconst policyContext = base.policy_context ?? {};\nconst normalizedEvent = base.normalized_event ?? null;\nconst traceId = jobResult.trace_id ?? base.trace_id ?? null;\n\nconst input = {\n  policy_context: policyContext,\n  job_result: {\n    job_id: jobResult.job_id ?? null,\n    status: jobResult.status ?? null,\n    result_payload: jobResult.result_payload ?? null,\n    error_payload: jobResult.error_payload ?? null,\n    trace_id: traceId,\n    retryable: jobResult.error_payload?.retryable ?? null\n  },\n  context: {\n    reply_target: replyTarget,\n    normalized_event: normalizedEvent,\n    trace_id: traceId\n  },\n  feedback_request_text: base.feedback_request_text ?? null\n};\n\nconst promptText = \"__PROMPT__JOB_RESULT_REPLY__\";\nconst promptHash = crypto.createHash('sha256').update(promptText).digest('hex');\n\nreturn [{\n  json: {\n    ...base,\n    prompt_key: 'adapter.job_result_reply.v1',\n    prompt_version: 'ja-1',\n    prompt_text: promptText,\n    prompt_hash: promptHash,\n    prompt_input: JSON.stringify(input)\n  }\n}];\n"
      },
      "id": "18",
      "name": "Build Job Result Reply Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1660,
        440
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO aiops_prompt_history (prompt_key, prompt_version, prompt_text, prompt_hash, source_workflow, source_node)\nVALUES (\n  '{{ String($json.prompt_key ?? '').replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_version ?? '').replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_text ?? '').replace(/'/g, \"''\") }}',\n  '{{ String($json.prompt_hash ?? '').replace(/'/g, \"''\") }}',\n  'aiops-adapter-callback',\n  'OpenAI Job Result Reply'\n)\nON CONFLICT (prompt_key, prompt_hash) DO NOTHING;"
      },
      "id": "19",
      "name": "Record Prompt History (Job Result Reply)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        1900,
        440
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "operation": "complete",
        "model": "={{$env.OPENAI_MODEL || 'gpt-4o-mini'}}",
        "prompt": {
          "messages": [
            {
              "role": "system",
              "content": "={{ $node['Build Job Result Reply Prompt (JP)'].json.prompt_text }}"
            },
            {
              "role": "user",
              "content": "={{ '入力:\\n' + $node['Build Job Result Reply Prompt (JP)'].json.prompt_input }}"
            }
          ]
        },
        "options": {
          "temperature": 0.2,
          "baseURL": "={{$env.OPENAI_BASE_URL}}",
          "maxTokens": "={{$json.policy_context?.limits?.llm_output_tokens || 1200}}"
        }
      },
      "id": "20",
      "name": "OpenAI Job Result Reply",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        2140,
        440
      ],
      "credentials": {
        "openAiApi": {
          "name": "aiops-openai"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const base = $node['Build Job Result Reply Prompt (JP)'].json ?? {};\nconst response = $json ?? {};\n\nfunction normalizeNewlines(raw) {\n  let text = String(raw ?? '');\n  if (!text) return text;\n  // Normalize actual CRLF/CR\n  text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  // Normalize double-escaped sequences (e.g., \"\\\\n\")\n  text = text.replace(/\\\\r\\\\n/g, '\\n').replace(/\\\\n/g, '\\n').replace(/\\\\r/g, '\\n');\n  return text;\n}\n\nconst extractContent = (payload) => {\n  return payload?.choices?.[0]?.message?.content\n    ?? payload?.choices?.[0]?.text\n    ?? payload?.data?.choices?.[0]?.message?.content\n    ?? '';\n};\n\nconst rawContent = extractContent(response);\nlet parsed = null;\nif (typeof rawContent === 'string') {\n  try {\n    parsed = JSON.parse(rawContent);\n  } catch (error) {\n    const match = rawContent.match(/\\{[\\s\\S]*\\}/);\n    if (match) {\n      try {\n        parsed = JSON.parse(match[0]);\n      } catch (inner) {\n        parsed = null;\n      }\n    }\n  }\n} else if (rawContent && typeof rawContent === 'object') {\n  parsed = rawContent;\n}\n\nconst isObject = (v) => Boolean(v) && typeof v === 'object' && !Array.isArray(v);\nconst ok = isObject(parsed) && typeof parsed.body === 'string';\n\nconst policyContext = base.policy_context ?? {};\nconst defaults = policyContext?.defaults?.job_result_reply ?? {};\nconst fallbacks = policyContext?.fallbacks?.job_result_reply ?? {};\n\nconst jobResult = base.job_result ?? {};\nconst status = jobResult.status ?? 'unknown';\nconst traceId = jobResult.trace_id ?? base.trace_id ?? null;\n\nconst maxChars = Number.isFinite(Number(policyContext?.limits?.job_result_reply?.max_payload_chars))\n  ? Math.max(0, Math.floor(Number(policyContext.limits.job_result_reply.max_payload_chars)))\n  : null;\n\nconst stringifyPayload = (payload) => {\n  if (payload === null || payload === undefined) return '(none)';\n  const raw = typeof payload === 'string' ? payload : JSON.stringify(payload);\n  if (maxChars <= 0) return raw;\n  return raw.length > maxChars ? raw.slice(0, maxChars) : raw;\n};\n\nconst statusGroups = policyContext?.rules?.job_result_reply?.status_groups ?? {};\nconst normalize = (value) => String(value ?? '').trim().toLowerCase();\nconst statusValue = normalize(status);\nconst matchesGroup = (group) => Array.isArray(group) && group.map(normalize).includes(statusValue);\nconst isSuccess = matchesGroup(statusGroups.success);\nconst isFailure = matchesGroup(statusGroups.failure);\n\nconst fallbackTemplate = isSuccess\n  ? (defaults.success_template ?? fallbacks.success_template)\n  : isFailure\n    ? (defaults.failure_template ?? fallbacks.failure_template)\n    : (defaults.unknown_status_template ?? fallbacks.unknown_status_template ?? defaults.failure_template ?? fallbacks.failure_template);\nconst traceLine = traceId ? `\\nTrace: ${traceId}` : '';\nconst feedbackRequestText = base.feedback_request_text ? normalizeNewlines(base.feedback_request_text) : '';\nconst feedbackRequest = feedbackRequestText ? `\\n\\n${feedbackRequestText}` : '';\n\nconst render = (template) => String(template || '')\n  .split('{job_id}').join(String(jobResult.job_id ?? ''))\n  .split('{result}').join(stringifyPayload(jobResult.result_payload))\n  .split('{error}').join(stringifyPayload(jobResult.error_payload))\n  .split('{trace_line}').join(traceLine)\n  .split('{feedback_request}').join(feedbackRequest);\n\nconst content = normalizeNewlines(ok ? parsed.body : render(fallbackTemplate));\nif (ok) {\n  parsed.body = content;\n}\n\nreturn [{\n  json: {\n    ...base,\n    llm_job_result_ok: ok,\n    job_result_reply: ok ? parsed : null,\n    content,\n    source: base.source ?? base.reply_target?.source ?? 'unknown',\n    job_id: jobResult.job_id ?? null\n  }\n}];\n"
      },
      "id": "21",
      "name": "Parse Job Result Reply Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2380,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Webhook (Job Callback)',\n  target: 'Respond 200',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "22",
      "name": "Debug Log After: Webhook (Job Callback) -> Respond 200",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        380,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Webhook (Job Callback)',\n  target: 'Respond 200',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "23",
      "name": "Debug Log Before: Respond 200 <- Webhook (Job Callback)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Webhook (Job Callback)',\n  target: 'Load Context + Save Result',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "24",
      "name": "Debug Log After: Webhook (Job Callback) -> Load Context + Save Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        380,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Webhook (Job Callback)',\n  target: 'Load Context + Save Result',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "25",
      "name": "Debug Log Before: Load Context + Save Result <- Webhook (Job Callback)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Load Context + Save Result',\n  target: 'Build Feedback Request Prompt (JP)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "26",
      "name": "Debug Log After: Load Context + Save Result -> Build Feedback Request Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Load Context + Save Result',\n  target: 'Build Feedback Request Prompt (JP)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "27",
      "name": "Debug Log Before: Build Feedback Request Prompt (JP) <- Load Context + Save Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        560,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Zulip Source',\n  target: 'Post to Zulip',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems",
        "url": "={{ (() => {\n  const tenant = $json.reply_target?.tenant ?? $json.reply_target?.realm ?? '';\n  const jsonRaw = $env.N8N_ZULIP_API_BASE_URL || '';\n  const yamlRaw = $env.N8N_ZULIP_API_BASE_URL || '';\n  const fallback = $env.N8N_ZULIP_API_BASE_URL || $env.ZULIP_API_BASE_URL || '';\n  const parseYaml = (text) => {\n    const map = {};\n    String(text).split(/\\r?\\n/).forEach((line) => {\n      const trimmed = line.trim();\n      if (!trimmed || trimmed.startsWith('#')) return;\n      const idx = trimmed.indexOf(':');\n      if (idx <= 0) return;\n      const key = trimmed.slice(0, idx).trim();\n      let value = trimmed.slice(idx + 1).trim();\n      if (!key) return;\n      value = value.replace(/^['\"]|['\"]$/g, '');\n      map[key] = value;\n    });\n    return map;\n  };\n  let map = {};\n  if (jsonRaw) {\n    try {\n      const parsed = JSON.parse(jsonRaw);\n      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n        map = parsed;\n      }\n    } catch (error) {}\n  }\n  if (!Object.keys(map).length && yamlRaw) {\n    map = parseYaml(yamlRaw);\n  }\n  const base = (tenant && map[tenant]) ? map[tenant] : (map.default || fallback);\n  const trimmed = base ? String(base).replace(/\\/+$/, '') : '';\n  if (!trimmed) return '';\n  const apiBase = trimmed.endsWith('/api/v1') ? trimmed : (trimmed + '/api/v1');\n  return apiBase + '/messages';\n})() }}",
        "sendHeaders": true,
        "specifyHeaders": "keypair",
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "={{ (() => {\n  const tenant = $json.reply_target?.tenant ?? $json.reply_target?.realm ?? '';\n  const tokenJsonRaw = $env.N8N_ZULIP_BOT_TOKEN || '';\n  const tokenYamlRaw = $env.ZULIP_BOT_TOKEN || $env.N8N_ZULIP_BOT_TOKEN || '';\n  const emailJsonRaw = $env.N8N_ZULIP_BOT_EMAIL || '';\n  const emailYamlRaw = $env.N8N_ZULIP_BOT_EMAIL || '';\n  const fallbackToken = $env.N8N_ZULIP_BOT_TOKEN || $env.ZULIP_BOT_TOKEN || '';\n  const fallbackEmail = $env.N8N_ZULIP_BOT_EMAIL || $env.ZULIP_BOT_EMAIL || '';\n  const parseYaml = (text) => {\n    const map = {};\n    String(text).split(/\\r?\\n/).forEach((line) => {\n      const trimmed = line.trim();\n      if (!trimmed || trimmed.startsWith('#')) return;\n      const idx = trimmed.indexOf(':');\n      if (idx <= 0) return;\n      const key = trimmed.slice(0, idx).trim();\n      let value = trimmed.slice(idx + 1).trim();\n      if (!key) return;\n      value = value.replace(/^['\"]|['\"]$/g, '');\n      map[key] = value;\n    });\n    return map;\n  };\n  const parseMap = (jsonRaw, yamlRaw) => {\n    let map = {};\n    if (jsonRaw) {\n      try {\n        const parsed = JSON.parse(jsonRaw);\n        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n          map = parsed;\n        }\n      } catch (error) {}\n    }\n    if (!Object.keys(map).length && yamlRaw) {\n      map = parseYaml(yamlRaw);\n    }\n    return map;\n  };\n  const tokenMap = parseMap(tokenJsonRaw, tokenYamlRaw);\n  const emailMap = parseMap(emailJsonRaw, emailYamlRaw);\n  const token = (tenant && tokenMap[tenant]) ? tokenMap[tenant] : (tokenMap.default || fallbackToken);\n  const email = (tenant && emailMap[tenant]) ? emailMap[tenant] : (emailMap.default || fallbackEmail);\n  if (!email || !token) return '';\n  return 'Basic ' + Buffer.from(email + ':' + token).toString('base64');\n})() }}"
            }
          ]
        }
      },
      "id": "28",
      "name": "Debug Log After: IF Zulip Source -> Post to Zulip",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        120
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Zulip Source',\n  target: 'Post to Zulip',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems",
        "url": "={{ (() => {\n  const tenant = $json.reply_target?.tenant ?? $json.reply_target?.realm ?? '';\n  const jsonRaw = $env.N8N_ZULIP_API_BASE_URL || '';\n  const yamlRaw = $env.N8N_ZULIP_API_BASE_URL || '';\n  const fallback = $env.N8N_ZULIP_API_BASE_URL || $env.ZULIP_API_BASE_URL || '';\n  const parseYaml = (text) => {\n    const map = {};\n    String(text).split(/\\r?\\n/).forEach((line) => {\n      const trimmed = line.trim();\n      if (!trimmed || trimmed.startsWith('#')) return;\n      const idx = trimmed.indexOf(':');\n      if (idx <= 0) return;\n      const key = trimmed.slice(0, idx).trim();\n      let value = trimmed.slice(idx + 1).trim();\n      if (!key) return;\n      value = value.replace(/^['\"]|['\"]$/g, '');\n      map[key] = value;\n    });\n    return map;\n  };\n  let map = {};\n  if (jsonRaw) {\n    try {\n      const parsed = JSON.parse(jsonRaw);\n      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n        map = parsed;\n      }\n    } catch (error) {}\n  }\n  if (!Object.keys(map).length && yamlRaw) {\n    map = parseYaml(yamlRaw);\n  }\n  const base = (tenant && map[tenant]) ? map[tenant] : (map.default || fallback);\n  const trimmed = base ? String(base).replace(/\\/+$/, '') : '';\n  if (!trimmed) return '';\n  const apiBase = trimmed.endsWith('/api/v1') ? trimmed : (trimmed + '/api/v1');\n  return apiBase + '/messages';\n})() }}",
        "sendHeaders": true,
        "specifyHeaders": "keypair",
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "={{ (() => {\n  const tenant = $json.reply_target?.tenant ?? $json.reply_target?.realm ?? '';\n  const tokenJsonRaw = $env.N8N_ZULIP_BOT_TOKEN || '';\n  const tokenYamlRaw = $env.ZULIP_BOT_TOKEN || $env.N8N_ZULIP_BOT_TOKEN || '';\n  const emailJsonRaw = $env.N8N_ZULIP_BOT_EMAIL || '';\n  const emailYamlRaw = $env.N8N_ZULIP_BOT_EMAIL || '';\n  const fallbackToken = $env.N8N_ZULIP_BOT_TOKEN || $env.ZULIP_BOT_TOKEN || '';\n  const fallbackEmail = $env.N8N_ZULIP_BOT_EMAIL || $env.ZULIP_BOT_EMAIL || '';\n  const parseYaml = (text) => {\n    const map = {};\n    String(text).split(/\\r?\\n/).forEach((line) => {\n      const trimmed = line.trim();\n      if (!trimmed || trimmed.startsWith('#')) return;\n      const idx = trimmed.indexOf(':');\n      if (idx <= 0) return;\n      const key = trimmed.slice(0, idx).trim();\n      let value = trimmed.slice(idx + 1).trim();\n      if (!key) return;\n      value = value.replace(/^['\"]|['\"]$/g, '');\n      map[key] = value;\n    });\n    return map;\n  };\n  const parseMap = (jsonRaw, yamlRaw) => {\n    let map = {};\n    if (jsonRaw) {\n      try {\n        const parsed = JSON.parse(jsonRaw);\n        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n          map = parsed;\n        }\n      } catch (error) {}\n    }\n    if (!Object.keys(map).length && yamlRaw) {\n      map = parseYaml(yamlRaw);\n    }\n    return map;\n  };\n  const tokenMap = parseMap(tokenJsonRaw, tokenYamlRaw);\n  const emailMap = parseMap(emailJsonRaw, emailYamlRaw);\n  const token = (tenant && tokenMap[tenant]) ? tokenMap[tenant] : (tokenMap.default || fallbackToken);\n  const email = (tenant && emailMap[tenant]) ? emailMap[tenant] : (emailMap.default || fallbackEmail);\n  if (!email || !token) return '';\n  return 'Basic ' + Buffer.from(email + ':' + token).toString('base64');\n})() }}"
            }
          ]
        }
      },
      "id": "29",
      "name": "Debug Log Before: Post to Zulip <- IF Zulip Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1240,
        120
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Zulip Source',\n  target: 'IF Slack Source',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "30",
      "name": "Debug Log After: IF Zulip Source -> IF Slack Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        180
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Zulip Source',\n  target: 'IF Slack Source',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "31",
      "name": "Debug Log Before: IF Slack Source <- IF Zulip Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Slack Source',\n  target: 'Post to Slack',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "32",
      "name": "Debug Log After: IF Slack Source -> Post to Slack",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Slack Source',\n  target: 'Post to Slack',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "33",
      "name": "Debug Log Before: Post to Slack <- IF Slack Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1340,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Slack Source',\n  target: 'IF Mattermost Source',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "34",
      "name": "Debug Log After: IF Slack Source -> IF Mattermost Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Slack Source',\n  target: 'IF Mattermost Source',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "35",
      "name": "Debug Log Before: IF Mattermost Source <- IF Slack Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        360
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Mattermost Source',\n  target: 'Post to Mattermost',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "36",
      "name": "Debug Log After: IF Mattermost Source -> Post to Mattermost",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        360
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Mattermost Source',\n  target: 'Post to Mattermost',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "37",
      "name": "Debug Log Before: Post to Mattermost <- IF Mattermost Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1340,
        360
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Mattermost Source',\n  target: 'IF Teams Source',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "38",
      "name": "Debug Log After: IF Mattermost Source -> IF Teams Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Mattermost Source',\n  target: 'IF Teams Source',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "39",
      "name": "Debug Log Before: IF Teams Source <- IF Mattermost Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Teams Source',\n  target: 'Post to Teams',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "40",
      "name": "Debug Log After: IF Teams Source -> Post to Teams",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Teams Source',\n  target: 'Post to Teams',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "41",
      "name": "Debug Log Before: Post to Teams <- IF Teams Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1340,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'IF Teams Source',\n  target: 'Log Unknown Source',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "42",
      "name": "Debug Log After: IF Teams Source -> Log Unknown Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        540
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'IF Teams Source',\n  target: 'Log Unknown Source',\n  output_index: 1,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "43",
      "name": "Debug Log Before: Log Unknown Source <- IF Teams Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1340,
        600
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Feedback Request Prompt (JP)',\n  target: 'Record Prompt History (Feedback Request)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "44",
      "name": "Debug Log After: Build Feedback Request Prompt (JP) -> Record Prompt History (Feedback Request)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        840,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Feedback Request Prompt (JP)',\n  target: 'Record Prompt History (Feedback Request)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "45",
      "name": "Debug Log Before: Record Prompt History (Feedback Request) <- Build Feedback Request Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Record Prompt History (Feedback Request)',\n  target: 'OpenAI Feedback Request Render',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "46",
      "name": "Debug Log After: Record Prompt History (Feedback Request) -> OpenAI Feedback Request Render",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1080,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Record Prompt History (Feedback Request)',\n  target: 'OpenAI Feedback Request Render',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "47",
      "name": "Debug Log Before: OpenAI Feedback Request Render <- Record Prompt History (Feedback Request)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'OpenAI Feedback Request Render',\n  target: 'Parse Feedback Request Response',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "48",
      "name": "Debug Log After: OpenAI Feedback Request Render -> Parse Feedback Request Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1320,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'OpenAI Feedback Request Render',\n  target: 'Parse Feedback Request Response',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "49",
      "name": "Debug Log Before: Parse Feedback Request Response <- OpenAI Feedback Request Render",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1280,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Parse Feedback Request Response',\n  target: 'Build Job Result Reply Prompt (JP)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "50",
      "name": "Debug Log After: Parse Feedback Request Response -> Build Job Result Reply Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1560,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Parse Feedback Request Response',\n  target: 'Build Job Result Reply Prompt (JP)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "51",
      "name": "Debug Log Before: Build Job Result Reply Prompt (JP) <- Parse Feedback Request Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1520,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Build Job Result Reply Prompt (JP)',\n  target: 'Record Prompt History (Job Result Reply)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "52",
      "name": "Debug Log After: Build Job Result Reply Prompt (JP) -> Record Prompt History (Job Result Reply)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Build Job Result Reply Prompt (JP)',\n  target: 'Record Prompt History (Job Result Reply)',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "53",
      "name": "Debug Log Before: Record Prompt History (Job Result Reply) <- Build Job Result Reply Prompt (JP)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Record Prompt History (Job Result Reply)',\n  target: 'OpenAI Job Result Reply',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "54",
      "name": "Debug Log After: Record Prompt History (Job Result Reply) -> OpenAI Job Result Reply",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2040,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Record Prompt History (Job Result Reply)',\n  target: 'OpenAI Job Result Reply',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "55",
      "name": "Debug Log Before: OpenAI Job Result Reply <- Record Prompt History (Job Result Reply)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2000,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'OpenAI Job Result Reply',\n  target: 'Parse Job Result Reply Response',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "56",
      "name": "Debug Log After: OpenAI Job Result Reply -> Parse Job Result Reply Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2280,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'OpenAI Job Result Reply',\n  target: 'Parse Job Result Reply Response',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "57",
      "name": "Debug Log Before: Parse Job Result Reply Response <- OpenAI Job Result Reply",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2240,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'after',\n  source: 'Parse Job Result Reply Response',\n  target: 'IF Zulip Source',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "58",
      "name": "Debug Log After: Parse Job Result Reply Response -> IF Zulip Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2520,
        440
      ]
    },
    {
      "parameters": {
        "jsCode": "const debugFlag = String($env.N8N_DEBUG_LOG || '').toLowerCase();\nconst enabled = ['1', 'true', 'yes', 'y', 'on'].includes(debugFlag);\nif (!enabled) {\n  return $input.all();\n}\n\nconst maxItemsRaw = $env.N8N_DEBUG_LOG_MAX_ITEMS || '5';\nconst maxItems = Number.isFinite(Number(maxItemsRaw)) ? Number(maxItemsRaw) : 5;\nconst items = $input.all();\nconst sample = items.slice(0, Math.max(0, maxItems));\n\nfunction mask(value, depth = 0) {\n  if (depth > 4) return '[max-depth]';\n  if (Array.isArray(value)) {\n    return value.map((entry) => mask(entry, depth + 1));\n  }\n  if (value && typeof value === 'object') {\n    const result = {};\n    for (const [key, raw] of Object.entries(value)) {\n      const keyLower = String(key).toLowerCase();\n      if (keyLower.includes('token') || keyLower.includes('secret') || keyLower.includes('password') || keyLower.includes('authorization') || keyLower.includes('cookie') || keyLower.includes('api_key') || keyLower.includes('apikey')) {\n        result[key] = '***';\n      } else {\n        result[key] = mask(raw, depth + 1);\n      }\n    }\n    return result;\n  }\n  return value;\n}\n\nconst payload = sample.map((item) => mask(item.json));\nconst line = JSON.stringify({\n  tag: 'n8n_debug',\n  phase: 'before',\n  source: 'Parse Job Result Reply Response',\n  target: 'IF Zulip Source',\n  output_index: 0,\n  items_total: items.length,\n  items: payload\n});\n\ntry {\n  if (this?.logger?.info) {\n    this.logger.info(line);\n  } else {\n    console.log(line);\n  }\n} catch (error) {\n  console.log(line);\n}\n\nconst observerUrl = $env.N8N_OBSERVER_URL;\nconst observerToken = $env.N8N_OBSERVER_TOKEN;\n\nif (observerUrl && observerToken) {\n  let event = null;\n  try {\n    event = JSON.parse(line);\n  } catch (error) {\n    event = { tag: 'n8n_debug', raw: String(line ?? '') };\n  }\n\n  const payloadForObserver = {\n    kind: 'n8n.debug_log',\n    realm: $env.N8N_OBSERVER_REALM ?? null,\n    workflow: $workflow.name,\n    execution_id: $execution.id,\n    sent_at: new Date().toISOString(),\n    event\n  };\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: observerUrl,\n      json: true,\n      headers: {\n        'X-Observer-Token': observerToken\n      },\n      body: payloadForObserver,\n      timeout: 5000\n    });\n  } catch (error) {\n    // Observability must never break production workflows.\n  }\n}\nreturn $input.all();\n",
        "mode": "runOnceForAllItems"
      },
      "id": "59",
      "name": "Debug Log Before: IF Zulip Source <- Parse Job Result Reply Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        120
      ]
    }
  ],
  "connections": {
    "Webhook (Job Callback)": {
      "main": [
        [
          {
            "node": "Debug Log After: Webhook (Job Callback) -> Respond 200",
            "type": "main",
            "index": 0
          },
          {
            "node": "Debug Log After: Webhook (Job Callback) -> Load Context + Save Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Context + Save Result": {
      "main": [
        [
          {
            "node": "Debug Log After: Load Context + Save Result -> Build Feedback Request Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Zulip Source": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Zulip Source -> Post to Zulip",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Zulip Source -> IF Slack Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Slack Source": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Slack Source -> Post to Slack",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Slack Source -> IF Mattermost Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Mattermost Source": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Mattermost Source -> Post to Mattermost",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Mattermost Source -> IF Teams Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Teams Source": {
      "main": [
        [
          {
            "node": "Debug Log After: IF Teams Source -> Post to Teams",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug Log After: IF Teams Source -> Log Unknown Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Feedback Request Prompt (JP)": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Feedback Request Prompt (JP) -> Record Prompt History (Feedback Request)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Record Prompt History (Feedback Request)": {
      "main": [
        [
          {
            "node": "Debug Log After: Record Prompt History (Feedback Request) -> OpenAI Feedback Request Render",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Feedback Request Render": {
      "main": [
        [
          {
            "node": "Debug Log After: OpenAI Feedback Request Render -> Parse Feedback Request Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Feedback Request Response": {
      "main": [
        [
          {
            "node": "Debug Log After: Parse Feedback Request Response -> Build Job Result Reply Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Job Result Reply Prompt (JP)": {
      "main": [
        [
          {
            "node": "Debug Log After: Build Job Result Reply Prompt (JP) -> Record Prompt History (Job Result Reply)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Record Prompt History (Job Result Reply)": {
      "main": [
        [
          {
            "node": "Debug Log After: Record Prompt History (Job Result Reply) -> OpenAI Job Result Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Job Result Reply": {
      "main": [
        [
          {
            "node": "Debug Log After: OpenAI Job Result Reply -> Parse Job Result Reply Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Job Result Reply Response": {
      "main": [
        [
          {
            "node": "Debug Log After: Parse Job Result Reply Response -> IF Zulip Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Webhook (Job Callback) -> Respond 200": {
      "main": [
        [
          {
            "node": "Debug Log Before: Respond 200 <- Webhook (Job Callback)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Respond 200 <- Webhook (Job Callback)": {
      "main": [
        [
          {
            "node": "Respond 200",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Webhook (Job Callback) -> Load Context + Save Result": {
      "main": [
        [
          {
            "node": "Debug Log Before: Load Context + Save Result <- Webhook (Job Callback)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Load Context + Save Result <- Webhook (Job Callback)": {
      "main": [
        [
          {
            "node": "Load Context + Save Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Load Context + Save Result -> Build Feedback Request Prompt (JP)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Feedback Request Prompt (JP) <- Load Context + Save Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Feedback Request Prompt (JP) <- Load Context + Save Result": {
      "main": [
        [
          {
            "node": "Build Feedback Request Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Zulip Source -> Post to Zulip": {
      "main": [
        [
          {
            "node": "Debug Log Before: Post to Zulip <- IF Zulip Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Post to Zulip <- IF Zulip Source": {
      "main": [
        [
          {
            "node": "Post to Zulip",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Zulip Source -> IF Slack Source": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Slack Source <- IF Zulip Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Slack Source <- IF Zulip Source": {
      "main": [
        [
          {
            "node": "IF Slack Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Slack Source -> Post to Slack": {
      "main": [
        [
          {
            "node": "Debug Log Before: Post to Slack <- IF Slack Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Post to Slack <- IF Slack Source": {
      "main": [
        [
          {
            "node": "Post to Slack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Slack Source -> IF Mattermost Source": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Mattermost Source <- IF Slack Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Mattermost Source <- IF Slack Source": {
      "main": [
        [
          {
            "node": "IF Mattermost Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Mattermost Source -> Post to Mattermost": {
      "main": [
        [
          {
            "node": "Debug Log Before: Post to Mattermost <- IF Mattermost Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Post to Mattermost <- IF Mattermost Source": {
      "main": [
        [
          {
            "node": "Post to Mattermost",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Mattermost Source -> IF Teams Source": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Teams Source <- IF Mattermost Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Teams Source <- IF Mattermost Source": {
      "main": [
        [
          {
            "node": "IF Teams Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Teams Source -> Post to Teams": {
      "main": [
        [
          {
            "node": "Debug Log Before: Post to Teams <- IF Teams Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Post to Teams <- IF Teams Source": {
      "main": [
        [
          {
            "node": "Post to Teams",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: IF Teams Source -> Log Unknown Source": {
      "main": [
        [
          {
            "node": "Debug Log Before: Log Unknown Source <- IF Teams Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Log Unknown Source <- IF Teams Source": {
      "main": [
        [
          {
            "node": "Log Unknown Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Feedback Request Prompt (JP) -> Record Prompt History (Feedback Request)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Record Prompt History (Feedback Request) <- Build Feedback Request Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Record Prompt History (Feedback Request) <- Build Feedback Request Prompt (JP)": {
      "main": [
        [
          {
            "node": "Record Prompt History (Feedback Request)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Record Prompt History (Feedback Request) -> OpenAI Feedback Request Render": {
      "main": [
        [
          {
            "node": "Debug Log Before: OpenAI Feedback Request Render <- Record Prompt History (Feedback Request)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: OpenAI Feedback Request Render <- Record Prompt History (Feedback Request)": {
      "main": [
        [
          {
            "node": "OpenAI Feedback Request Render",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: OpenAI Feedback Request Render -> Parse Feedback Request Response": {
      "main": [
        [
          {
            "node": "Debug Log Before: Parse Feedback Request Response <- OpenAI Feedback Request Render",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Parse Feedback Request Response <- OpenAI Feedback Request Render": {
      "main": [
        [
          {
            "node": "Parse Feedback Request Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Parse Feedback Request Response -> Build Job Result Reply Prompt (JP)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Build Job Result Reply Prompt (JP) <- Parse Feedback Request Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Build Job Result Reply Prompt (JP) <- Parse Feedback Request Response": {
      "main": [
        [
          {
            "node": "Build Job Result Reply Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Build Job Result Reply Prompt (JP) -> Record Prompt History (Job Result Reply)": {
      "main": [
        [
          {
            "node": "Debug Log Before: Record Prompt History (Job Result Reply) <- Build Job Result Reply Prompt (JP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Record Prompt History (Job Result Reply) <- Build Job Result Reply Prompt (JP)": {
      "main": [
        [
          {
            "node": "Record Prompt History (Job Result Reply)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Record Prompt History (Job Result Reply) -> OpenAI Job Result Reply": {
      "main": [
        [
          {
            "node": "Debug Log Before: OpenAI Job Result Reply <- Record Prompt History (Job Result Reply)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: OpenAI Job Result Reply <- Record Prompt History (Job Result Reply)": {
      "main": [
        [
          {
            "node": "OpenAI Job Result Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: OpenAI Job Result Reply -> Parse Job Result Reply Response": {
      "main": [
        [
          {
            "node": "Debug Log Before: Parse Job Result Reply Response <- OpenAI Job Result Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: Parse Job Result Reply Response <- OpenAI Job Result Reply": {
      "main": [
        [
          {
            "node": "Parse Job Result Reply Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log After: Parse Job Result Reply Response -> IF Zulip Source": {
      "main": [
        [
          {
            "node": "Debug Log Before: IF Zulip Source <- Parse Job Result Reply Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Log Before: IF Zulip Source <- Parse Job Result Reply Response": {
      "main": [
        [
          {
            "node": "IF Zulip Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionTimeout": 300
  },
  "versionId": "00000000-0000-0000-0000-000000000000",
  "meta": {
    "aiops": {
      "purpose": "Adapter: job callback -> lookup context -> post reply"
    }
  }
}
