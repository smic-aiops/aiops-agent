{
  "name": "gitlab-mention-notify",
  "nodes": [
    {
      "parameters": {
        "path": "gitlab/mention/notify",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "1",
      "name": "Webhook (GitLab)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        240,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const headers = ($json && $json.headers) ? $json.headers : {};\nconst body = ($json && $json.body) ? $json.body : ($json ?? {});\n\nfunction getHeader(name) {\n  const lower = name.toLowerCase();\n  if (headers[lower] !== undefined) return headers[lower];\n  if (headers[name] !== undefined) return headers[name];\n  const key = Object.keys(headers).find((k) => k.toLowerCase() === lower);\n  return key ? headers[key] : undefined;\n}\n\nfunction error(status, message, extra = {}) {\n  return [{\n    json: {\n      ok: false,\n      status_code: status,\n      error: message,\n      ...extra\n    }\n  }];\n}\n\nfunction isTruthy(value) {\n  if (value === undefined || value === null) return false;\n  const v = String(value).toLowerCase();\n  return ['1', 'true', 'yes', 'y', 'on'].includes(v);\n}\n\nfunction pickFirst(paths, fallback = null) {\n  for (const path of paths) {\n    const parts = String(path).split('.').filter(Boolean);\n    let cur = body;\n    for (const part of parts) {\n      if (cur === null || cur === undefined) {\n        cur = undefined;\n        break;\n      }\n      cur = cur?.[part];\n    }\n    if (cur !== undefined && cur !== null && String(cur).trim() !== '') return cur;\n  }\n  return fallback;\n}\n\nfunction normalizeMention(raw) {\n  const trimmed = String(raw || '').trim();\n  const name = trimmed.startsWith('@') ? trimmed.slice(1) : trimmed;\n  return name.toLowerCase();\n}\n\nfunction stripCodeBlocks(text) {\n  let output = String(text || '');\n  output = output.replace(/```[\\s\\S]*?```/g, ' ');\n  output = output.replace(/`[^`]*`/g, ' ');\n  return output;\n}\n\nfunction stripUrls(text) {\n  let output = String(text || '');\n  output = output.replace(/https?:\\/\\/[^\\s<>()\\[\\]]+/gi, ' ');\n  output = output.replace(/\\bwww\\.[^\\s<>()\\[\\]]+/gi, ' ');\n  return output;\n}\n\nconst secret = $env.GITLAB_WEBHOOK_SECRET || '';\nif (!secret) {\n  return error(424, 'missing webhook secret', { missing: ['GITLAB_WEBHOOK_SECRET'] });\n}\nif (getHeader('x-gitlab-token') !== secret) {\n  return error(401, 'invalid token');\n}\n\nconst eventHeader = (getHeader('x-gitlab-event') || body.event_type || body.object_kind || '').toString();\nconst event = eventHeader.toLowerCase();\n\nconst texts = [];\nconst urls = [];\n\nfunction pushText(value) {\n  if (value === null || value === undefined) return;\n  const str = String(value).trim();\n  if (str) texts.push(str);\n}\n\nfunction pushUrl(value) {\n  if (value === null || value === undefined) return;\n  const str = String(value).trim();\n  if (str) urls.push(str);\n}\n\nconst actor = pickFirst([\n  'user.username',\n  'user.name',\n  'user_username',\n  'user_name',\n  'user.email',\n  'user_email'\n], 'unknown');\n\nconst project = body.project || {};\nconst projectId = project.id || body.project_id || null;\nconst projectPath = project.path_with_namespace || project.path || null;\n\nfunction deriveGitlabApiBaseUrl() {\n  const env = String($env.GITLAB_API_BASE_URL || '').trim();\n  if (env) return env.replace(/\\/+$/, '');\n\n  const hint = project?.web_url || '';\n  if (hint) {\n    try {\n      const u = new URL(hint);\n      return `${u.origin}/api/v4`;\n    } catch (err) {}\n  }\n\n  return '';\n}\n\n\nif (event.includes('wiki')) {\n  pushText(body.object_attributes?.content);\n  pushText(body.object_attributes?.title);\n  pushUrl(body.object_attributes?.url);\n  pushUrl(body.object_attributes?.url || body.object_attributes?.url || body.page?.url);\n}\n\nif (event.includes('issue')) {\n  pushText(body.object_attributes?.description);\n  pushText(body.object_attributes?.title);\n  pushUrl(body.object_attributes?.url);\n}\n\nif (event.includes('note') || body.object_kind === 'note') {\n  pushText(body.object_attributes?.note);\n  pushUrl(body.object_attributes?.url);\n  if (body.object_attributes?.noteable_type === 'Issue') {\n    pushUrl(body.issue?.url || body.object_attributes?.noteable_url);\n  }\n}\n\nif (event.includes('push')) {\n  const commits = Array.isArray(body.commits) ? body.commits : [];\n  const fileSet = new Set();\n  for (const commit of commits) {\n    for (const listKey of ['added', 'modified']) {\n      const paths = Array.isArray(commit?.[listKey]) ? commit[listKey] : [];\n      for (const path of paths) {\n        if (path) fileSet.add(String(path));\n      }\n    }\n  }\n\n  const maxFilesRaw = $env.GITLAB_MAX_FILES || '5';\n  const maxFiles = Number(maxFilesRaw) > 0 ? Number(maxFilesRaw) : 5;\n  const files = Array.from(fileSet)\n    .filter((path) => path.toLowerCase().endsWith('.md'))\n    .slice(0, maxFiles);\n\n  const ref = body.after || body.checkout_sha || (body.ref || '').replace('refs/heads/', '');\n  const apiBase = (deriveGitlabApiBaseUrl() || '').replace(/\\/$/, '');\n  const apiToken = $env.GITLAB_TOKEN || $env.GITLAB_ADMIN_TOKEN || '';\n\n  if (files.length) {\n    const missing = [];\n    if (!apiBase) missing.push('GITLAB_API_BASE_URL');\n    if (!apiToken) missing.push('GITLAB_TOKEN/GITLAB_ADMIN_TOKEN');\n    if (!projectId) missing.push('project.id/project_id');\n    if (!ref) missing.push('ref/after/checkout_sha');\n    if (missing.length) {\n      return error(424, 'missing GitLab API config for push markdown fetch', { missing, files });\n    }\n  }\n\n  let fetchedCount = 0;\n  const fetchErrors = [];\n  if (apiBase && apiToken && projectId && ref && files.length) {\n    const httpRequest = this.helpers.httpRequest;\n    for (const filePath of files) {\n      try {\n        const url = `${apiBase}/projects/${encodeURIComponent(projectId)}/repository/files/${encodeURIComponent(filePath)}?ref=${encodeURIComponent(ref)}`;\n        const res = await httpRequest({\n          method: 'GET',\n          url,\n          headers: { 'PRIVATE-TOKEN': apiToken }\n        });\n        const encoded = res?.content || '';\n        if (encoded) {\n          const decoded = Buffer.from(encoded, 'base64').toString('utf8');\n          if (decoded) {\n            pushText(decoded);\n            fetchedCount += 1;\n          }\n        } else {\n          fetchErrors.push({ file: filePath, error: 'missing content' });\n        }\n      } catch (err) {\n        fetchErrors.push({ file: filePath, error: String(err?.message || err) });\n      }\n    }\n  }\n\n  if (files.length && fetchedCount == 0) {\n    return error(502, 'failed to fetch markdown files from GitLab', { files, fetchErrors });\n  }\n\n  pushUrl(body.compare);\n  pushUrl(project.web_url);\n}\n\nif (!urls.length && project?.web_url) {\n  pushUrl(project.web_url);\n}\n\nconst rawText = texts.join('\\n\\n');\nconst cleanedText = stripUrls(stripCodeBlocks(rawText));\nconst mentionRegex = /(?:^|[^A-Za-z0-9_.-])@([A-Za-z0-9][A-Za-z0-9_.-]{0,31})(?=[^A-Za-z0-9_.-]|$)/g;\nconst excludeRaw = $env.GITLAB_MENTION_EXCLUDE_WORDS || 'all,group,here,channel,everyone';\nconst exclude = new Set(\n  excludeRaw\n    .split(',')\n    .map((v) => v.trim().toLowerCase())\n    .filter(Boolean)\n);\n\nconst mentions = [];\nconst seen = new Set();\nlet match = null;\nwhile ((match = mentionRegex.exec(cleanedText)) !== null) {\n  const username = match[1];\n  const nextChar = cleanedText[mentionRegex.lastIndex] || '';\n  const key = username.toLowerCase();\n  if (nextChar === '/') continue;\n  if (exclude.has(key)) continue;\n  if (seen.has(key)) continue;\n  seen.add(key);\n  mentions.push({ raw: username, key });\n}\n\nif (!mentions.length) {\n  return [{ json: { ok: true, status_code: 200, event: eventHeader, mentions: [], sent: 0, reason: 'no_mentions' } }];\n}\n\nfunction splitTableRow(line) {\n  const parts = String(line).split('|');\n  if (parts.length < 3) return [];\n  parts.shift();\n  parts.pop();\n  return parts.map((value) => value.trim());\n}\n\nfunction parseMappingMarkdown(md) {\n  const lines = String(md).split(/\\r?\\n/).filter((line) => line.trim().startsWith('|'));\n  if (lines.length < 2) return {};\n  const header = splitTableRow(lines[0]).map((h) => h.toLowerCase());\n  const map = {};\n  for (let i = 1; i < lines.length; i += 1) {\n    const cols = splitTableRow(lines[i]);\n    if (cols.every((col) => /^-+$/.test(col))) continue;\n    const entry = {};\n    for (let j = 0; j < header.length; j += 1) {\n      entry[header[j]] = cols[j] || '';\n    }\n    const mention = entry.gitlab_mention || entry.mention || '';\n    if (!mention) continue;\n    const key = normalizeMention(mention);\n    const zulipUserId = Number(entry.zulip_user_id || entry.zulip_id || '');\n    const zulipEmail = entry.zulip_email || entry.keycloak_email || '';\n    map[key] = {\n      zulip_user_id: Number.isFinite(zulipUserId) ? zulipUserId : null,\n      zulip_email: zulipEmail || null\n    };\n  }\n  return map;\n}\n\nasync function loadMapping() {\n  const envJson = $env.ZULIP_USER_MAP_JSON || '';\n  if (envJson) {\n    try {\n      const parsed = JSON.parse(envJson);\n      const normalized = {};\n      for (const [key, value] of Object.entries(parsed)) {\n        const norm = normalizeMention(key);\n        normalized[norm] = value;\n      }\n      return normalized;\n    } catch (err) {\n      return {};\n    }\n  }\n\n  const apiBase = (deriveGitlabApiBaseUrl() || '').replace(/\\/$/, '');\n  const apiToken = $env.GITLAB_TOKEN || $env.GITLAB_ADMIN_TOKEN || '';\n  const mappingPath = $env.GITLAB_MENTION_MAPPING_PATH || 'docs/mention_user_mapping.md';\n  const ref = $env.GITLAB_REF || 'main';\n  const mappingProject = $env.GITLAB_MENTION_MAPPING_PROJECT_ID\n    || $env.GITLAB_MENTION_MAPPING_PROJECT_PATH\n    || projectId\n    || projectPath;\n\n  if (!apiBase || !apiToken || !mappingProject) return {};\n\n  const httpRequest = this.helpers.httpRequest;\n  const url = `${apiBase}/projects/${encodeURIComponent(mappingProject)}/repository/files/${encodeURIComponent(mappingPath)}?ref=${encodeURIComponent(ref)}`;\n  try {\n    const res = await httpRequest({\n      method: 'GET',\n      url,\n      headers: { 'PRIVATE-TOKEN': apiToken }\n    });\n    const encoded = res?.content || '';\n    const decoded = encoded ? Buffer.from(encoded, 'base64').toString('utf8') : '';\n    if (!decoded) return {};\n    return parseMappingMarkdown(decoded);\n  } catch (err) {\n    return {};\n  }\n}\n\nconst mapping = await loadMapping();\nconst recipients = new Map();\nconst unmapped = [];\n\nfor (const mention of mentions) {\n  const entry = mapping[mention.key] || mapping[`@${mention.key}`] || null;\n  if (!entry) {\n    unmapped.push(`@${mention.raw}`);\n    continue;\n  }\n  const zulipUserId = entry.zulip_user_id || entry.zulipUserId || null;\n  const zulipEmail = entry.zulip_email || entry.zulipEmail || entry.keycloak_email || null;\n  if (zulipUserId) {\n    const key = `id:${zulipUserId}`;\n    const current = recipients.get(key) || { to: zulipUserId, type: 'id', mentions: [] };\n    current.mentions.push(`@${mention.raw}`);\n    recipients.set(key, current);\n    continue;\n  }\n  if (zulipEmail) {\n    const key = `email:${zulipEmail}`;\n    const current = recipients.get(key) || { to: zulipEmail, type: 'email', mentions: [] };\n    current.mentions.push(`@${mention.raw}`);\n    recipients.set(key, current);\n    continue;\n  }\n  unmapped.push(`@${mention.raw}`);\n}\n\nif (!recipients.size) {\n  return [{ json: { ok: true, status_code: 200, event: eventHeader, mentions: mentions.map((m) => `@${m.raw}`), sent: 0, unmapped } }];\n}\n\nfunction parseYamlMap(text) {\n  const map = {};\n  String(text || '').split(/\\r?\\n/).forEach((line) => {\n    const trimmed = String(line || '').trim();\n    if (!trimmed || trimmed.startsWith('#')) return;\n    const idx = trimmed.indexOf(':');\n    if (idx <= 0) return;\n    const key = trimmed.slice(0, idx).trim();\n    let value = trimmed.slice(idx + 1).trim();\n    if (!key) return;\n    value = value.replace(/^['\"]|['\"]$/g, '');\n    map[key] = value;\n  });\n  return map;\n}\n\nfunction parseMap(jsonRaw, yamlRaw) {\n  let map = {};\n  if (jsonRaw) {\n    try {\n      const parsed = JSON.parse(jsonRaw);\n      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n        map = parsed;\n      }\n    } catch (err) {}\n  }\n  if (!Object.keys(map).length && yamlRaw) {\n    map = parseYamlMap(yamlRaw);\n  }\n  return map;\n}\n\nfunction deriveRealmFromProjectPath(path) {\n  const p = String(path || '').trim();\n  if (!p) return '';\n  const first = p.split('/')[0] || '';\n  return first.trim();\n}\n\nfunction normalizeZulipBaseUrl(base) {\n  let u = String(base || '').trim();\n  if (!u) return '';\n  u = u.replace(/\\/+$/, '');\n  if (u.endsWith('/api/v1')) u = u.slice(0, -'/api/v1'.length);\n  return u;\n}\n\nfunction resolveZulipCredentials(realm) {\n  const tenant = String(realm || '').trim();\n\n  const baseUrlMap = parseMap($env.ZULIP_API_MESS_BASE_URL || $env.N8N_ZULIP_API_BASE_URL || '', $env.ZULIP_API_MESS_BASE_URL || $env.N8N_ZULIP_API_BASE_URL || '');\n  const emailMap = parseMap($env.ZULIP_MESS_BOT_EMAIL || $env.N8N_ZULIP_BOT_EMAIL || '', $env.ZULIP_MESS_BOT_EMAIL || $env.N8N_ZULIP_BOT_EMAIL || '');\n  const tokenMap = parseMap($env.ZULIP_MESS_BOT_TOKEN || $env.N8N_ZULIP_BOT_TOKEN || '', ($env.ZULIP_MESS_BOT_TOKEN || $env.ZULIP_BOT_TOKEN || $env.N8N_ZULIP_BOT_TOKEN || ''));\n\n  const fallbackBase = $env.ZULIP_BASE_URL || $env.ZULIP_API_MESS_BASE_URL || $env.N8N_ZULIP_API_BASE_URL || $env.ZULIP_API_BASE_URL || '';\n  const fallbackEmail = $env.ZULIP_MESS_BOT_EMAIL || $env.ZULIP_BOT_EMAIL || $env.N8N_ZULIP_BOT_EMAIL || '';\n  const fallbackToken = $env.ZULIP_MESS_BOT_TOKEN || $env.ZULIP_BOT_API_KEY || $env.N8N_ZULIP_BOT_TOKEN || $env.ZULIP_BOT_TOKEN || '';\n\n  const baseRaw = (tenant && baseUrlMap[tenant]) ? baseUrlMap[tenant] : (baseUrlMap.default || fallbackBase);\n  const email = (tenant && emailMap[tenant]) ? emailMap[tenant] : (emailMap.default || fallbackEmail);\n  const token = (tenant && tokenMap[tenant]) ? tokenMap[tenant] : (tokenMap.default || fallbackToken);\n\n  return {\n    base_url: normalizeZulipBaseUrl(baseRaw),\n    email: String(email || '').trim(),\n    api_key: String(token || '').trim(),\n  };\n}\n\nconst realm = deriveRealmFromProjectPath(projectPath);\nconst zulipCreds = resolveZulipCredentials(realm);\nconst zulipBase = zulipCreds.base_url;\nconst zulipEmail = zulipCreds.email;\nconst zulipKey = zulipCreds.api_key;\nif (!zulipBase || !zulipEmail || !zulipKey) {\n  return error(500, 'Zulip credentials are missing', { missing: [\n    !zulipBase ? 'ZULIP_BASE_URL/N8N_ZULIP_API_BASE_URL' : null,\n    !zulipEmail ? 'ZULIP_BOT_EMAIL/N8N_ZULIP_BOT_EMAIL' : null,\n    !zulipKey ? 'ZULIP_BOT_API_KEY/N8N_ZULIP_BOT_TOKEN' : null,\n  ].filter(Boolean), realm });\n}\n\nconst resourceUrl = urls.find(Boolean) || '';\nconst snippet = cleanedText.slice(0, 300);\nconst dryRun = isTruthy($env.GITLAB_MENTION_NOTIFY_DRY_RUN);\nconst httpRequest = this.helpers.httpRequest;\n\nconst results = [];\nfor (const recipient of recipients.values()) {\n  const toValue = recipient.type === 'id' ? [Number(recipient.to)] : [recipient.to];\n  const lines = [\n    `GitLab update (${eventHeader || event || 'event'})`,\n    `Actor: ${actor}`,\n  ];\n  if (resourceUrl) lines.push(`URL: ${resourceUrl}`);\n  if (recipient.mentions.length) lines.push(`Mentions: ${recipient.mentions.join(', ')}`);\n  if (snippet) {\n    lines.push('');\n    lines.push(snippet);\n  }\n  const content = lines.join('\\n');\n\n  if (dryRun) {\n    results.push({ to: recipient.to, ok: true, dry_run: true });\n    continue;\n  }\n\n  const auth = Buffer.from(`${zulipEmail}:${zulipKey}`).toString('base64');\n  try {\n    const formBody = Object.entries({\n      type: 'direct',\n      to: JSON.stringify(toValue),\n      content,\n    })\n      .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(String(v))}`)\n      .join('&');\n\n    await httpRequest({\n      method: 'POST',\n      url: `${zulipBase}/api/v1/messages`,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Authorization: `Basic ${auth}`,\n      },\n      body: formBody,\n    });\n    results.push({ to: recipient.to, ok: true });\n  } catch (err) {\n    const status = err?.response?.statusCode || err?.statusCode || err?.httpCode || null;\n    const responseBody = err?.response?.body || err?.response?.data || null;\n    results.push({\n      to: recipient.to,\n      ok: false,\n      error: String(err?.message || err),\n      status_code: status,\n      response_body: responseBody,\n      realm,\n      zulip_base: zulipBase,\n    });\n  }\n}\n\nconst sentCount = results.filter((r) => r.ok).length;\nconst failedCount = results.filter((r) => !r.ok).length;\n\nreturn [{\n  json: {\n    ok: failedCount === 0,\n    status_code: failedCount === 0 ? 200 : 207,\n    event: eventHeader,\n    mentions: mentions.map((m) => `@${m.raw}`),\n    sent: sentCount,\n    failed: failedCount,\n    unmapped,\n    results\n  }\n}];"
      },
      "id": "2",
      "name": "Process + Notify",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        520,
        300
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": "={{ $json.status_code || 200 }}"
        }
      },
      "id": "3",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        780,
        300
      ]
    }
  ],
  "connections": {
    "Webhook (GitLab)": {
      "main": [
        [
          {
            "node": "Process + Notify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process + Notify": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
